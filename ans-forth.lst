  Wed Mar  9 2016 20:10                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The Forth data stack is DP
    27                        ;
    28                        ; The Y register holds the forth instruction pointer and the direct page
    29                        ; register is used to access the word address pointer and user variables.
    30                        ;
    31                        ;==============================================================================
    32                        ;------------------------------------------------------------------------------
    33                        
    34                                        pw      132
    35                                        inclist on
    36                                        maclist off
    37                        
    38                                        chip    65816
    39                                        longi   off
    40                                        longa   off
    41                        
    42                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
     7                        ;
     8                        ; Western Design Center W65C816 device definitions                                          
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
  Wed Mar  9 2016 20:10                                                                                                    Page 2


    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;===============================================================================
    25                        ; Revision History:
    26                        ;
    27                        ; 2015-12-18 AJ Initial version
    28                        ;-------------------------------------------------------------------------------
    29                        ; $Id$
    30                        ;-------------------------------------------------------------------------------
    31                        
    32                        ;==============================================================================
    33                        ; Status Register Bits
    34                        ;------------------------------------------------------------------------------
    35                        
    36             00000080   N_FLAG          equ     1<<7
    37             00000040   V_FLAG          equ     1<<6
    38             00000020   M_FLAG          equ     1<<5
    39             00000010   X_FLAG          equ     1<<4
    40             00000010   B_FLAG          equ     1<<4
    41             00000008   D_FLAG          equ     1<<3
    42             00000004   I_FLAG          equ     1<<2
    43             00000002   Z_FLAG          equ     1<<1
    44             00000001   C_FLAG          equ     1<<0
    45                        
    46                        ;==============================================================================
    47                        ; Macros
    48                        ;------------------------------------------------------------------------------
    49                        
    50                        ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
    51                        ; is fixed at $0100-$01ff. 
    52                        
    53                        emulate         macro
    54                                        sec
    55                                        xce
    56                                        endm
    57                        
    58                        ; Puts the processor in native mode. The size of the memory and index register
    59                        ; operations is not controlled by the M & X bits in the status register.
    60                        
    61                        native          macro
    62                                        clc
    63                                        xce
    64                                        endm
    65                        
    66                        ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
    67                         
    68                        long_a          macro
  Wed Mar  9 2016 20:10                                                                                                    Page 3


    69                                        rep     #M_FLAG
    70                                        longa   on
    71                                        endm
    72                        
    73                        ; Resets the X bit making the index registers 16-bits wide
    74                        
    75                        long_i          macro
    76                                        rep     #X_FLAG
    77                                        longi   on
    78                                        endm
    79                        
    80                        ; Resets the M and X bits making the accumulator, memory accesses and index
    81                        ; registers 16-bits wide.
    82                                        
    83                        long_ai         macro
    84                                        rep     #M_FLAG|X_FLAG
    85                                        longa   on
    86                                        longi   on
    87                                        endm
    88                        
    89                        ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
    90                        
    91                        short_a         macro
    92                                        sep     #M_FLAG
    93                                        longa   off
    94                                        endm
    95                        
    96                        ; Sets the X bit making the index registers 8-bits wide.
    97                        
    98                        short_i         macro
    99                                        sep     #X_FLAG
   100                                        longi   off
   101                                        endm
   102                                        
   103                        ; Sets the M & X bits making the accumulator, memory accesses and index
   104                        ; registers 8-bits wide.
   105                        
   106                        short_ai        macro
   107                                        sep     #M_FLAG|X_FLAG
   108                                        longa   off
   109                                        longi   off
   110                                        endm
    43                        
    44                        ;==============================================================================
    45                        ; Macros
    46                        ;------------------------------------------------------------------------------
    47                        
    48             00000000   COUNT           set     0                       ; Word counter
    49             00000000   WORD0           equ     0                       ; Null address for first word
    50                        
    51                        HEADER          macro   TYPE
    52                        WORD@<COUNT+1>:
    53                                        dw      WORD@<COUNT>
    54                                        db      TYPE
    55                        COUNT           set     COUNT+1
    56                                        endm
    57                        
    58             00000000   NORMAL          equ     $00
  Wed Mar  9 2016 20:10                                                                                                    Page 4


    59             00000080   IMMEDIATE       equ     $80
    60                        
    61                        TRAILER         macro
    62                        LAST_WORD       equ     WORD@<COUNT>
    63                                        endm
    64                        
    65                        ;==============================================================================
    66                        ; Definitions
    67                        ;------------------------------------------------------------------------------
    68                        
    69             00000014   USER_SIZE       equ     20
    70             00000080   DSTACK_SIZE     equ     128
    71             00000080   RSTACK_SIZE     equ     128
    72                        
    73             00000000   TO_IN_OFFSET    equ     0
    74             00000002   BASE_OFFSET     equ     2
    75             00000004   BLK_OFFSET      equ     4
    76             00000006   DP_OFFSET       equ     6
    77             00000008   LATEST_OFFSET   equ     8
    78             0000000A   SCR_OFFSET      equ     10
    79             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
    80             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
    81             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
    82             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
    83                        
    84             00000080   TIB_SIZE        equ     128
    85                        
    86                        ;==============================================================================
    87                        ; Data Areas
    88                        ;------------------------------------------------------------------------------
    89                        
    90                                        page0
    91                                        org     $00
    92                        
    93 00:0000:              USER_AREA       ds      USER_SIZE               ; User Variables
    94                        
    95                        
    96             00000100   DSTACK_START	equ	$0100
    97             00000180   DSTACK_END	equ	DSTACK_START+DSTACK_SIZE
    98                        
    99             00000180   RSTACK_START	equ	$0180
   100             00000200   RSTACK_END	equ	RSTACK_START+RSTACK_SIZE
   101                        
   102                        
   103                                        data
   104                                        org     $0200
   105                        
   106 00:0200:              TIB_AREA        ds      TIB_SIZE                ; Terminal Input Buffer
   107                        
   108                        ;==============================================================================
   109                        ; Forth Entry Point
   110                        ;------------------------------------------------------------------------------
   111                        
   112                        FORTH           section OFFSET $0400
   113                        
   114                                        public  Start
   115                        Start:
   116 00:0400: 18 FB                        native                          ; Go to native mode
  Wed Mar  9 2016 20:10                                                                                                    Page 5


   117 00:0402: C2 30                        long_ai                         ; And all 16-bit registers
   118 00:0404: A9 FF 01                     lda     #RSTACK_END-1           ; Initialise return stack
   119 00:0407: 1B                           tcs
   120 00:0408: A9 7F 01                     lda     #DSTACK_END-1           ; .. and data stack
   121 00:040B: 5B                           tcd
   122                        
   123 00:040C: A0 12 04                     ldy     #COLD                   ; Then perform COLD start
   124 00:040F: 4C E6 0D                     jmp     NEXT
   125                        
   126                        COLD:
   127 00:0412: 4C 05                        dw      DECIMAL
   128 00:0414: 01 05 81 04                  dw      ZERO,BLK,STORE
       00:0418: 72 05 
   129 00:041A: 25 05 EB 04                  dw      FALSE,STATE,STORE
       00:041E: 72 05 
   130 00:0420: 74 0F 74 0F                  dw      CR,CR,DO_S_QUOTE
       00:0424: 52 0F 
   131 00:0426: 23 48 61 6E                  db      35,"HandCoded W65C816 ANS-Forth [16.03]"
       00:042A: 64 43 6F 64 
       00:042E: 65 64 20 57 
       00:0432: 36 35 43 38 
       00:0436: 31 36 20 41 
       00:043A: 4E 53 2D 46 
       00:043E: 6F 72 74 68 
       00:0442: 20 5B 31 36 
       00:0446: 2E 30 33 5D 
   132 00:044A: EB 0F 74 0F                  dw      TYPE,CR,CR
       00:044E: 74 0F 
   133 00:0450: 81 0A                        dw      ABORT
   134                        
   135                        ;==============================================================================
   136                        ; System/User Variables
   137                        ;------------------------------------------------------------------------------
   138                        
   139                        ; #TIB ( -- a-addr )
   140                        ;
   141                        ; a-addr is the address of a cell containing the number of characters in the
   142                        ; terminal input buffer.
   143                        
   144 00:0452: 00 00 00                     HEADER  NORMAL
   145 00:0455: 04 23 54 49                  db      4,"#TIB"
       00:0459: 42 
   146 00:045A: 20 2D 0E     HASH_TIB:       jsr     DO_CONSTANT
   147 00:045D: 5F 04                        dw      $+2
   148 00:045F: 7E 00                        dw      TIB_SIZE-2
   149                        
   150                        ; >IN ( -- a-addr )
   151                        ;
   152                        ; a-addr is the address of a cell containing the offset in characters from the
   153                        ; start of the input buffer to the start of the parse area.
   154                        
   155 00:0461: 52 04 00                     HEADER  NORMAL
   156 00:0464: 03 3E 49 4E                  db      3,">IN"
   157 00:0468: 20 01 0F     TO_IN:          jsr     DO_USER
   158 00:046B: 00 00                        dw      TO_IN_OFFSET
   159                        
   160                        ; BASE ( -- a-addr )
   161                        ;
  Wed Mar  9 2016 20:10                                                                                                    Page 6


   162                        ; a-addr is the address of a cell containing the current number-conversion
   163                        ; radix {{2...36}}.
   164                        
   165 00:046D: 61 04 00                     HEADER  NORMAL
   166 00:0470: 04 42 41 53                  db      4,"BASE"
       00:0474: 45 
   167 00:0475: 20 01 0F     BASE:           jsr     DO_USER
   168 00:0478: 02 00                        dw      BASE_OFFSET
   169                        
   170                        ; BLK ( -- a-addr )
   171                        ;
   172                        ; a-addr is the address of a cell containing zero or the number of the mass-
   173                        ; storage block being interpreted. If BLK contains zero, the input source is
   174                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   175                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   176                        
   177 00:047A: 6D 04 00                     HEADER  NORMAL
   178 00:047D: 03 42 4C 4B                  db      3,"BLK"
   179 00:0481: 20 01 0F     BLK:            jsr     DO_USER
   180 00:0484: 04 00                        dw      BLK_OFFSET
   181                        
   182                        ; (BUFFER)
   183                        
   184 00:0486: 7A 04 00                     HEADER  NORMAL
   185 00:0489: 08 28 42 55                  db      8,"(BUFFER)"
       00:048D: 46 46 45 52 
       00:0491: 29 
   186 00:0492: 20 01 0F     BUFFER:         jsr     DO_USER
   187 00:0495: 10 00                        dw      BUFFER_OFFSET
   188                        
   189                        ; DP ( -- a-addr )
   190                        
   191 00:0497: 86 04 00                     HEADER  NORMAL
   192 00:049A: 02 44 50                     db      2,"DP"
   193 00:049D: 20 01 0F     DP:             jsr     DO_USER
   194 00:04A0: 06 00                        dw      DP_OFFSET
   195                        
   196                        ; LATEST ( -- a-addr )
   197                        
   198 00:04A2: 97 04 00                     HEADER  NORMAL
   199 00:04A5: 06 4C 41 54                  db      6,"LATEST"
       00:04A9: 45 53 54 
   200 00:04AC: 20 01 0F     LATEST:         jsr     DO_USER
   201 00:04AF: 08 00                        dw      LATEST_OFFSET
   202                        
   203                        ; (LENGTH)
   204                        
   205 00:04B1: A2 04 00                     HEADER  NORMAL
   206 00:04B4: 08 28 4C 45                  db      8,"(LENGTH)"
       00:04B8: 4E 47 54 48 
       00:04BC: 29 
   207 00:04BD: 20 01 0F     LENGTH:         jsr     DO_USER
   208 00:04C0: 12 00                        dw      LENGTH_OFFSET
   209                        
   210                        ; SCR ( -- a-addr )
   211                        ;
   212                        ; a-addr is the address of a cell containing the block number of the block most
   213                        ; recently LISTed.
  Wed Mar  9 2016 20:10                                                                                                    Page 7


   214                        
   215 00:04C2: B1 04 00                     HEADER  NORMAL
   216 00:04C5: 03 53 43 52                  db      3,"SCR"
   217 00:04C9: 20 01 0F     SCR:            jsr     DO_USER
   218 00:04CC: 0A 00                        dw      SCR_OFFSET
   219                        
   220                        ; (SOURCE-ID)
   221                        
   222 00:04CE: C2 04 00                     HEADER  NORMAL
   223 00:04D1: 0B 28 53 4F                  db      11,"(SOURCE-ID)"
       00:04D5: 55 52 43 45 
       00:04D9: 2D 49 44 29 
   224 00:04DD: 20 01 0F     SOURCEID:       jsr     DO_USER
   225 00:04E0: 0C 00                        dw      SOURCEID_OFFSET
   226                        
   227                        ; STATE ( -- a-addr )
   228                        ;
   229                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   230                        ; is true when in compilation state, false otherwise. The true value in STATE
   231                        ; is non-zero, but is otherwise implementation-defined.
   232                        
   233 00:04E2: CE 04 00                     HEADER  NORMAL
   234 00:04E5: 05 53 54 41                  db      5,"STATE"
       00:04E9: 54 45 
   235 00:04EB: 20 01 0F     STATE:          jsr     DO_USER
   236 00:04EE: 0E 00                        dw      STATE_OFFSET
   237                        
   238                        ; TIB ( -- c-addr )
   239                        ;
   240                        ; c-addr is the address of the terminal input buffer.
   241                        
   242 00:04F0: E2 04 00                     HEADER  NORMAL
   243 00:04F3: 03 54 49 42                  db      3,"TIB"
   244 00:04F7: 20 2D 0E     TIB:            jsr     DO_CONSTANT
   245 00:04FA: 00 02                        dw      TIB_AREA
   246                        
   247                        ;==============================================================================
   248                        ; Constants
   249                        ;------------------------------------------------------------------------------
   250                        
   251                        ; 0 ( -- 0 )
   252                        ;
   253                        ; Push the constant value zero on the stack
   254                        
   255 00:04FC: F0 04 00                     HEADER  NORMAL
   256 00:04FF: 01 30                        db      1,"0"
   257                        ZERO:
   258 00:0501: 7B                           tdc
   259 00:0502: 3A                           dec     a                       ; Make space on the stack
   260 00:0503: 3A                           dec     a
   261 00:0504: 5B                           tcd
   262 00:0505: 64 01                        stz     <1                      ; And create a zero value
   263 00:0507: 4C E6 0D                     jmp     NEXT                    ; Done
   264                        
   265                        ; BL ( -- char )
   266                        ;
   267                        ; char is the character value for a space.
   268                        
  Wed Mar  9 2016 20:10                                                                                                    Page 8


   269 00:050A: FC 04 00                     HEADER  NORMAL
   270 00:050D: 02 42 4C                     db      2,"BL"
   271                        BL:
   272 00:0510: 7B                           tdc
   273 00:0511: 3A                           dec     a                       ; Make space on the stack
   274 00:0512: 3A                           dec     a
   275 00:0513: 5B                           tcd
   276 00:0514: A9 20 00                     lda     #' '                    ; And save a space value
   277 00:0517: 85 01                        sta     <1
   278 00:0519: 4C E6 0D                     jmp     NEXT                    ; Done
   279                        
   280                        ; FALSE ( -- false )
   281                        ;
   282                        ; Return a false flag.
   283                        
   284 00:051C: 0A 05 00                     HEADER  NORMAL
   285 00:051F: 05 46 41 4C                  db      5,"FALSE"
       00:0523: 53 45 
   286                        FALSE:
   287 00:0525: 7B                           tdc
   288 00:0526: 3A                           dec     a                       ; Make space on the stack
   289 00:0527: 3A                           dec     a
   290 00:0528: 5B                           tcd
   291 00:0529: 64 01                        stz     <1                      ; And create a false value
   292 00:052B: 4C E6 0D                     jmp     NEXT                    ; Done
   293                        
   294                        ; TRUE ( -- true )
   295                        ;
   296                        ; Return a true flag, a single-cell value with all bits set.
   297                        
   298 00:052E: 1C 05 00                     HEADER  NORMAL
   299 00:0531: 04 54 52 55                  db      4,"TRUE"
       00:0535: 45 
   300                        TRUE:
   301 00:0536: 7B                           tdc
   302 00:0537: 3A                           dec     a                       ; Make space on the stack
   303 00:0538: 3A                           dec     a
   304 00:0539: 5B                           tcd
   305 00:053A: 64 01                        stz     <1                      ; And create a true value
   306 00:053C: C6 01                        dec     <1
   307 00:053E: 4C E6 0D                     jmp     NEXT                    ; Done
   308                        
   309                        ;==============================================================================
   310                        ; Radix
   311                        ;------------------------------------------------------------------------------
   312                        
   313                        ; DECIMAL ( -- )
   314                        ;
   315                        ; Set the numeric conversion radix to ten (decimal).
   316                        
   317 00:0541: 2E 05 00                     HEADER  NORMAL
   318 00:0544: 07 44 45 43                  db      7,"DECIMAL"
       00:0548: 49 4D 41 4C 
   319 00:054C: 20 E2 0D     DECIMAL:        jsr     DO_COLON
   320 00:054F: AE 0E 0A 00                  dw      DO_LITERAL,10,BASE,STORE
       00:0553: 75 04 72 05 
   321 00:0557: E2 0A                        dw      EXIT
   322                        
  Wed Mar  9 2016 20:10                                                                                                    Page 9


   323                        ; HEX ( -- )
   324                        ;
   325                        ; Set contents of BASE to sixteen.
   326                        
   327 00:0559: 41 05 00                     HEADER  NORMAL
   328 00:055C: 03 48 45 58                  db      3,"HEX"
   329 00:0560: 20 E2 0D     HEX:            jsr     DO_COLON
   330 00:0563: AE 0E 10 00                  dw      DO_LITERAL,16,BASE,STORE
       00:0567: 75 04 72 05 
   331 00:056B: E2 0A                        dw      EXIT
   332                        
   333                        ;==============================================================================
   334                        ; Memory Operations
   335                        ;------------------------------------------------------------------------------
   336                        
   337                        ; ! ( x a-addr -- )
   338                        ;
   339                        ; Store x at a-addr.
   340                        
   341 00:056D: 59 05 00                     HEADER  NORMAL
   342 00:0570: 01 21                        db      1,"!"
   343                        STORE:
   344 00:0572: A5 03                        lda     <3                      ; Fetch data value
   345 00:0574: 92 01                        sta     (1)                     ; .. and store
   346 00:0576: 7B                           tdc                             ; Clean up data stack
   347 00:0577: 1A                           inc     a
   348 00:0578: 1A                           inc     a
   349 00:0579: 1A                           inc     a
   350 00:057A: 1A                           inc     a
   351 00:057B: 5B                           tcd
   352 00:057C: 4C E6 0D                     jmp     NEXT                    ; Done
   353                        
   354                        ; +! ( n|u a-addr -- )
   355                        ;
   356                        ; Add n|u to the single-cell number at a-addr.
   357                        
   358 00:057F: 6D 05 00                     HEADER  NORMAL
   359 00:0582: 02 2B 21                     db      2,"+!"
   360                        PLUS_STORE:
   361 00:0585: 18                           clc
   362 00:0586: A5 03                        lda     <3                      ; Fetch data value
   363 00:0588: 72 01                        adc     (1)
   364 00:058A: 92 01                        sta     (1)
   365 00:058C: 7B                           tdc                             ; Clean up data stack
   366 00:058D: 1A                           inc     a
   367 00:058E: 1A                           inc     a
   368 00:058F: 1A                           inc     a
   369 00:0590: 1A                           inc     a
   370 00:0591: 5B                           tcd
   371 00:0592: 4C E6 0D                     jmp     NEXT                    ; Done
   372                        
   373                        ; , ( x -- )
   374                        ;
   375                        ; Reserve one cell of data space and store x in the cell. If the data-space
   376                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   377                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   378                        ; is not aligned prior to execution of ,.
   379                        ;
  Wed Mar  9 2016 20:10                                                                                                    Page 10


   380                        ;   HERE ! 1 CELLS ALLOT
   381                        
   382 00:0595: 7F 05 00                     HEADER  NORMAL
   383 00:0598: 01 2C                        db      1,","
   384 00:059A: 20 E2 0D     COMMA:          jsr     DO_COLON
   385 00:059D: 3C 06 72 05                  dw      HERE,STORE
   386 00:05A1: AE 0E 01 00                  dw      DO_LITERAL,1,CELLS,ALLOT
       00:05A5: 78 06 EA 05 
   387 00:05A9: E2 0A                        dw      EXIT
   388                        
   389                        ; 2! ( x1 x2 a-addr -- )
   390                        ;
   391                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   392                        ; consecutive cell. It is equivalent to the sequence SWAP OVER ! CELL+ !.
   393                        
   394 00:05AB: 95 05 00                     HEADER  NORMAL
   395 00:05AE: 02 32 21                     db      2,"2!"
   396 00:05B1: 20 E2 0D     TWO_STORE:      jsr     DO_COLON
   397 00:05B4: 62 07                        dw      SWAP
   398 00:05B6: 4F 07                        dw      OVER
   399 00:05B8: 72 05                        dw      STORE
   400 00:05BA: 68 06                        dw      CELL_PLUS
   401 00:05BC: 72 05                        dw      STORE
   402 00:05BE: E2 0A                        dw      EXIT
   403                        
   404                        ; 2@ ( a-addr -- x1 x2 )
   405                        ;
   406                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   407                        ; the next consecutive cell. It is equivalent to the sequence DUP CELL+ @ SWAP
   408                        ; @.
   409                        
   410 00:05C0: AB 05 00                     HEADER  NORMAL
   411 00:05C3: 02 32 40                     db      2,"2@"
   412 00:05C6: 20 E2 0D     TWO_FETCH:      jsr     DO_COLON
   413 00:05C9: 2F 07                        dw      DUP
   414 00:05CB: 68 06                        dw      CELL_PLUS
   415 00:05CD: DA 05                        dw      FETCH
   416 00:05CF: 62 07                        dw      SWAP
   417 00:05D1: DA 05                        dw      FETCH
   418 00:05D3: E2 0A                        dw      EXIT
   419                        
   420                        ; @ ( a-addr -- x )
   421                        ;
   422                        ; x is the value stored at a-addr.
   423                        
   424 00:05D5: C0 05 00                     HEADER  NORMAL
   425 00:05D8: 01 40                        db      1,"@"
   426                        FETCH:
   427 00:05DA: B2 01                        lda     (1)                     ; Fetch from memory
   428 00:05DC: 85 01                        sta     <1                      ; .. and replace top value
   429 00:05DE: 4C E6 0D                     jmp     NEXT                    ; Done
   430                        
   431                        ; ALLOT ( n -- )
   432                        ;
   433                        ; If n is greater than zero, reserve n address units of data space. If n is
   434                        ; less than zero, release |n| address units of data space. If n is zero, leave
   435                        ; the data-space pointer unchanged.
   436                        ;
  Wed Mar  9 2016 20:10                                                                                                    Page 11


   437                        ; In this implementation its is defined as:
   438                        ;
   439                        ;   DP +!
   440                        
   441 00:05E1: D5 05 00                     HEADER  NORMAL
   442 00:05E4: 05 41 4C 4C                  db      5,"ALLOT"
       00:05E8: 4F 54 
   443 00:05EA: 20 E2 0D     ALLOT:          jsr     DO_COLON
   444 00:05ED: 9D 04 85 05                  dw      DP,PLUS_STORE
   445 00:05F1: E2 0A                        dw      EXIT
   446                        
   447                        ; C! ( char c-addr -- )
   448                        ;
   449                        ; Store char at c-addr. When character size is smaller than cell size, only the
   450                        ; number of low-order bits corresponding to character size are transferred.
   451                        
   452 00:05F3: E1 05 00                     HEADER  NORMAL
   453 00:05F6: 02 43 21                     db      2,"C!"
   454                        C_STORE:
   455 00:05F9: A5 03                        lda     <3                      ; Fetch the data value
   456 00:05FB: E2 20                        short_a
   457 00:05FD: 92 01                        sta     (1)                     ; And store it
   458 00:05FF: C2 20                        long_a
   459 00:0601: 7B                           tdc                             ; Clean up the stack
   460 00:0602: 1A                           inc     a
   461 00:0603: 1A                           inc     a
   462 00:0604: 1A                           inc     a
   463 00:0605: 1A                           inc     a
   464 00:0606: 5B                           tcd
   465 00:0607: 4C E6 0D                     jmp     NEXT                    ; Done
   466                        
   467                        ; C, ( char -- )
   468                        ;
   469                        ; Reserve space for one character in the data space and store char in the
   470                        ; space. If the data-space pointer is character aligned when C, begins
   471                        ; execution, it will remain character aligned when C, finishes execution.
   472                        ; An ambiguous condition exists if the data-space pointer is not character-
   473                        ; aligned prior to execution of C,
   474                        ;
   475                        ;   HERE C! 1 CHARS ALLOT
   476                        
   477 00:060A: F3 05 00                     HEADER  NORMAL
   478 00:060D: 02 43 2C                     db      2,"C,"
   479 00:0610: 20 E2 0D     C_COMMA:        jsr     DO_COLON
   480 00:0613: 3C 06 F9 05                  dw      HERE,C_STORE
   481 00:0617: AE 0E 01 00                  dw      DO_LITERAL,1,CHARS,ALLOT
       00:061B: A2 06 EA 05 
   482 00:061F: E2 0A                        dw      EXIT
   483                        
   484                        ; C@ ( c-addr -- char )
   485                        ;
   486                        ; Fetch the character stored at c-addr. When the cell size is greater than
   487                        ; character size, the unused high-order bits are all zeroes.
   488                        
   489 00:0621: 0A 06 00                     HEADER  NORMAL
   490 00:0624: 02 43 40                     db      2,"C@"
   491                        C_FETCH:
   492 00:0627: E2 20                        short_a
  Wed Mar  9 2016 20:10                                                                                                    Page 12


   493 00:0629: B2 01                        lda     (1)                     ; Fetch the data byte
   494 00:062B: 85 01                        sta     <1                      ; .. and replace stack value
   495 00:062D: 64 02                        stz     <2
   496 00:062F: C2 20                        long_a
   497 00:0631: 4C E6 0D                     jmp     NEXT                    ; Done
   498                        
   499                        ; HERE
   500                        
   501 00:0634: 21 06 00                     HEADER  NORMAL
   502 00:0637: 04 48 45 52                  db      4,"HERE"
       00:063B: 45 
   503 00:063C: 20 E2 0D     HERE:           jsr     DO_COLON
   504 00:063F: 9D 04 DA 05                  dw      DP,FETCH
   505 00:0643: E2 0A                        dw      EXIT
   506                        
   507                        ;==============================================================================
   508                        ; Alignment
   509                        ;------------------------------------------------------------------------------
   510                        
   511                        ; ALIGN ( -- )
   512                        ;
   513                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   514                        
   515 00:0645: 34 06 00                     HEADER  NORMAL
   516 00:0648: 05 41 4C 49                  db      5,"ALIGN"
       00:064C: 47 4E 
   517                        ALIGN:
   518 00:064E: 4C E6 0D                     jmp     NEXT                    ; Done
   519                        
   520                        ; ALIGNED ( addr -- a-addr )
   521                        ;
   522                        ; a-addr is the first aligned address greater than or equal to addr.
   523                        
   524 00:0651: 45 06 00                     HEADER  NORMAL
   525 00:0654: 07 41 4C 49                  db      7,"ALIGNED"
       00:0658: 47 4E 45 44 
   526                        ALIGNED:
   527 00:065C: 4C E6 0D                     jmp     NEXT                    ; Done
   528                        
   529                        ; CELL+ ( a-addr1 -- a-addr2 )
   530                        ;
   531                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   532                        
   533 00:065F: 51 06 00                     HEADER  NORMAL
   534 00:0662: 05 43 45 4C                  db      5,"CELL+"
       00:0666: 4C 2B 
   535                        CELL_PLUS:
   536 00:0668: E6 01                        inc     <1                      ; Bump the address by two
   537 00:066A: E6 01                        inc     <1
   538 00:066C: 4C E6 0D                     jmp     NEXT
   539                        
   540                        ; CELLS ( n1 -- n2 )
   541                        ;
   542                        ; n2 is the size in address units of n1 cells.
   543                        
   544 00:066F: 5F 06 00                     HEADER  NORMAL
   545 00:0672: 05 43 45 4C                  db      5,"CELLS"
       00:0676: 4C 53 
  Wed Mar  9 2016 20:10                                                                                                    Page 13


   546                        CELLS:
   547 00:0678: 06 01                        asl     <1                      ; Two bytes per cell
   548 00:067A: 4C E6 0D                     jmp     NEXT
   549                        
   550                        ; CHAR+ ( c-addr1 -- c-addr2 )
   551                        ;
   552                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
   553                        
   554 00:067D: 6F 06 00                     HEADER  NORMAL
   555 00:0680: 05 43 48 41                  db      5,"CHAR+"
       00:0684: 52 2B 
   556                        CHAR_PLUS:
   557 00:0686: E6 01                        inc     <1                      ; Bump the address by one
   558 00:0688: 4C E6 0D                     jmp     NEXT
   559                        		
   560                        ; CHAR- ( c-addr1 -- c-addr2 )
   561                        ;
   562                        ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
   563                        
   564 00:068B: 7D 06 00     		HEADER	NORMAL
   565 00:068E: 05 43 48 41  		db	5,"CHAR-"
       00:0692: 52 2D 
   566                        CHAR_MINUS:
   567 00:0694: C6 01        		dec	<1
   568 00:0696: 4C E6 0D     		jmp	NEXT
   569                        
   570                        ; CHARS ( n1 -- n2 )
   571                        ;
   572                        ; n2 is the size in address units of n1 characters.
   573                        
   574 00:0699: 8B 06 00                     HEADER  NORMAL
   575 00:069C: 05 43 48 41                  db      5,"CHARS"
       00:06A0: 52 53 
   576                        CHARS:
   577 00:06A2: 4C E6 0D                     jmp     NEXT
   578                        
   579                        ;==============================================================================
   580                        ; Stack Operations
   581                        ;------------------------------------------------------------------------------
   582                        
   583                        ; 2DROP ( x1 x2 -- )
   584                        ;
   585                        ; Drop cell pair x1 x2 from the stack.
   586                        
   587 00:06A5: 99 06 00                     HEADER  NORMAL
   588 00:06A8: 05 32 44 52                  db      5,"2DROP"
       00:06AC: 4F 50 
   589                        TWO_DROP:
   590 00:06AE: 7B                           tdc                             ; Removed two words from stack
   591 00:06AF: 1A                           inc     a
   592 00:06B0: 1A                           inc     a
   593 00:06B1: 1A                           inc     a
   594 00:06B2: 1A                           inc     a
   595 00:06B3: 5B                           tcd
   596 00:06B4: 4C E6 0D                     jmp     NEXT                    ; Done
   597                        
   598                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   599                        ;
  Wed Mar  9 2016 20:10                                                                                                    Page 14


   600                        ; Duplicate cell pair x1 x2.
   601                        
   602 00:06B7: A5 06 00                     HEADER  NORMAL
   603 00:06BA: 04 32 44 55                  db      4,"2DUP"
       00:06BE: 50 
   604                        TWO_DUP:
   605 00:06BF: 7B                           tdc                             ; Make space for new value
   606 00:06C0: 3A                           dec     a
   607 00:06C1: 3A                           dec     a
   608 00:06C2: 3A                           dec     a
   609 00:06C3: 3A                           dec     a
   610 00:06C4: 5B                           tcd
   611 00:06C5: A5 05                        lda     <5                      ; Copy top two values
   612 00:06C7: 85 01                        sta     <1
   613 00:06C9: A5 07                        lda     <7
   614 00:06CB: 85 03                        sta     <3
   615 00:06CD: 4C E6 0D                     jmp     NEXT                    ; Done
   616                        
   617                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   618                        ;
   619                        ; Copy cell pair x1 x2 to the top of the stack.
   620                        
   621 00:06D0: B7 06 00                     HEADER  NORMAL
   622 00:06D3: 05 32 4F 56                  db      5,"2OVER"
       00:06D7: 45 52 
   623                        TWO_OVER:
   624 00:06D9: 7B                           tdc                             ; Make space for new value
   625 00:06DA: 3A                           dec     a
   626 00:06DB: 3A                           dec     a
   627 00:06DC: 3A                           dec     a
   628 00:06DD: 3A                           dec     a
   629 00:06DE: 5B                           tcd
   630 00:06DF: A5 09                        lda     <9                      ; Ciopy top two values
   631 00:06E1: 85 01                        sta     <1
   632 00:06E3: A5 0B                        lda     <11
   633 00:06E5: 85 03                        sta     <3
   634 00:06E7: 4C E6 0D                     jmp     NEXT                    ; Done
   635                        
   636                        ; 2ROT
   637                        
   638                        ; TODO
   639                        
   640                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   641                        ;
   642                        ; Exchange the top two cell pairs.
   643                        
   644 00:06EA: D0 06 00                     HEADER  NORMAL
   645 00:06ED: 05 32 53 57                  db      5,"2SWAP"
       00:06F1: 41 50 
   646                        TWO_SWAP:
   647 00:06F3: A5 03                        lda     <3                      ; Save x3
   648 00:06F5: 48                           pha
   649 00:06F6: A5 01                        lda     <1                      ; Save x4
   650 00:06F8: 48                           pha
   651 00:06F9: A5 07                        lda     <7                      ; Move x1
   652 00:06FB: 85 03                        sta     <3
   653 00:06FD: A5 05                        lda     <5                      ; Move x2
   654 00:06FF: 85 01                        sta     <1
  Wed Mar  9 2016 20:10                                                                                                    Page 15


   655 00:0701: 68                           pla                             ; Move x4
   656 00:0702: 85 05                        sta     <5
   657 00:0704: 68                           pla                             ; Move x3
   658 00:0705: 85 07                        sta     <7
   659 00:0707: 4C E6 0D                     jmp     NEXT                    ; Done
   660                        
   661                        ; ?DUP ( x -- 0 | x x )
   662                        ;
   663                        ; Duplicate x if it is non-zero.
   664                        
   665 00:070A: EA 06 00                     HEADER  NORMAL
   666 00:070D: 04 3F 44 55                  db      4,"?DUP"
       00:0711: 50 
   667                        QUERY_DUP:
   668 00:0712: A5 01                        lda     <1                      ; Fetch top value
   669 00:0714: D0 19                        bne     DUP                     ; Non-zero value?
   670 00:0716: 4C E6 0D                     jmp     NEXT                    ; Done
   671                        
   672                        ; DROP ( x -- )
   673                        ;
   674                        ; Remove x from the stack.
   675                        
   676 00:0719: 0A 07 00                     HEADER  NORMAL
   677 00:071C: 04 44 52 4F                  db      4,"DROP"
       00:0720: 50 
   678                        DROP:
   679 00:0721: 7B                           tdc                             ; Drop the top value
   680 00:0722: 1A                           inc     a
   681 00:0723: 1A                           inc     a
   682 00:0724: 5B                           tcd
   683 00:0725: 4C E6 0D                     jmp     NEXT                    ; Done
   684                        
   685                        ; DUP ( x -- x x )
   686                        ;
   687                        ; Duplicate x.
   688                        
   689 00:0728: 19 07 00                     HEADER  NORMAL
   690 00:072B: 03 44 55 50                  db      3,"DUP"
   691                        DUP:
   692 00:072F: 7B                           tdc
   693 00:0730: 3A                           dec     a
   694 00:0731: 3A                           dec     a
   695 00:0732: 5B                           tcd
   696 00:0733: A5 03                        lda     <3                      ; Fetch top value
   697 00:0735: 85 01                        sta     <1                      ; And make a copy
   698 00:0737: 4C E6 0D                     jmp     NEXT                    ; Done
   699                        
   700                        ; NIP ( x1 x2 -- x2 )
   701                        ;
   702                        ; Drop the first item below the top of stack.
   703                        
   704 00:073A: 28 07 00                     HEADER  NORMAL
   705 00:073D: 03 4E 49 50                  db      3,"NIP"
   706                        NIP:
   707 00:0741: A5 01                        lda     <1                      ; Copy x2 over x1
   708 00:0743: 85 03                        sta     <3
   709 00:0745: 80 DA                        bra     DROP
   710                        
  Wed Mar  9 2016 20:10                                                                                                    Page 16


   711                        ; OVER ( x1 x2 -- x1 x2 x1 )
   712                        ;
   713                        ; Place a copy of x1 on top of the stack.
   714                        
   715 00:0747: 3A 07 00                     HEADER  NORMAL
   716 00:074A: 04 4F 56 45                  db      4,"OVER"
       00:074E: 52 
   717                        OVER:
   718 00:074F: 7B                           tdc
   719 00:0750: 3A                           dec     a
   720 00:0751: 3A                           dec     a
   721 00:0752: 5B                           tcd
   722 00:0753: A5 05                        lda     <5                      ; Fetch second value
   723 00:0755: 85 01                        sta     <1                      ; And make a copy
   724 00:0757: 4C E6 0D                     jmp     NEXT                    ; Done
   725                        
   726                        ; SWAP ( x1 x2 -- x2 x1 )
   727                        ;
   728                        ; Exchange the top two stack items.
   729                        
   730 00:075A: 47 07 00                     HEADER  NORMAL
   731 00:075D: 04 53 57 41                  db      4,"SWAP"
       00:0761: 50 
   732                        SWAP:
   733 00:0762: A5 01                        lda     <1                      ; Switch top two words
   734 00:0764: A6 03                        ldx     <3
   735 00:0766: 85 03                        sta     <3
   736 00:0768: 86 01                        stx     <1
   737 00:076A: 4C E6 0D                     jmp     NEXT                    ; Done
   738                        
   739                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   740                        ;
   741                        ; Rotate the top three stack entries.
   742                        
   743 00:076D: 5A 07 00                     HEADER  NORMAL
   744 00:0770: 03 52 4F 54                  db      3,"ROT"
   745                        ROT:
   746 00:0774: A6 05                        ldx     <5                      ; Save x1
   747 00:0776: A5 03                        lda     <3                      ; Move x2
   748 00:0778: 85 05                        sta     <5
   749 00:077A: A5 01                        lda     <1                      ; Move x3
   750 00:077C: 85 03                        sta     <3
   751 00:077E: 86 01                        stx     <1                      ; Restore x1
   752 00:0780: 4C E6 0D                     jmp     NEXT
   753                        
   754                        ; ROLL [TODO]
   755                        
   756                        ; TUCK ( x1 x2 -- x2 x1 x2 )
   757                        ;
   758                        ; Copy the first (top) stack item below the second stack item.
   759                        
   760 00:0783: 6D 07 00                     HEADER  NORMAL
   761 00:0786: 04 54 55 43                  db      4,"TUCK"
       00:078A: 4B 
   762 00:078B: 20 E2 0D     TUCK:           jsr     DO_COLON
   763 00:078E: 62 07                        dw      SWAP
   764 00:0790: 4F 07                        dw      OVER
   765 00:0792: E2 0A                        dw      EXIT
  Wed Mar  9 2016 20:10                                                                                                    Page 17


   766                        
   767                        ;==============================================================================
   768                        ; Return Stack Operations
   769                        ;------------------------------------------------------------------------------
   770                        
   771                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   772                        ;
   773                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   774                        ; SWAP >R >R.
   775                        
   776 00:0794: 83 07 00                     HEADER  NORMAL
   777 00:0797: 03 32 3E 52                  db      3,"2>R"
   778                        TWO_TO_R:
   779 00:079B: A5 03                        lda     <3                      ; Transfer x1
   780 00:079D: 48                           pha
   781 00:079E: A5 01                        lda     <1                      ; Transfer x2
   782 00:07A0: 48                           pha
   783 00:07A1: 7B                           tdc
   784 00:07A2: 1A                           inc     a                       ; Clean up data stack
   785 00:07A3: 1A                           inc     a
   786 00:07A4: 1A                           inc     a
   787 00:07A5: 1A                           inc     a
   788 00:07A6: 5B                           tcd
   789 00:07A7: 4C E6 0D                     jmp     NEXT                    ; Done
   790                        
   791                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   792                        ;
   793                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   794                        ; R> SWAP.
   795                        
   796 00:07AA: 94 07 00                     HEADER  NORMAL
   797 00:07AD: 03 32 52 3E                  db      3,"2R>"
   798                        TWO_R_FROM:
   799 00:07B1: 7B                           tdc
   800 00:07B2: 3A                           dec     a                       ; Make space for values
   801 00:07B3: 3A                           dec     a
   802 00:07B4: 3A                           dec     a
   803 00:07B5: 3A                           dec     a
   804 00:07B6: 5B                           tcd
   805 00:07B7: 68                           pla                             ; Transfer x2
   806 00:07B8: 85 01                        sta     <1
   807 00:07BA: 68                           pla                             ; Transfer x1
   808 00:07BB: 85 03                        sta     <3
   809 00:07BD: 4C E6 0D                     jmp     NEXT                    ; Done
   810                        
   811                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
   812                        ;
   813                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   814                        ; 2DUP >R >R SWAP.
   815                        
   816 00:07C0: AA 07 00                     HEADER  NORMAL
   817 00:07C3: 03 32 52 40                  db      3,"2R@"
   818                        TWO_R_FETCH:
   819 00:07C7: 7B                           tdc
   820 00:07C8: 3A                           dec     a                       ; Make space for values
   821 00:07C9: 3A                           dec     a
   822 00:07CA: 3A                           dec     a
   823 00:07CB: 3A                           dec     a
  Wed Mar  9 2016 20:10                                                                                                    Page 18


   824 00:07CC: 5B                           tcd
   825 00:07CD: A3 01                        lda     1,s                     ; Transfer x2
   826 00:07CF: 85 01                        sta     <1
   827 00:07D1: A3 03                        lda     3,s                     ; Transfer x1
   828 00:07D3: 85 03                        sta     <3
   829 00:07D5: 4C E6 0D                     jmp     NEXT                    ; Done
   830                        
   831                        ; >R ( x -- ) ( R: -- x )
   832                        ;
   833                        ; Move x to the return stack.
   834                        
   835 00:07D8: C0 07 00                     HEADER  NORMAL
   836 00:07DB: 02 3E 52                     db      2,">R"
   837                        TO_R:
   838 00:07DE: A5 01                        lda     <1                      ; Transfer top value
   839 00:07E0: 48                           pha                             ; .. to return stack
   840 00:07E1: 7B                           tdc
   841 00:07E2: 1A                           inc     a
   842 00:07E3: 1A                           inc     a
   843 00:07E4: 5B                           tcd
   844 00:07E5: 4C E6 0D                     jmp     NEXT                    ; Done
   845                        
   846                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   847                        ;
   848                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   849                        ; exists if the loop control parameters are unavailable.
   850                        
   851 00:07E8: D8 07 00                     HEADER  NORMAL
   852 00:07EB: 01 49                        db      1,"I"
   853                        I:
   854 00:07ED: 7B                           tdc
   855 00:07EE: 3A                           dec     a
   856 00:07EF: 3A                           dec     a
   857 00:07F0: 5B                           tcd
   858 00:07F1: A3 01                        lda     1,s
   859 00:07F3: 85 01                        sta     <1
   860 00:07F5: 4C E6 0D                     jmp     NEXT
   861                        
   862                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   863                        ;
   864                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   865                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   866                        ; unavailable.
   867                        
   868 00:07F8: E8 07 00                     HEADER  NORMAL
   869 00:07FB: 01 4A                        db      1,"J"
   870                        J:
   871 00:07FD: 7B                           tdc
   872 00:07FE: 3A                           dec     a
   873 00:07FF: 3A                           dec     a
   874 00:0800: 5B                           tcd
   875 00:0801: A3 05                        lda     5,s
   876 00:0803: 85 01                        sta     <1
   877 00:0805: 4C E6 0D                     jmp     NEXT
   878                        
   879                        ; R> ( -- x ) ( R: x -- )
   880                        ;
   881                        ; Move x from the return stack to the data stack.
  Wed Mar  9 2016 20:10                                                                                                    Page 19


   882                        
   883 00:0808: F8 07 00                     HEADER  NORMAL
   884 00:080B: 02 52 3E                     db      2,"R>"
   885                        R_FROM:
   886 00:080E: 7B                           tdc
   887 00:080F: 3A                           dec     a
   888 00:0810: 3A                           dec     a
   889 00:0811: 5B                           tcd
   890 00:0812: 68                           pla                             ; Fetch return stack value
   891 00:0813: 85 01                        sta     <1
   892 00:0815: 4C E6 0D                     jmp     NEXT                    ; Done
   893                        
   894                        ; R@ ( -- x ) ( R: x -- x )
   895                        ;
   896                        ; Copy x from the return stack to the data stack.
   897                        
   898 00:0818: 08 08 00                     HEADER  NORMAL
   899 00:081B: 02 52 40                     db      2,"R@"
   900                        R_FETCH:
   901 00:081E: 7B                           tdc
   902 00:081F: 3A                           dec     a
   903 00:0820: 3A                           dec     a
   904 00:0821: 5B                           tcd
   905 00:0822: A3 01                        lda     1,s
   906 00:0824: 85 01                        sta     <1
   907 00:0826: 4C E6 0D                     jmp     NEXT
   908                        
   909                        ;==============================================================================
   910                        ; Single Precision Arithmetic
   911                        ;------------------------------------------------------------------------------
   912                        
   913                        ; * ( n1|u1 n2|u2 -- n3|u3 )
   914                        ;
   915                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
   916                        
   917 00:0829: 18 08 00                     HEADER  NORMAL
   918 00:082C: 01 2A                        db      1,"*"
   919                        STAR:
   920 00:082E: 4C E6 0D                     jmp     NEXT                    ; Done
   921                        
   922                        ; */
   923                        ; */MOD
   924                        
   925                        
   926                        ; + ( n1|u1 n2|u2 -- n3|u3 )
   927                        ;
   928                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
   929                        
   930 00:0831: 29 08 00                     HEADER  NORMAL
   931 00:0834: 01 2B                        db      1,"+"
   932                        PLUS:
   933 00:0836: 18                           clc                             ; Add top two values
   934 00:0837: A5 03                        lda     <3
   935 00:0839: 65 01                        adc     <1
   936 00:083B: 85 03                        sta     <3                      ; Save result
   937 00:083D: 7B                           tdc
   938 00:083E: 1A                           inc     a                       ; Clean up data stack
   939 00:083F: 1A                           inc     a
  Wed Mar  9 2016 20:10                                                                                                    Page 20


   940 00:0840: 5B                           tcd
   941 00:0841: 4C E6 0D                     jmp     NEXT                    ; Done
   942                        
   943                        ; - ( n1|u1 n2|u2 -- n3|u3 )
   944                        ;
   945                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
   946                        
   947 00:0844: 31 08 00                     HEADER  NORMAL
   948 00:0847: 01 2D                        db      1,"-"
   949                        MINUS:
   950 00:0849: 38                           sec                             ; Subtract top two values
   951 00:084A: A5 03                        lda     <3
   952 00:084C: E5 01                        sbc     <1
   953 00:084E: 85 03                        sta     <3                      ; Save result
   954 00:0850: 7B                           tdc
   955 00:0851: 1A                           inc     a                       ; Clean up data stack
   956 00:0852: 1A                           inc     a
   957 00:0853: 5B                           tcd
   958 00:0854: 4C E6 0D                     jmp     NEXT                    ; Done
   959                        
   960                        ; /
   961                        ; /MOD
   962                        
   963                        ; 1+ ( n1|u1 -- n2|u2 )
   964                        ;
   965                        ; Add one (1) to n1|u1 giving the sum n2|u2.
   966                        
   967 00:0857: 44 08 00                     HEADER  NORMAL
   968 00:085A: 02 31 2B                     db      2,"1+"
   969                        ONE_PLUS:
   970 00:085D: E6 01                        inc     <1                      ; Increment top of stack
   971 00:085F: 4C E6 0D                     jmp     NEXT                    ; Done
   972                        
   973                        ; 1- ( n1|u1 -- n2|u2 )
   974                        ;
   975                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
   976                        
   977 00:0862: 57 08 00                     HEADER  NORMAL
   978 00:0865: 02 31 2D                     db      2,"1-"
   979                        ONE_MINUS:
   980 00:0868: C6 01                        dec     <1                      ; Decrement top of stack
   981 00:086A: 4C E6 0D                     jmp     NEXT                    ; Done
   982                        
   983                        ; 2* ( x1 -- x2 )
   984                        ;
   985                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
   986                        ; filling the vacated least-significant bit with zero.
   987                        
   988 00:086D: 62 08 00                     HEADER  NORMAL
   989 00:0870: 02 32 2A                     db      2,"2*"
   990                        TWO_STAR:
   991 00:0873: 06 01                        asl     <1                      ; Multiply top value by two
   992 00:0875: 4C E6 0D                     jmp     NEXT                    ; Done
   993                        
   994                        ; 2/ ( x1 -- x2 )
   995                        ;
   996                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
   997                        ; leaving the most-significant bit unchanged.
  Wed Mar  9 2016 20:10                                                                                                    Page 21


   998                        
   999 00:0878: 6D 08 00                     HEADER  NORMAL
  1000 00:087B: 02 32 2F                     db      2,"2/"
  1001                        TWO_SLASH:
  1002 00:087E: A5 01                        lda     <1                      ; Load the top value
  1003 00:0880: 2A                           rol     a                       ; Extract the top bit
  1004 00:0881: 66 01                        ror     <1                      ; And shift back into value
  1005 00:0883: 4C E6 0D                     jmp     NEXT
  1006                        
  1007                        ; ABS ( n -- u )
  1008                        ;
  1009                        ; u is the absolute value of n.
  1010                        
  1011 00:0886: 78 08 00                     HEADER  NORMAL
  1012 00:0889: 03 41 42 53                  db      3,"ABS"
  1013                        ABS:
  1014 00:088D: A5 01                        lda     <1
  1015 00:088F: 30 0D                        bmi     NEGATE
  1016 00:0891: 4C E6 0D                     jmp     NEXT                    ; Done
  1017                        
  1018                        ; MAX
  1019                        ; MIN
  1020                        ; MOD
  1021                        
  1022                        ; NEGATE ( n1 -- n2 )
  1023                        ;
  1024                        ; Negate n1, giving its arithmetic inverse n2.
  1025                        
  1026 00:0894: 86 08 00                     HEADER  NORMAL
  1027 00:0897: 06 4E 45 47                  db      6,"NEGATE"
       00:089B: 41 54 45 
  1028                        NEGATE:
  1029 00:089E: 38                           sec                             ; Negate the top of stack
  1030 00:089F: A9 00 00                     lda     #0
  1031 00:08A2: E5 01                        sbc     <1
  1032 00:08A4: 85 01                        sta     <1
  1033 00:08A6: 4C E6 0D                     jmp     NEXT                    ; Done
  1034                        
  1035                        ; UMAX ( x1 x2 -- x1|x2 )
  1036                        
  1037 00:08A9: 94 08 00                     HEADER  NORMAL
  1038 00:08AC: 04 55 4D 41                  db      4,"UMAX"
       00:08B0: 58 
  1039                        UMAX:
  1040 00:08B1: A5 01                        lda     <1                      ; Compare the top values
  1041 00:08B3: C5 03                        cmp     <3
  1042 00:08B5: B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
  1043 00:08B7: 4C 21 07                     jmp     DROP                    ; No, x1 is
  1044 00:08BA: 4C 41 07     UMAX_EXIT:      jmp     NIP
  1045                        
  1046                        ; UMIN ( x1 x2 -- x1|x2 )
  1047                        
  1048 00:08BD: A9 08 00                     HEADER  NORMAL
  1049 00:08C0: 04 55 4D 49                  db      4,"UMIN"
       00:08C4: 4E 
  1050                        UMIN:
  1051 00:08C5: A5 01                        lda     <1                      ; Compare the top values
  1052 00:08C7: C5 03                        cmp     <3
  Wed Mar  9 2016 20:10                                                                                                    Page 22


  1053 00:08C9: 90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
  1054 00:08CB: 4C 21 07                     jmp     DROP                    ; No, x1 is
  1055 00:08CE: 4C 41 07     UMIN_EXIT:      jmp     NIP
  1056                        
  1057                        ;==============================================================================
  1058                        ; Double Precision Arithmetic
  1059                        ;------------------------------------------------------------------------------
  1060                        
  1061                        ; D+ ( d1|ud1 d2|ud2 -- d3|ud3 )
  1062                        ;
  1063                        ; Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
  1064                        
  1065 00:08D1: BD 08 00     		HEADER	NORMAL
  1066 00:08D4: 02 44 2B     		db	2,"D+"
  1067                        D_PLUS:
  1068 00:08D7: 18           		clc
  1069 00:08D8: A5 07        		lda	<7			; Add low words
  1070 00:08DA: 65 03        		adc	<3
  1071 00:08DC: 85 07        		sta	<7
  1072 00:08DE: A5 05        		lda	<5			; Then the high words
  1073 00:08E0: 65 01        		adc	<1
  1074 00:08E2: 85 05        		sta	<5
  1075 00:08E4: 7B           		tdc				; Drop top double
  1076 00:08E5: 1A           		inc	a
  1077 00:08E6: 1A           		inc	a
  1078 00:08E7: 1A           		inc	a
  1079 00:08E8: 1A           		inc	a
  1080 00:08E9: 5B           		tcd
  1081 00:08EA: 4C E6 0D     		jmp	NEXT			; Done
  1082                        
  1083                        ; D- ( d1|ud1 d2|ud2 -- d3|ud3 )
  1084                        ;
  1085                        ; Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
  1086                        
  1087 00:08ED: D1 08 00     		HEADER	NORMAL
  1088 00:08F0: 02 44 2D     		db	2,"D-"
  1089                        D_MINUS:
  1090 00:08F3: 38           		sec
  1091 00:08F4: A5 07        		lda	<7			; Subtract low words
  1092 00:08F6: E5 03        		sbc	<3
  1093 00:08F8: 85 07        		sta	<7
  1094 00:08FA: A5 05        		lda	<5			; Then the high words
  1095 00:08FC: E5 01        		sbc	<1
  1096 00:08FE: 85 05        		sta	<5
  1097 00:0900: 7B           		tdc				; Drop top double
  1098 00:0901: 1A           		inc	a
  1099 00:0902: 1A           		inc	a
  1100 00:0903: 1A           		inc	a
  1101 00:0904: 1A           		inc	a
  1102 00:0905: 5B           		tcd
  1103 00:0906: 4C E6 0D     		jmp	NEXT			; Done
  1104                        		
  1105                        ; D2* ( xd1 -- xd2 )
  1106                        ;
  1107                        ; xd2 is the result of shifting xd1 one bit toward the most-significant bit,
  1108                        ; filling the vacated least-significant bit with zero.
  1109                        
  1110 00:0909: ED 08 00     		HEADER	NORMAL
  Wed Mar  9 2016 20:10                                                                                                    Page 23


  1111 00:090C: 03 44 32 2A  		db	3,"D2*"
  1112                        D_TWO_STAR:
  1113 00:0910: 06 03        		asl	<3
  1114 00:0912: 26 01        		rol	<1
  1115 00:0914: 4C E6 0D     		jmp	NEXT
  1116                        
  1117                        ; D2/ ( xd1 -- xd2 )
  1118                        ;
  1119                        ; xd2 is the result of shifting xd1 one bit toward the least-significant bit,
  1120                        ; leaving the most-significant bit unchanged.
  1121                        
  1122 00:0917: 09 09 00     		HEADER	NORMAL
  1123 00:091A: 03 44 32 2F  		db	3,"D2/"
  1124                        D_TWO_SLASH:
  1125 00:091E: A5 01        		lda	<1
  1126 00:0920: 2A           		rol	a
  1127 00:0921: 66 01        		ror	<1
  1128 00:0923: 66 03        		ror	<3
  1129 00:0925: 4C E6 0D     		jmp	NEXT
  1130                        
  1131                        ; DABS
  1132                        ; DMAX
  1133                        ; DMIN
  1134                        
  1135                        ; DNEGATE ( d1 -- d2 )
  1136                        ;
  1137                        ; d2 is the negation of d1.
  1138                        
  1139 00:0928: 17 09 00     		HEADER	NORMAL
  1140 00:092B: 07 44 4E 45  		db	7,"DNEGATE"
       00:092F: 47 41 54 45 
  1141                        DNEGATE:
  1142 00:0933: 38           		sec
  1143 00:0934: A9 00 00     		lda	#0			; Subtract low word from zero
  1144 00:0937: E5 03        		sbc	<3		
  1145 00:0939: 85 03        		sta	<3
  1146 00:093B: A9 00 00     		lda	#0			; Then the high word
  1147 00:093E: E5 01        		sbc	<1
  1148 00:0940: 85 01        		sta	<1
  1149 00:0942: 4C E6 0D     		jmp	NEXT			; Done
  1150                        
  1151                        ;==============================================================================
  1152                        ; Mixed Arithmetic
  1153                        ;------------------------------------------------------------------------------
  1154                        
  1155                        
  1156                        ; D>S ( d -- n )
  1157                        ;
  1158                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1159                        ; range of a signed single-cell number.
  1160                        
  1161 00:0945: 28 09 00                     HEADER  NORMAL
  1162 00:0948: 03 44 3E 53                  db      3,"D>S"
  1163                        D_TO_S:
  1164 00:094C: 7B                           tdc
  1165 00:094D: 1A                           inc     a                       ; Drop the high word
  1166 00:094E: 1A                           inc     a
  1167 00:094F: 5B                           tcd
  Wed Mar  9 2016 20:10                                                                                                    Page 24


  1168 00:0950: 4C E6 0D                     jmp     NEXT
  1169                        
  1170                        ; S>D ( n -- d )
  1171                        ;
  1172                        ; Convert the number n to the double-cell number d with the same numerical
  1173                        ; value.
  1174                        
  1175 00:0953: 45 09 00                     HEADER  NORMAL
  1176 00:0956: 03 53 3E 44                  db      3,"S>D"
  1177                        S_TO_D:
  1178 00:095A: 7B                           tdc
  1179 00:095B: 3A                           dec     a                       ; Assume n is positive
  1180 00:095C: 3A                           dec     a
  1181 00:095D: 5B                           tcd
  1182 00:095E: 64 01                        stz     <1                      ; .. push a zero value
  1183 00:0960: A5 03                        lda     <3                      ; Test the number
  1184 00:0962: 10 02                        bpl     S_TO_D_1
  1185 00:0964: C6 01                        dec     <1                      ; Make top -1 if negative
  1186 00:0966: 4C E6 0D     S_TO_D_1        jmp     NEXT                    ; Done
  1187                        
  1188                        ;==============================================================================
  1189                        ; Comparisons
  1190                        ;------------------------------------------------------------------------------
  1191                        
  1192                        ; 0< ( n -- flag )
  1193                        ;
  1194                        ; flag is true if and only if n is less than zero.
  1195                        
  1196 00:0969: 53 09 00                     HEADER  NORMAL
  1197 00:096C: 02 30 3C                     db      2,"0<"
  1198                        ZERO_LESS:
  1199 00:096F: A5 01                        lda     <1                      ; Test top of stack
  1200 00:0971: 64 01                        stz     <1                      ; Assume false result
  1201 00:0973: 10 02                        bpl     ZERO_LT_1               ; Was the value negative?
  1202 00:0975: C6 01                        dec     <1                      ; Yes, make true result
  1203 00:0977: 4C E6 0D     ZERO_LT_1:      jmp     NEXT                    ; Done
  1204                        
  1205                        ; 0<> ( x -- flag )
  1206                        ;
  1207                        ; flag is true if and only if x is not equal to zero.
  1208                        
  1209 00:097A: 69 09 00                     HEADER  NORMAL
  1210 00:097D: 03 30 3C 3E                  db      3,"0<>"
  1211                        ZERO_NOT_EQUAL:
  1212 00:0981: A5 01                        lda     <1                      ; Test top of stack
  1213 00:0983: 64 01                        stz     <1                      ; Assume false result
  1214 00:0985: F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
  1215 00:0987: C6 01                        dec     <1                      ; Yes, make true result
  1216 00:0989: 4C E6 0D     ZERO_NE_1:      jmp     NEXT                    ; Done
  1217                        
  1218                        ; 0= ( x -- flag )
  1219                        ;
  1220                        ; flag is true if and only if x is equal to zero.
  1221                        
  1222 00:098C: 7A 09 00                     HEADER  NORMAL
  1223 00:098F: 02 30 3D                     db      2,"0="
  1224                        ZERO_EQUAL:
  1225 00:0992: A5 01                        lda     <1                      ; Test top of stack
  Wed Mar  9 2016 20:10                                                                                                    Page 25


  1226 00:0994: 64 01                        stz     <1                      ; Assume false result
  1227 00:0996: D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
  1228 00:0998: C6 01                        dec     <1                      ; Yes, make true result
  1229 00:099A: 4C E6 0D     ZERO_EQ_1:      jmp     NEXT                    ; Done
  1230                        
  1231                        ; 0> ( n -- flag )
  1232                        ;
  1233                        ; flag is true if and only if n is greater than zero.
  1234                        
  1235 00:099D: 8C 09 00                     HEADER  NORMAL
  1236 00:09A0: 02 30 3E                     db      2,"0>"
  1237                        ZERO_GREATER:
  1238 00:09A3: A5 01                        lda     <1                      ; Test top of stack
  1239 00:09A5: 64 01                        stz     <1                      ; Assume false result
  1240 00:09A7: 30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
  1241 00:09A9: F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
  1242 00:09AB: C6 01                        dec     <1                      ; Yes, make true result
  1243 00:09AD: 4C E6 0D     ZERO_GT_EXIT:   jmp     NEXT                    ; Done
  1244                        
  1245                        ; <
  1246                        
  1247                        ; <>
  1248                        
  1249 00:09B0: 9D 09 00                     HEADER  NORMAL
  1250 00:09B3: 02 3C 3E                     db      2,"<>"
  1251                        NOT_EQUAL:
  1252 00:09B6: A6 01                        ldx     <1                      ; Pull x2 from stack
  1253 00:09B8: 7B                           tdc
  1254 00:09B9: 1A                           inc     a
  1255 00:09BA: 1A                           inc     a
  1256 00:09BB: 5B                           tcd
  1257 00:09BC: E4 01                        cpx     <1                      ; Compare with x1
  1258 00:09BE: 64 01                        stz     <1                      ; Assume equal
  1259 00:09C0: F0 02                        beq     NE_EXIT                 ; Test flags
  1260 00:09C2: C6 01                        dec     <1                      ; Make result true
  1261 00:09C4: 4C E6 0D     NE_EXIT:        jmp     NEXT                    ; Done
  1262                        
  1263                        ; = ( x1 x2 -- flag )
  1264                        ;
  1265                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  1266                        
  1267 00:09C7: B0 09 00                     HEADER  NORMAL
  1268 00:09CA: 01 3D                        db      1,"="
  1269                        EQUAL:
  1270 00:09CC: A6 01                        ldx     <1                      ; Pull x2 from stack
  1271 00:09CE: 7B                           tdc
  1272 00:09CF: 1A                           inc     a
  1273 00:09D0: 1A                           inc     a
  1274 00:09D1: 5B                           tcd
  1275 00:09D2: E4 01                        cpx     <1                      ; Compare with x1
  1276 00:09D4: 64 01                        stz     <1                      ; Assume not equal
  1277 00:09D6: D0 02                        bne     EQ_EXIT                 ; Test the flags
  1278 00:09D8: E6 01                        inc     <1                      ; Make result true
  1279 00:09DA: 4C E6 0D     EQ_EXIT:        jmp     NEXT                    ; Done
  1280                        
  1281                        ; >
  1282                        
  1283                        ; U<
  Wed Mar  9 2016 20:10                                                                                                    Page 26


  1284                        ; U>
  1285                        
  1286                        ;==============================================================================
  1287                        ; Logical Operations
  1288                        ;------------------------------------------------------------------------------
  1289                        
  1290                        ; AND ( x1 x2 -- x3 )
  1291                        ;
  1292                        ; x3 is the bit-by-bit logical and of x1 with x2.
  1293                        
  1294 00:09DD: C7 09 00                     HEADER  NORMAL
  1295 00:09E0: 03 41 4E 44                  db      3,"AND"
  1296                        AND:
  1297 00:09E4: A5 01                        lda     <1
  1298 00:09E6: 25 03                        and     <3
  1299 00:09E8: 85 03                        sta     <3
  1300 00:09EA: 7B                           tdc
  1301 00:09EB: 1A                           inc     a
  1302 00:09EC: 1A                           inc     a
  1303 00:09ED: 5B                           tcd
  1304 00:09EE: 4C E6 0D                     jmp     NEXT
  1305                        
  1306                        ; INVERT ( x1 -- x2 )
  1307                        ;
  1308                        ; Invert all bits of x1, giving its logical inverse x2.
  1309                        
  1310 00:09F1: DD 09 00                     HEADER  NORMAL
  1311 00:09F4: 06 49 4E 56                  db      6,"INVERT"
       00:09F8: 45 52 54 
  1312                        INVERT:
  1313 00:09FB: A5 01                        lda     <1                      ; Fetch top value
  1314 00:09FD: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1315 00:0A00: 85 01                        sta     <1                      ; .. and write back
  1316 00:0A02: 4C E6 0D                     jmp     NEXT                    ; Done
  1317                        
  1318                        ; LSHIFT ( x1 u -- x2 )
  1319                        ;
  1320                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1321                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1322                        ; exists if u is greater than or equal to the number of bits in a cell.
  1323                        
  1324 00:0A05: F1 09 00                     HEADER  NORMAL
  1325 00:0A08: 06 4C 53 48                  db      6,"LSHIFT"
       00:0A0C: 49 46 54 
  1326                        LSHIFT:
  1327 00:0A0F: A6 01                        ldx     <1                      ; Pull bit count
  1328 00:0A11: 08                           php
  1329 00:0A12: 7B                           tdc
  1330 00:0A13: 1A                           inc     a                       ; .. from the stack
  1331 00:0A14: 1A                           inc     a
  1332 00:0A15: 5B                           tcd
  1333 00:0A16: 28                           plp
  1334 00:0A17: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1335 00:0A19: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1336 00:0A1C: B0 08                        bcs     LSHIFT_2                ; Yes, result will be zero
  1337 00:0A1E: 06 01        LSHIFT_1        asl     <1                      ; Shift one bit left
  1338 00:0A20: CA                           dex                             ; Update count
  1339 00:0A21: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  Wed Mar  9 2016 20:10                                                                                                    Page 27


  1340 00:0A23: 4C E6 0D     LSHIFT_0        jmp     NEXT                    ; Done
  1341 00:0A26: 64 01        LSHIFT_2        stz     <1                      ; Clear top value
  1342 00:0A28: 4C E6 0D                     jmp     NEXT                    ; Done
  1343                        
  1344                        ; OR ( x1 x2 -- x3 )
  1345                        ;
  1346                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1347                        
  1348 00:0A2B: 05 0A 00                     HEADER  NORMAL
  1349 00:0A2E: 02 4F 52                     db      2,"OR"
  1350                        OR:
  1351 00:0A31: A5 01                        lda     <1
  1352 00:0A33: 05 03                        ora     <3
  1353 00:0A35: 85 03                        sta     <3
  1354 00:0A37: 7B                           tdc
  1355 00:0A38: 1A                           inc     a
  1356 00:0A39: 1A                           inc     a
  1357 00:0A3A: 5B                           tcd
  1358 00:0A3B: 4C E6 0D                     jmp     NEXT
  1359                        
  1360                        ; RSHIFT ( x1 u -- x2 )
  1361                        ;
  1362                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1363                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1364                        ; exists if u is greater than or equal to the number of bits in a cell.
  1365                        
  1366 00:0A3E: 2B 0A 00                     HEADER  NORMAL
  1367 00:0A41: 06 52 53 48                  db      6,"RSHIFT"
       00:0A45: 49 46 54 
  1368                        RSHIFT:
  1369 00:0A48: A6 01                        ldx     <1                      ; Pull bit count
  1370 00:0A4A: 08                           php
  1371 00:0A4B: 7B                           tdc
  1372 00:0A4C: 1A                           inc     a                       ; .. from the stack
  1373 00:0A4D: 1A                           inc     a
  1374 00:0A4E: 5B                           tcd
  1375 00:0A4F: 28                           plp
  1376 00:0A50: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1377 00:0A52: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1378 00:0A55: B0 08                        bcs     RSHIFT_2                ; Yes, result will be zero
  1379 00:0A57: 46 01        RSHIFT_1        lsr     <1                      ; Shift one bit left
  1380 00:0A59: CA                           dex                             ; Update count
  1381 00:0A5A: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1382 00:0A5C: 4C E6 0D     RSHIFT_0        jmp     NEXT                    ; Done
  1383 00:0A5F: 64 01        RSHIFT_2        stz     <1                      ; Clear top value
  1384 00:0A61: 4C E6 0D                     jmp     NEXT                    ; Done
  1385                        
  1386                        ; XOR ( x1 x2 -- x3 )
  1387                        ;
  1388                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1389                        
  1390 00:0A64: 3E 0A 00                     HEADER  NORMAL
  1391 00:0A67: 03 58 4F 52                  db      3,"XOR"
  1392                        XOR:
  1393 00:0A6B: A5 01                        lda     <1
  1394 00:0A6D: 45 03                        eor     <3
  1395 00:0A6F: 85 03                        sta     <3
  1396 00:0A71: 7B                           tdc
  Wed Mar  9 2016 20:10                                                                                                    Page 28


  1397 00:0A72: 1A                           inc     a
  1398 00:0A73: 1A                           inc     a
  1399 00:0A74: 5B                           tcd
  1400 00:0A75: 4C E6 0D                     jmp     NEXT
  1401                        
  1402                        ;==============================================================================
  1403                        ; Control Words
  1404                        ;------------------------------------------------------------------------------
  1405                        
  1406                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1407                        ;
  1408                        ; Empty the data stack and perform the function of QUIT, which includes
  1409                        ; emptying the return stack, without displaying a message.
  1410                        
  1411 00:0A78: 64 0A 00                     HEADER  NORMAL
  1412 00:0A7B: 05 41 42 4F                  db      5,"ABORT"
       00:0A7F: 52 54 
  1413 00:0A81: 20 E2 0D     ABORT:          jsr     DO_COLON
  1414 00:0A84: 88 0A                        dw      DO_ABORT
  1415 00:0A86: EE 0A                        dw      QUIT
  1416                        
  1417                        DO_ABORT:
  1418 00:0A88: A9 7F 01                     lda     #DSTACK_END-1
  1419 00:0A8B: 5B           		tcd
  1420 00:0A8C: 4C E6 0D                     jmp     NEXT
  1421                        
  1422                        ; (BUILD) ( dtc-addr -- )
  1423                        ;
  1424                        ; Adds a jump the to exection function for the new word.
  1425                        
  1426 00:0A8F: 78 0A 00                     HEADER  NORMAL
  1427 00:0A92: 07 28 42 55                  db      7,"(BUILD)"
       00:0A96: 49 4C 44 29 
  1428 00:0A9A: 20 E2 0D     BUILD:          jsr     DO_COLON
  1429 00:0A9D: AE 0E 20 00                  dw      DO_LITERAL,$20,C_COMMA
       00:0AA1: 10 06 
  1430 00:0AA3: 9A 05 E2 0A                  dw      COMMA,EXIT
  1431                        
  1432                        ; CREATE ( -- ) [TODO]
  1433                        ;
  1434                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1435                        ; definition for name with the execution semantics defined below. If the data-
  1436                        ; space pointer is not aligned, reserve enough data space to align it. The new
  1437                        ; data-space pointer defines names data field. CREATE does not allocate data
  1438                        ; space in names data field.
  1439                        
  1440 00:0AA7: 8F 0A 00                     HEADER  NORMAL
  1441 00:0AAA: 06 43 52 45                  db      6,"CREATE"
       00:0AAE: 41 54 45 
  1442 00:0AB1: 20 E2 0D     CREATE:         jsr     DO_COLON
  1443                                        ; parse
  1444 00:0AB4: 3C 06 AC 04                  dw      HERE,LATEST,FETCH,COMMA
       00:0AB8: DA 05 9A 05 
  1445 00:0ABC: 01 05 10 06                  dw      ZERO,C_COMMA,LATEST,STORE
       00:0AC0: AC 04 72 05 
  1446                                        ; move name
  1447 00:0AC4: E2 0A                        dw      EXIT
  1448                        
  Wed Mar  9 2016 20:10                                                                                                    Page 29


  1449                        ; EXECUTE ( i*x xt -- j*x )
  1450                        ;
  1451                        ; Remove xt from the stack and perform the semantics identified by it. Other
  1452                        ; stack effects are due to the word EXECUTEd.
  1453                        
  1454 00:0AC6: A7 0A 00                     HEADER  NORMAL
  1455 00:0AC9: 07 45 58 45                  db      7,"EXECUTE"
       00:0ACD: 43 55 54 45 
  1456                        EXECUTE:
  1457 00:0AD1: A6 01                        ldx     <1
  1458 00:0AD3: 7B                           tdc
  1459 00:0AD4: 1A                           inc     a
  1460 00:0AD5: 1A                           inc     a
  1461 00:0AD6: 5B                           tcd
  1462 00:0AD7: CA                           dex
  1463 00:0AD8: DA                           phx
  1464 00:0AD9: 60                           rts
  1465                        
  1466                        ; EXIT ( -- ) ( R: nest-sys -- )
  1467                        ;
  1468                        ; Return control to the calling definition specified by nest-sys. Before
  1469                        ; executing EXIT within a do-loop, a program shall discard the loop-control
  1470                        ; parameters by executing UNLOOP.
  1471                        
  1472 00:0ADA: C6 0A 00                     HEADER  NORMAL
  1473 00:0ADD: 04 45 58 49                  db      4,"EXIT"
       00:0AE1: 54 
  1474                        EXIT:
  1475 00:0AE2: 7A                           ply
  1476 00:0AE3: 4C E6 0D                     jmp     NEXT
  1477                        
  1478                        ; QUIT ( -- ) ( R: i*x -- )
  1479                        ;
  1480                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  1481                        ; user input device the input source, and enter interpretation state. Do not
  1482                        ; display a message. Repeat the following:
  1483                        ;  Accept a line from the input source into the input buffer, set >IN to zero,
  1484                        ;   and interpret.
  1485                        ;  Display the implementation-defined system prompt if in interpretation state,
  1486                        ;   all processing has been completed, and no ambiguous condition exists.
  1487                        ;
  1488                        ; In this implementation it is defined as:
  1489                        ;
  1490                        ;   DO_QUIT 0 STATE !
  1491                        ;   0 (SOURCE-ID) !
  1492                        ;   BEGIN
  1493                        ;     REFILL
  1494                        ;     WHILE SOURCE EVALUATE
  1495                        ;     STATE @ 0= IF CR S" Ok" TYPE THEN
  1496                        ;   AGAIN ;
  1497                        
  1498 00:0AE6: DA 0A 00                     HEADER  NORMAL
  1499 00:0AE9: 04 51 55 49                  db      4,"QUIT"
       00:0AED: 54 
  1500 00:0AEE: 20 E2 0D     QUIT:           jsr     DO_COLON
  1501 00:0AF1: 1C 0B                        dw      DO_QUIT
  1502 00:0AF3: 01 05 EB 04                  dw      ZERO,STATE,STORE
       00:0AF7: 72 05 
  Wed Mar  9 2016 20:10                                                                                                    Page 30


  1503 00:0AF9: 01 05 DD 04                  dw      ZERO,SOURCEID,STORE
       00:0AFD: 72 05 
  1504 00:0AFF: 4C 0C 7B 0E  QUIT_1:         dw      REFILL,QUERY_BRANCH,QUIT_2
       00:0B03: 07 0B 
  1505 00:0B05: E2 0B                        dw      INTERPRET
  1506 00:0B07: EB 04 DA 05  QUIT_2:         dw      STATE,FETCH,ZERO_EQUAL
       00:0B0B: 92 09 
  1507 00:0B0D: 7B 0E 18 0B                  dw      QUERY_BRANCH,QUIT_3
  1508 00:0B11: 52 0F                        dw      DO_S_QUOTE
  1509 00:0B13: 02 4F 6B                     db      2,"Ok"
  1510 00:0B16: EB 0F                        dw      TYPE
  1511 00:0B18: 69 0E FF 0A  QUIT_3:         dw      BRANCH,QUIT_1
  1512                        
  1513                        DO_QUIT:
  1514 00:0B1C: A9 FF 01                     lda     #RSTACK_END-1           ; Reset the return stack
  1515 00:0B1F: 1B                           tcs
  1516 00:0B20: 4C E6 0D                     jmp     NEXT                    ; Done
  1517                        
  1518                        ;==============================================================================
  1519                        ; Parser & Interpreter
  1520                        ;------------------------------------------------------------------------------
  1521                        
  1522                        ; ?NUMBER
  1523                        
  1524 00:0B23: E6 0A 00                     HEADER  NORMAL
  1525 00:0B26: 07 3F 4E 55                  db      7,"?NUMBER"
       00:0B2A: 4D 42 45 52 
  1526 00:0B2E: 20 E2 0D     QUERY_NUMBER:   jsr     DO_COLON
  1527                        
  1528 00:0B31: E2 0A                        dw      EXIT
  1529                        
  1530                        ; ACCEPT ( c-addr +n1 -- +n2 )
  1531                        ;
  1532                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  1533                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  1534                        ; received. A program that depends on the presence or absence of non-graphic
  1535                        ; characters in the string has an environmental dependency. The editing
  1536                        ; functions, if any, that the system performs in order to construct the string
  1537                        ; are implementation-defined.
  1538                        ;
  1539                        ; Input terminates when an implementation-defined line terminator is received.
  1540                        ; When input terminates, nothing is appended to the string, and the display is
  1541                        ; maintained in an implementation-defined way.
  1542                        ;
  1543                        ; +n2 is the length of the string stored at c-addr.
  1544                        ;
  1545                        ;   OVER + 1- OVER      -- sa ea a
  1546                        ;   BEGIN KEY           -- sa ea a c
  1547                        ;   DUP 0D <> WHILE
  1548                        ;     DUP 8 = OVER 127 = OR IF
  1549                        ;       DROP 1-
  1550                        ;       >R OVER R> UMAX
  1551                        ;       8 EMIT SPACE 8 EMIT
  1552                        ;     ELSE
  1553                        ;       DUP EMIT        -- sa ea a c
  1554                        ;       OVER C! 1+ OVER UMIN
  1555                        ;     THEN              -- sa ea a
  1556                        ;   REPEAT              -- sa ea a c
  Wed Mar  9 2016 20:10                                                                                                    Page 31


  1557                        ;   DROP NIP SWAP - ;
  1558                        
  1559 00:0B33: 23 0B 00                     HEADER  NORMAL
  1560 00:0B36: 06 41 43 43                  db      6,"ACCEPT"
       00:0B3A: 45 50 54 
  1561 00:0B3D: 20 E2 0D     ACCEPT:         jsr     DO_COLON
  1562 00:0B40: 4F 07 36 08                  dw      OVER,PLUS,ONE_MINUS,OVER
       00:0B44: 68 08 4F 07 
  1563 00:0B48: A0 0F 2F 07  ACCEPT_1:       dw      KEY,DUP,DO_LITERAL,$0D,NOT_EQUAL
       00:0B4C: AE 0E 0D 00 
       00:0B50: B6 09 
  1564 00:0B52: 7B 0E 9C 0B                  dw      QUERY_BRANCH,ACCEPT_4
  1565 00:0B56: 2F 07 AE 0E                  dw      DUP,DO_LITERAL,$08,EQUAL
       00:0B5A: 08 00 CC 09 
  1566 00:0B5E: 4F 07 AE 0E                  dw      OVER,DO_LITERAL,$7f,EQUAL,OR
       00:0B62: 7F 00 CC 09 
       00:0B66: 31 0A 
  1567 00:0B68: 7B 0E 8A 0B                  dw      QUERY_BRANCH,ACCEPT_2
  1568 00:0B6C: 21 07 68 08                  dw      DROP,ONE_MINUS
  1569 00:0B70: DE 07 4F 07                  dw      TO_R,OVER,R_FROM,UMAX
       00:0B74: 0E 08 B1 08 
  1570 00:0B78: AE 0E 08 00                  dw      DO_LITERAL,8,EMIT,SPACE
       00:0B7C: 8D 0F B9 0F 
  1571 00:0B80: AE 0E 08 00                  dw      DO_LITERAL,8,EMIT,BRANCH,ACCEPT_3
       00:0B84: 8D 0F 69 0E 
       00:0B88: 98 0B 
  1572 00:0B8A: 2F 07 8D 0F  ACCEPT_2:       dw      DUP,EMIT
  1573 00:0B8E: 4F 07 F9 05                  dw      OVER,C_STORE,ONE_PLUS,OVER,UMIN
       00:0B92: 5D 08 4F 07 
       00:0B96: C5 08 
  1574 00:0B98: 69 0E 48 0B  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  1575 00:0B9C: 21 07 41 07  ACCEPT_4:       dw      DROP,NIP,SWAP,MINUS,EXIT
       00:0BA0: 62 07 49 08 
       00:0BA4: E2 0A 
  1576                        
  1577                        ; EVALUATE ( i*x c-addr u -- j*x )
  1578                        ;
  1579                        ; Save the current input source specification. Store minus-one (-1) in
  1580                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  1581                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  1582                        ; parse area is empty, restore the prior input source specification. Other
  1583                        ; stack effects are due to the words EVALUATEd.
  1584                        ;
  1585                        ;   >R >R SAVE-INPUT
  1586                        ;   -1 (SOURCE-ID) !
  1587                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  1588                        ;   INTERPRET
  1589                        ;   RESTORE-INPUT DROP
  1590                        
  1591 00:0BA6: 33 0B 00                     HEADER  NORMAL
  1592 00:0BA9: 08 45 56 41                  db      8,"EVALUATE"
       00:0BAD: 4C 55 41 54 
       00:0BB1: 45 
  1593 00:0BB2: 20 E2 0D     EVALUATE:       jsr     DO_COLON
  1594 00:0BB5: DE 07 DE 07                  dw      TO_R,TO_R,SAVE_INPUT
       00:0BB9: AF 0C 
  1595 00:0BBB: 0E 08 0E 08                  dw      R_FROM,R_FROM
  1596 00:0BBF: 36 05 DD 04                  dw      TRUE,SOURCEID,STORE
  Wed Mar  9 2016 20:10                                                                                                    Page 32


       00:0BC3: 72 05 
  1597 00:0BC5: 01 05 68 04                  dw      ZERO,TO_IN,STORE
       00:0BC9: 72 05 
  1598 00:0BCB: BD 04 72 05                  dw      LENGTH,STORE
  1599 00:0BCF: 92 04 72 05                  dw      BUFFER,STORE
  1600 00:0BD3: E2 0B                        dw      INTERPRET
  1601 00:0BD5: 8A 0C 21 07                  dw      RESTORE_INPUT,DROP
  1602 00:0BD9: E2 0A                        dw      EXIT
  1603                        
  1604                        ; INTERPRET ( -- )
  1605                        ;
  1606                        ;
  1607                        ;   BEGIN
  1608                        ;   BL WORD DUP C@ WHILE        -- textadr
  1609                        ;       FIND                    -- a 0/1/-1
  1610                        ;       ?DUP IF                 -- xt 1/-1
  1611                        ;           1+ STATE @ 0= OR    immed or interp?
  1612                        ;           IF EXECUTE ELSE ,XT THEN
  1613                        ;       ELSE                    -- textadr
  1614                        ;           ?NUMBER
  1615                        ;           IF POSTPONE LITERAL     converted ok
  1616                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  1617                        ;           THEN
  1618                        ;       THEN
  1619                        ;   REPEAT DROP ;
  1620                        
  1621 00:0BDB: A6 0B E2                     HEADER  INTERPRET
  1622 00:0BDE: 09 00 54 45                  dw      9,"INTERPRET"
  1623 00:0BE2: 20 E2 0D     INTERPRET:      jsr     DO_COLON
  1624 00:0BE5: 10 05 F9 0C  INTERPRET_1:    dw      BL,WORD,DUP,C_FETCH,QUERY_BRANCH,INTERPRET_7
       00:0BE9: 2F 07 27 06 
       00:0BED: 7B 0E 31 0C 
  1625 00:0BF1: 3D 0C 12 07                  dw      FIND,QUERY_DUP,QUERY_BRANCH,INTERPRET_4
       00:0BF5: 7B 0E 13 0C 
  1626 00:0BF9: 5D 08 EB 04                  dw      ONE_PLUS,STATE,FETCH,ZERO_EQUAL,OR
       00:0BFD: DA 05 92 09 
       00:0C01: 31 0A 
  1627 00:0C03: 7B 0E 0D 0C                  dw      QUERY_BRANCH,INTERPRET_2,EXECUTE,BRANCH,INTERPRET_3
       00:0C07: D1 0A 69 0E 
       00:0C0B: 0F 0C 
  1628 00:0C0D: 9A 05        INTERPRET_2:    dw      COMMA
  1629 00:0C0F: 69 0E 2D 0C  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  1630 00:0C13: 2E 0B 7B 0E  INTERPRET_4:    dw      QUERY_NUMBER,QUERY_BRANCH,INTERPRET_5
       00:0C17: 1F 0C 
  1631 00:0C19: 94 0E 69 0E                  dw      LITERAL,BRANCH,INTERPRET_6
       00:0C1D: 2D 0C 
  1632 00:0C1F: 60 00 EB 0F  INTERPRET_5:    dw      COUNT,TYPE,DO_LITERAL,$3f,EMIT,CR,ABORT
       00:0C23: AE 0E 3F 00 
       00:0C27: 8D 0F 74 0F 
       00:0C2B: 81 0A 
  1633 00:0C2D: 69 0E E5 0B  INTERPRET_6     dw      BRANCH,INTERPRET_1
  1634 00:0C31: 21 07 E2 0A  INTERPRET_7:    dw      DROP,EXIT
  1635                        
  1636                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  1637                        ;
  1638                        ; Find the definition named in the counted string at c-addr. If the definition
  1639                        ; is not found, return c-addr and zero. If the definition is found, return its
  1640                        ; execution token xt. If the definition is immediate, also return one (1),
  Wed Mar  9 2016 20:10                                                                                                    Page 33


  1641                        ; otherwise also return minus-one (-1). For a given string, the values returned
  1642                        ; by FIND while compiling may differ from those returned while not compiling.
  1643                        ;
  1644                        ;   LATEST @ BEGIN             -- a nfa
  1645                        ;     2DUP OVER C@ CHAR+       -- a nfa a nfa n+1
  1646                        ;     N=                       -- a nfa f
  1647                        ;     DUP IF
  1648                        ;       DROP
  1649                        ;       NFA>LFA H@ DUP         -- a link link
  1650                        ;     THEN
  1651                        ;   0= UNTIL                   -- a nfa  OR  a 0
  1652                        ;   DUP IF
  1653                        ;     NIP DUP NFA>CFA          -- nfa xt
  1654                        ;     SWAP IMMED?              -- xt iflag
  1655                        ;     0= 1 OR                  -- xt 1/-1
  1656                        ;   THEN ;
  1657                        
  1658 00:0C35: DB 0B 00                     HEADER  NORMAL
  1659 00:0C38: 04 46 49 4E                  db      4,"FIND"
       00:0C3C: 44 
  1660 00:0C3D: 20 E2 0D     FIND:           jsr     DO_COLON
  1661                        
  1662                        
  1663                        
  1664 00:0C40: E2 0A                        dw      EXIT
  1665                        
  1666                        ; REFILL ( -- flag )
  1667                        ;
  1668                        ; Attempt to fill the input buffer from the input source, returning a true flag
  1669                        ; if successful.
  1670                        ;
  1671                        ; When the input source is the user input device, attempt to receive input into
  1672                        ; the terminal input buffer. If successful, make the result the input buffer,
  1673                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  1674                        ; is considered successful. If there is no input available from the current
  1675                        ; input source, return false.
  1676                        ;
  1677                        ; When the input source is a string from EVALUATE, return false and perform no
  1678                        ; other action.
  1679                        ;
  1680                        ;   SOURCE-ID 0= IF
  1681                        ;     TIB DUP #TIB @ ACCEPT SPACE
  1682                        ;     LENGTH ! BUFFER !
  1683                        ;     0 >IN ! TRUE EXIT
  1684                        ;   THEN
  1685                        ;   FALSE
  1686                        
  1687 00:0C42: 35 0C 00                     HEADER  NORMAL
  1688 00:0C45: 06 52 45 46                  db      6,"REFILL"
       00:0C49: 49 4C 4C 
  1689 00:0C4C: 20 E2 0D     REFILL:         jsr     DO_COLON
  1690 00:0C4F: E8 0C 92 09                  dw      SOURCE_ID,ZERO_EQUAL,QUERY_BRANCH,REFILL_1
       00:0C53: 7B 0E 75 0C 
  1691 00:0C57: F7 04 2F 07                  dw      TIB,DUP,HASH_TIB,FETCH,ACCEPT,SPACE
       00:0C5B: 5A 04 DA 05 
       00:0C5F: 3D 0B B9 0F 
  1692 00:0C63: BD 04 72 05                  dw      LENGTH,STORE,BUFFER,STORE
       00:0C67: 92 04 72 05 
  Wed Mar  9 2016 20:10                                                                                                    Page 34


  1693 00:0C6B: 01 05 68 04                  dw      ZERO,TO_IN,STORE,TRUE,EXIT
       00:0C6F: 72 05 36 05 
       00:0C73: E2 0A 
  1694 00:0C75: 25 05 E2 0A  REFILL_1:       dw      FALSE,EXIT
  1695                        
  1696                        ; RESTORE-INPUT
  1697                        ;
  1698                        ;   >IN ! (LENGTH) ! BUFFER !
  1699                        ;   SOURCEID !
  1700                        ;   TRUE
  1701                        
  1702 00:0C79: 42 0C 00                     HEADER  NORMAL
  1703 00:0C7C: 0D 52 45 53                  db      13,"RESTORE-INPUT"
       00:0C80: 54 4F 52 45 
       00:0C84: 2D 49 4E 50 
       00:0C88: 55 54 
  1704 00:0C8A: 20 E2 0D     RESTORE_INPUT   jsr     DO_COLON
  1705 00:0C8D: 68 04 72 05                  dw      TO_IN,STORE
  1706 00:0C91: BD 04 72 05                  dw      LENGTH,STORE
  1707 00:0C95: 92 04 72 05                  dw      BUFFER,STORE
  1708 00:0C99: DD 04 72 05                  dw      SOURCEID,STORE
  1709 00:0C9D: 36 05 E2 0A                  dw      TRUE,EXIT
  1710                        
  1711                        ; SAVE-INPUT
  1712                        
  1713 00:0CA1: 79 0C 00                     HEADER  NORMAL
  1714 00:0CA4: 0A 53 41 56                  db      10,"SAVE-INPUT"
       00:0CA8: 45 2D 49 4E 
       00:0CAC: 50 55 54 
  1715 00:0CAF: 20 E2 0D     SAVE_INPUT:     jsr     DO_COLON
  1716 00:0CB2: DD 04 DA 05                  dw      SOURCEID,FETCH
  1717 00:0CB6: 92 04 DA 05                  dw      BUFFER,FETCH
  1718 00:0CBA: BD 04 DA 05                  dw      LENGTH,FETCH
  1719 00:0CBE: 68 04 DA 05                  dw      TO_IN,FETCH,EXIT
       00:0CC2: E2 0A 
  1720                        
  1721                        ; SOURCE ( -- c-addr u )
  1722                        ;
  1723                        ; c-addr is the address of, and u is the number of characters in, the input
  1724                        ; buffer.
  1725                        ;
  1726                        ; In this implementation it is defined as
  1727                        ;
  1728                        ;   BUFFER @ LENGTH @
  1729                        
  1730 00:0CC4: A1 0C 00                     HEADER  NORMAL
  1731 00:0CC7: 06 53 4F 55                  db      6,"SOURCE"
       00:0CCB: 52 43 45 
  1732 00:0CCE: 20 E2 0D     SOURCE:         jsr     DO_COLON
  1733 00:0CD1: 92 04 DA 05                  dw      BUFFER,FETCH
  1734 00:0CD5: BD 04 DA 05                  dw      LENGTH,FETCH
  1735 00:0CD9: E2 0A                        dw      EXIT
  1736                        
  1737                        ; SOURCE-ID ( -- 0 | -1 )
  1738                        ;
  1739                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  1740                        ; device.
  1741                        
  Wed Mar  9 2016 20:10                                                                                                    Page 35


  1742 00:0CDB: C4 0C 00                     HEADER  NORMAL
  1743 00:0CDE: 09 53 4F 55                  db      9,"SOURCE-ID"
       00:0CE2: 52 43 45 2D 
       00:0CE6: 49 44 
  1744 00:0CE8: 20 E2 0D     SOURCE_ID:      jsr     DO_COLON
  1745 00:0CEB: DD 04 DA 05                  dw      SOURCEID,FETCH
  1746 00:0CEF: E2 0A                        dw      EXIT
  1747                        
  1748                        ; WORD
  1749                        ;
  1750                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  1751                        ;   DUP >R   ROT SKIP           -- c adr' n'
  1752                        ;   OVER >R  ROT SCAN           -- adr" n"
  1753                        ;   DUP IF CHAR- THEN        skip trailing delim.
  1754                        ;   R> R> ROT -   >IN +!        update >IN offset
  1755                        ;   TUCK -                      -- adr' N
  1756                        ;   HERE >counted               --
  1757                        ;   HERE                        -- a
  1758                        ;   BL OVER COUNT + C! ;    append trailing blank
  1759                        
  1760 00:0CF1: DB 0C 00                     HEADER  NORMAL
  1761 00:0CF4: 04 57 4F 52                  db      4,"WORD"
       00:0CF8: 44 
  1762 00:0CF9: 20 E2 0D     WORD:           jsr     DO_COLON
  1763 00:0CFC: 2F 07 CE 0C                  dw      DUP,SOURCE,TO_IN,FETCH,SLASH_STRING
       00:0D00: 68 04 DA 05 
       00:0D04: 79 0D 
  1764 00:0D06: 2F 07 DE 07                  dw      DUP,TO_R,ROT,SKIP
       00:0D0A: 74 07 40 0D 
  1765 00:0D0E: 4F 07 DE 07                  dw      OVER,TO_R,ROT,SCAN
       00:0D12: 74 07 57 0D 
  1766 00:0D16: 2F 07 7B 0E  		dw	DUP,QUERY_BRANCH,WORD_1,CHAR_MINUS
       00:0D1A: 1E 0D 94 06 
  1767 00:0D1E: 0E 08 0E 08  WORD_1:		dw	R_FROM,R_FROM,ROT,MINUS,TO_IN,PLUS_STORE
       00:0D22: 74 07 49 08 
       00:0D26: 68 04 85 05 
  1768 00:0D2A: 8B 07 49 08  		dw	TUCK,MINUS
1769: ***ERROR - Undefined symbol - <TO_COUNTED>

  1769 00:0D2E: 3C 06 xx xx  		dw	HERE,TO_COUNTED
  1770 00:0D32: 3C 06        		dw	HERE
  1771 00:0D34: 10 05 4F 07  		dw	BL,OVER,COUNT,PLUS,C_STORE
       00:0D38: 67 00 36 08 
       00:0D3C: F9 05 
  1772 00:0D3E: E2 0A        		dw	EXIT
  1773                        
  1774                        ; SKIP ( c-addr n c == c-addr' n' )
  1775                        
  1776                        SKIP:
  1777 00:0D40: A5 03        SKIP_1:         lda     <3                      ; Any data left to skip over?
  1778 00:0D42: F0 10                        beq     SKIP_2                  ; No.
  1779 00:0D44: A5 01                        lda     <1                      ; Fetch and compare with skip
  1780 00:0D46: E2 20                        short_a
  1781 00:0D48: D2 05                        cmp     (5)
  1782 00:0D4A: C2 20                        long_a
  1783 00:0D4C: D0 06                        bne     SKIP_2                  ; Cannot be skipped
  1784 00:0D4E: E6 05                        inc     <5                      ; Bump data address
  Wed Mar  9 2016 20:10                                                                                                    Page 36


  1785 00:0D50: C6 03                        dec     <3                      ; and update length
  1786 00:0D52: 80 EC                        bra     SKIP_1                  ; And repeat
  1787                        
  1788                        SKIP_2:
  1789 00:0D54: 4C 21 07                     jmp     DROP                    ; Drop the character
  1790                        
  1791                        ; SKIP ( c-addr n c == c-addr' n' )
  1792                        
  1793 00:0D57: 20 E2 0D     SCAN:           jsr     DO_COLON
  1794                        
  1795 00:0D5A: E2 0A                        dw      EXIT
  1796                        
  1797                        ;==============================================================================
  1798                        ; String Words
  1799                        ;------------------------------------------------------------------------------
  1800                        
  1801                        ; -TRAILING
  1802                        
  1803 00:0D5C: F1 0C 00                     HEADER  NORMAL
  1804 00:0D5F: 09 2D 54 52                  db      9,"-TRAILING"
       00:0D63: 41 49 4C 49 
       00:0D67: 4E 47 
  1805 00:0D69: 20 E2 0D     DASH_TRAILING:  jsr     DO_COLON
  1806                        
  1807 00:0D6C: E2 0A                        dw      EXIT
  1808                        
  1809                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  1810                        ;
  1811                        ; Adjust the character string at c-addr1 by n characters. The resulting
  1812                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  1813                        ; characters and is u1 minus n characters long.
  1814                        ;
  1815                        ;   ROT OVER + ROT ROT -
  1816                        
  1817 00:0D6E: 5C 0D 00                     HEADER  NORMAL
  1818 00:0D71: 07 2F 53 54                  db      7,"/STRING"
       00:0D75: 52 49 4E 47 
  1819 00:0D79: 20 E2 0D     SLASH_STRING:   jsr     DO_COLON
  1820 00:0D7C: 74 07 4F 07                  dw      ROT,OVER,PLUS
       00:0D80: 36 08 
  1821 00:0D82: 74 07 74 07                  dw      ROT,ROT,MINUS
       00:0D86: 49 08 
  1822 00:0D88: E2 0A                        dw      EXIT
  1823                        
  1824                        ; BLANK
  1825                        
  1826                        ; CMOVE ( c-addr1 c-addr2 u -- )
  1827                        ;
  1828                        ; If u is greater than zero, copy u consecutive characters from the data space
  1829                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  1830                        ; character from lower addresses to higher addresses.
  1831                        
  1832 00:0D8A: 6E 0D 00                     HEADER  NORMAL
  1833 00:0D8D: 05 43 4D 4F                  db      5,"CMOVE"
       00:0D91: 56 45 
  1834                        CMOVE:
  1835 00:0D93: 5A                           phy                             ; Save IP
  1836 00:0D94: DA                           phx                             ; Save stack pointer
  Wed Mar  9 2016 20:10                                                                                                    Page 37


  1837 00:0D95: A5 01                        lda     <1                      ; Fetch length and save
  1838 00:0D97: 48                           pha
  1839 00:0D98: A4 03                        ldy     <3                      ; Fetch target address
  1840 00:0D9A: A5 05                        lda     <5                      ; Fetch source address
  1841 00:0D9C: AA                           tax
  1842 00:0D9D: 68                           pla                             ; Recover length
  1843 00:0D9E: F0 04                        beq     CMOVE_1                 ; .. No bytes to move
  1844 00:0DA0: 3A                           dec     a                       ; Adjust count for MVN
  1845 00:0DA1: 54 00 00                     mvn     0,0                     ; Perform the move
  1846 00:0DA4: FA           CMOVE_1:        plx
  1847 00:0DA5: E8                           inx                             ; Clean up the stack
  1848 00:0DA6: E8                           inx
  1849 00:0DA7: E8                           inx
  1850 00:0DA8: E8                           inx
  1851 00:0DA9: E8                           inx
  1852 00:0DAA: E8                           inx
  1853 00:0DAB: 7A                           ply                             ; Restore IP
  1854 00:0DAC: 4C E6 0D                     jmp     NEXT
  1855                        
  1856                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  1857                        ;
  1858                        ; If u is greater than zero, copy u consecutive characters from the data space
  1859                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  1860                        ; character from higher addresses to lower addresses.
  1861                        
  1862 00:0DAF: 8A 0D 00                     HEADER  NORMAL
  1863 00:0DB2: 06 43 4D 4F                  db      6,"CMOVE>"
       00:0DB6: 56 45 3E 
  1864                        CMOVE_GREATER:
  1865 00:0DB9: 4C E6 0D                     jmp     NEXT
  1866                        
  1867                        ; COMPARE
  1868                        
  1869                        ; SEARCH
  1870                        
  1871                        
  1872                        ;==============================================================================
  1873                        ; Compiling Words
  1874                        ;------------------------------------------------------------------------------
  1875                        
  1876                        ; +LOOP ( -- )
  1877                        
  1878 00:0DBC: AF 0D 80                     HEADER  IMMEDIATE
  1879 00:0DBF: 05 2B 4C 4F                  db      5,"+LOOP"
       00:0DC3: 4F 50 
  1880 00:0DC5: 20 E2 0D     PLUS_LOOP:      jsr     DO_COLON
  1881                        
  1882 00:0DC8: E2 0A                        dw      EXIT
  1883                        
  1884                        ; (+LOOP)
  1885                        
  1886 00:0DCA: BC 0D 00                     HEADER  NORMAL
  1887 00:0DCD: 07 28 2B 4C                  db      7,"(+LOOP)"
       00:0DD1: 4F 4F 50 29 
  1888                        DO_PLUS_LOOP:
  1889                        
  1890 00:0DD5: 4C E6 0D                     jmp     NEXT
  1891                        
  Wed Mar  9 2016 20:10                                                                                                    Page 38


  1892                        ; : ( -- )
  1893                        
  1894 00:0DD8: CA 0D 00                     HEADER  NORMAL
  1895 00:0DDB: 01 3A                        db      1,":"
  1896 00:0DDD: 20 E2 0D     COLON:          jsr     DO_COLON
  1897                        
  1898 00:0DE0: E2 0A                        dw      EXIT
  1899                        
  1900                        DO_COLON:
  1901 00:0DE2: FA                           plx
  1902 00:0DE3: 5A                           phy
  1903 00:0DE4: E8                           inx
  1904 00:0DE5: 9B                           txy
  1905                        
  1906                        NEXT:
  1907 00:0DE6: BB                           tyx                             ; Copy IP to X
  1908 00:0DE7: C8                           iny
  1909 00:0DE8: C8                           iny
  1910 00:0DE9: 7C 00 00                     jmp     (0,x)                   ; Then execute word
  1911                        
  1912                        ; AGAIN
  1913                        
  1914 00:0DEC: D8 0D 80                     HEADER  IMMEDIATE
  1915 00:0DEF: 05 00 4E 49                  dw      5,"AGAIN"
  1916 00:0DF3: 20 E2 0D     AGAIN:          jsr     DO_COLON
  1917                        
  1918 00:0DF6: E2 0A                        dw      EXIT
  1919                        
  1920                        ; BEGIN
  1921                        
  1922 00:0DF8: EC 0D 80                     HEADER  IMMEDIATE
  1923 00:0DFB: 05 00 4E 49                  dw      5,"BEGIN"
  1924 00:0DFF: 20 E2 0D     BEGIN:          jsr     DO_COLON
  1925                        
  1926 00:0E02: E2 0A                        dw      EXIT
  1927                        
  1928                        ; CONSTANT ( x <spaces>name -- )
  1929                        ;
  1930                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1931                        ; definition for name with the execution semantics defined below.
  1932                        
  1933 00:0E04: F8 0D 00                     HEADER  NORMAL
  1934 00:0E07: 08 43 4F 4E                  db      8,"CONSTANT"
       00:0E0B: 53 54 41 4E 
       00:0E0F: 54 
  1935 00:0E10: 20 E2 0D     CONSTANT:       jsr     DO_COLON
  1936 00:0E13: B1 0A                        dw      CREATE
  1937 00:0E15: AE 0E 2D 0E                  dw      DO_LITERAL,DO_CONSTANT,BUILD
       00:0E19: 9A 0A 
  1938 00:0E1B: 9A 05 E2 0A                  dw      COMMA,EXIT
  1939                        
  1940                        ; (CONSTANT) ( -- x )
  1941                        
  1942 00:0E1F: 04 0E 00                     HEADER  NORMAL
  1943 00:0E22: 0A 28 43 4F                  db      10,"(CONSTANT)"
       00:0E26: 4E 53 54 41 
       00:0E2A: 4E 54 29 
  1944                        DO_CONSTANT:
  Wed Mar  9 2016 20:10                                                                                                    Page 39


  1945 00:0E2D: FA                           plx
  1946 00:0E2E: 7B                           tdc
  1947 00:0E2F: 3A                           dec     a
  1948 00:0E30: 3A                           dec     a
  1949 00:0E31: 5B                           tcd
  1950 00:0E32: BD 01 00                     lda     !1,x
  1951 00:0E35: 85 01                        sta     <1
  1952 00:0E37: 4C E6 0D                     jmp     NEXT                    ; Done
  1953                        
  1954                        ; DO ( -- )
  1955                        
  1956 00:0E3A: 1F 0E 80                     HEADER  IMMEDIATE
  1957 00:0E3D: 02 44 4F                     db      2,"DO"
  1958 00:0E40: 20 E2 0D     DO:             jsr     DO_COLON
  1959                        
  1960 00:0E43: E2 0A                        dw      EXIT
  1961                        
  1962                        ; (DO) ( -- )
  1963                        
  1964 00:0E45: 3A 0E 00                     HEADER  NORMAL
  1965 00:0E48: 04 28 44 4F                  db      4,"(DO)"
       00:0E4C: 29 
  1966                        DO_DO:
  1967 00:0E4D: A5 03                        lda     <3
  1968 00:0E4F: 48                           pha
  1969 00:0E50: A5 01                        lda     <1
  1970 00:0E52: 48                           pha
  1971 00:0E53: 7B                           tdc
  1972 00:0E54: 1A                           inc     a
  1973 00:0E55: 1A                           inc     a
  1974 00:0E56: 1A                           inc     a
  1975 00:0E57: 1A                           inc     a
  1976 00:0E58: 5B                           tcd
  1977 00:0E59: 4C E6 0D                     jmp     NEXT
  1978                        
  1979                        ; ELSE
  1980                        
  1981 00:0E5C: 45 0E 80                     HEADER  IMMEDIATE
  1982 00:0E5F: 04 45 4C 53                  db      4,"ELSE"
       00:0E63: 45 
  1983 00:0E64: 20 E2 0D     ELSE:           jsr     DO_COLON
  1984                        
  1985 00:0E67: E2 0A                        dw      EXIT
  1986                        
  1987                        ; (BRANCH) ( -- )
  1988                        ;
  1989                        ; Cause the IP to be loaded with the word following the link to this word.
  1990                        
  1991                        BRANCH:
  1992 00:0E69: B9 00 00                     lda     !0,y                    ; Load branch address into IP
  1993 00:0E6C: A8                           tay
  1994 00:0E6D: 4C E6 0D                     jmp     NEXT                    ; Done
  1995                        
  1996                        ; IF
  1997                        
  1998 00:0E70: 5C 0E 80                     HEADER  IMMEDIATE
  1999 00:0E73: 02 49 46                     db      2,"IF"
  2000 00:0E76: 20 E2 0D     IF:             jsr     DO_COLON
  Wed Mar  9 2016 20:10                                                                                                    Page 40


  2001                        
  2002 00:0E79: E2 0A                        dw      EXIT
  2003                        
  2004                        ; (?BRANCH) ( flag -- )
  2005                        ;
  2006                        ; If flag is false then cause the IP to be loaded with the word following the
  2007                        ; link to this word, otherwise skip over it.
  2008                        
  2009                        QUERY_BRANCH:
  2010 00:0E7B: A6 01                        ldx     <1                      ; Pull the top of stack value
  2011 00:0E7D: 7B                           tdc
  2012 00:0E7E: 1A                           inc     a                       ; Drop top item
  2013 00:0E7F: 1A                           inc     a
  2014 00:0E80: 5B                           tcd
  2015 00:0E81: 8A                           txa
  2016 00:0E82: F0 E5                        beq     BRANCH                  ; Branch if top was zero
  2017 00:0E84: C8                           iny                             ; Otherwise skip address
  2018 00:0E85: C8                           iny
  2019 00:0E86: 4C E6 0D                     jmp     NEXT                    ; Done
  2020                        
  2021                        ; LITERAL ( x -- )
  2022                        ;
  2023                        ; Append the run-time semantics given below to the current definition.
  2024                        
  2025 00:0E89: 70 0E 80                     HEADER  IMMEDIATE
  2026 00:0E8C: 07 4C 49 54                  db      7,"LITERAL"
       00:0E90: 45 52 41 4C 
  2027 00:0E94: 20 E2 0D     LITERAL:        jsr     DO_COLON
  2028 00:0E97: AE 0E AE 0E                  dw      DO_LITERAL,DO_LITERAL,COMMA
       00:0E9B: 9A 05 
  2029 00:0E9D: 9A 05 E2 0A                  dw      COMMA,EXIT
  2030                        
  2031                        ; (LITERAL) ( -- x )
  2032                        ;
  2033                        ; Place x on the stack.
  2034                        
  2035 00:0EA1: 89 0E 00                     HEADER  NORMAL
  2036 00:0EA4: 09 28 4C 49                  db      9,"(LITERAL)"
       00:0EA8: 54 45 52 41 
       00:0EAC: 4C 29 
  2037                        DO_LITERAL:
  2038 00:0EAE: 7B                           tdc
  2039 00:0EAF: 3A                           dec     a
  2040 00:0EB0: 3A                           dec     a
  2041 00:0EB1: 5B                           tcd
  2042 00:0EB2: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  2043 00:0EB5: C8                           iny
  2044 00:0EB6: C8                           iny
  2045 00:0EB7: 85 01                        sta     <1
  2046 00:0EB9: 4C E6 0D                     jmp     NEXT                    ; Done
  2047                        
  2048                        ; LOOP
  2049                        
  2050 00:0EBC: A1 0E 80                     HEADER  IMMEDIATE
  2051 00:0EBF: 04 4C 4F 4F                  db      4,"LOOP"
       00:0EC3: 50 
  2052 00:0EC4: 20 E2 0D     LOOP:           jsr     DO_COLON
  2053                        
  Wed Mar  9 2016 20:10                                                                                                    Page 41


  2054 00:0EC7: E2 0A                        dw      EXIT
  2055                        
  2056                        ; (LOOP)
  2057                        
  2058 00:0EC9: BC 0E 00                     HEADER  NORMAL
  2059 00:0ECC: 06 28 4C 4F                  db      6,"(LOOP)"
       00:0ED0: 4F 50 29 
  2060                        DO_LOOP
  2061 00:0ED3: A3 01                        lda     1,s                     ; Add one to loop counter
  2062 00:0ED5: 1A                           inc     a
  2063 00:0ED6: 83 01                        sta     1,s
  2064 00:0ED8: C3 03                        cmp     3,s                     ; Reached limit?
  2065 00:0EDA: B0 07                        bcs     DO_LOOP_END             ; Yes
  2066 00:0EDC: B9 00 00                     lda     !0,y                    ; No, branch back to start
  2067 00:0EDF: A8                           tay
  2068 00:0EE0: 4C E6 0D                     jmp     NEXT                    ; Done
  2069 00:0EE3: C8           DO_LOOP_END:    iny                             ; Skip over address
  2070 00:0EE4: C8                           iny
  2071 00:0EE5: 68                           pla                             ; Drop loop variables
  2072 00:0EE6: 68                           pla
  2073 00:0EE7: 4C E6 0D                     jmp     NEXT                    ; Done
  2074                        
  2075                        ; USER
  2076                        
  2077 00:0EEA: C9 0E 00                     HEADER  NORMAL
  2078 00:0EED: 04 55 53 45                  db      4,"USER"
       00:0EF1: 52 
  2079 00:0EF2: 20 E2 0D     USER:           jsr     DO_COLON
  2080                        
  2081 00:0EF5: E2 0A                        dw      EXIT
  2082                        
  2083 00:0EF7: EA 0E 00                     HEADER  NORMAL
  2084 00:0EFA: 06 28 55 53                  db      6,"(USER)"
       00:0EFE: 45 52 29 
  2085                        DO_USER:
  2086 00:0F01: 7B                           tdc
  2087 00:0F02: 3A                           dec     a                       ; Push on data stack
  2088 00:0F03: 3A                           dec     a
  2089 00:0F04: 5B                           tcd
  2090 00:0F05: FA                           plx
  2091 00:0F06: 18                           clc
  2092 00:0F07: BD 01 00                     lda     !1,x
  2093 00:0F0A: 69 00 00                     adc     #USER_AREA
  2094 00:0F0D: 85 01                        sta     <1
  2095 00:0F0F: 4C E6 0D                     jmp     NEXT                    ; Done
  2096                        
  2097                        ; VARIABLE ( <spaces>name -- )
  2098                        ;
  2099                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2100                        ; definition for name with the execution semantics defined below. Reserve one
  2101                        ; cell of data space at an aligned address.
  2102                        
  2103 00:0F12: F7 0E 00                     HEADER  NORMAL
  2104 00:0F15: 08 56 41 52                  db      8,"VARIABLE"
       00:0F19: 49 41 42 4C 
       00:0F1D: 45 
  2105 00:0F1E: 20 E2 0D     VARIABLE:       jsr     DO_COLON
  2106 00:0F21: B1 0A                        dw      CREATE
  Wed Mar  9 2016 20:10                                                                                                    Page 42


  2107 00:0F23: AE 0E 41 0F                  dw      DO_LITERAL,DO_VARIABLE,BUILD
       00:0F27: 9A 0A 
2108: ***ERROR - Undefined symbol - <ONE>

  2108 00:0F29: xx xx 78 06                  dw      ONE,CELLS,ALLOT,EXIT
       00:0F2D: EA 05 E2 0A 
  2109 00:0F31: E2 0A                        dw      EXIT
  2110                        
  2111 00:0F33: 12 0F 00                     HEADER  NORMAL
  2112 00:0F36: 0A 28 56 41                  db      10,"(VARIABLE)"
       00:0F3A: 52 49 41 42 
       00:0F3E: 4C 45 29 
  2113                        DO_VARIABLE:
  2114 00:0F41: 7B                           tdc
  2115 00:0F42: 3A                           dec     a
  2116 00:0F43: 3A                           dec     a
  2117 00:0F44: 5B                           tcd
  2118 00:0F45: 68                           pla
  2119 00:0F46: 1A                           inc     a
  2120 00:0F47: 85 01                        sta     <1
  2121 00:0F49: 4C E6 0D                     jmp     NEXT
  2122                        
  2123                        ; S"
  2124                        
  2125 00:0F4C: 33 0F 80                     HEADER  IMMEDIATE
  2126 00:0F4F: 02 53 22                     db      2,"S",'"'
  2127                        S_QUOTE:
  2128                        
  2129                        ; (S") ( -- c-addr u )
  2130                        
  2131                        DO_S_QUOTE:
  2132 00:0F52: 7B                           tdc
  2133 00:0F53: 3A                           dec     a                       ; Reserve space for values
  2134 00:0F54: 3A                           dec     a
  2135 00:0F55: 3A                           dec     a
  2136 00:0F56: 3A                           dec     a
  2137 00:0F57: 5B                           tcd
  2138 00:0F58: E2 20                        short_a
  2139 00:0F5A: B9 00 00                     lda     !0,y                    ; Fetch the length
  2140 00:0F5D: 85 01                        sta     <1
  2141 00:0F5F: 64 02                        stz     <2
  2142 00:0F61: C2 20                        long_a
  2143 00:0F63: C8                           iny
  2144 00:0F64: 98                           tya                             ; Save the text address
  2145 00:0F65: 85 03                        sta     <3
  2146 00:0F67: 18                           clc                             ; And update IP
  2147 00:0F68: 65 01                        adc     <1
  2148 00:0F6A: A8                           tay
  2149 00:0F6B: 4C E6 0D                     jmp     NEXT                    ; Done
  2150                        
  2151                        ;==============================================================================
  2152                        ; I/O Operations
  2153                        ;------------------------------------------------------------------------------
  2154                        
  2155                        ; CR ( -- )
  2156                        ;
  2157                        ; Cause subsequent output to appear at the beginning of the next line.
  Wed Mar  9 2016 20:10                                                                                                    Page 43


  2158                        ;
  2159                        ; In this implementation it is defined as
  2160                        ;
  2161                        ;   13 EMIT 10 EMIT
  2162                        
  2163 00:0F6E: 4C 0F 00                     HEADER  NORMAL
  2164 00:0F71: 02 43 52                     db      2,"CR"
  2165 00:0F74: 20 E2 0D     CR:             jsr     DO_COLON
  2166 00:0F77: AE 0E 0D 00                  dw      DO_LITERAL,13,EMIT
       00:0F7B: 8D 0F 
  2167 00:0F7D: AE 0E 0A 00                  dw      DO_LITERAL,10,EMIT
       00:0F81: 8D 0F 
  2168 00:0F83: E2 0A                        dw      EXIT
  2169                        
  2170                        ; EMIT ( x -- )
  2171                        ;
  2172                        ; If x is a graphic character in the implementation-defined character set,
  2173                        ; display x. The effect of EMIT for all other values of x is implementation
  2174                        ; -defined.
  2175                        
  2176 00:0F85: 6E 0F 00                     HEADER  NORMAL
  2177 00:0F88: 04 45 4D 49                  db      4,"EMIT"
       00:0F8C: 54 
  2178                                        extern  UartTx
  2179                        EMIT:
  2180 00:0F8D: A5 01                        lda     <1                      ; Fetch character from stack
  2181 00:0F8F: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  2182 00:0F92: 7B                           tdc
  2183 00:0F93: 1A                           inc     a                       ; Drop the character
  2184 00:0F94: 1A                           inc     a
  2185 00:0F95: 5B                           tcd
  2186 00:0F96: 4C E6 0D                     jmp     NEXT                    ; Done
  2187                        
  2188                        ; KEY ( -- char )
  2189                        ;
  2190                        ; Receive one character char, a member of the implementation-defined character
  2191                        ; set. Keyboard events that do not correspond to such characters are discarded
  2192                        ; until a valid character is received, and those events are subsequently
  2193                        ; unavailable.
  2194                        ;
  2195                        ; All standard characters can be received. Characters received by KEY are not
  2196                        ; displayed.
  2197                        
  2198 00:0F99: 85 0F 00                     HEADER  NORMAL
  2199 00:0F9C: 03 4B 45 59                  db      3,"KEY"
  2200                                        extern  UartRx
  2201                        KEY:
  2202 00:0FA0: 20 xx xx                     jsr     UartRx                  ; Receive a character
  2203 00:0FA3: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  2204 00:0FA6: AA                           tax
  2205 00:0FA7: 7B                           tdc
  2206 00:0FA8: 3A                           dec     a                       ; And push to stack
  2207 00:0FA9: 3A                           dec     a
  2208 00:0FAA: 5B                           tcd
  2209 00:0FAB: 86 01                        stx     <1
  2210 00:0FAD: 4C E6 0D                     jmp     NEXT                    ; Done
  2211                        
  2212                        ; SPACE ( -- )
  Wed Mar  9 2016 20:10                                                                                                    Page 44


  2213                        ;
  2214                        ; Display one space.
  2215                        ;
  2216                        ; In this implementation it is defined as
  2217                        ;
  2218                        ;   BL EMIT
  2219                        
  2220 00:0FB0: 99 0F 00                     HEADER  NORMAL
  2221 00:0FB3: 05 53 50 41                  db      5,"SPACE"
       00:0FB7: 43 45 
  2222 00:0FB9: 20 E2 0D     SPACE:          jsr     DO_COLON
  2223 00:0FBC: 10 05                        dw      BL
  2224 00:0FBE: 8D 0F                        dw      EMIT
  2225 00:0FC0: E2 0A                        dw      EXIT
  2226                        
  2227                        ; SPACES ( n -- )
  2228                        ;
  2229                        ; If n is greater than zero, display n spaces.
  2230                        ;
  2231                        ; In this implementation it is defined as
  2232                        ;
  2233                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  2234                        
  2235 00:0FC2: B0 0F 00                     HEADER  NORMAL
  2236 00:0FC5: 06 53 50 41                  db      6,"SPACES"
       00:0FC9: 43 45 53 
  2237 00:0FCC: 20 E2 0D     SPACES:         jsr     DO_COLON
  2238 00:0FCF: 2F 07 A3 09  SPACES_1:       dw      DUP,ZERO_GREATER,QUERY_BRANCH,SPACES_2
       00:0FD3: 7B 0E DF 0F 
  2239 00:0FD7: B9 0F 68 08                  dw      SPACE,ONE_MINUS,BRANCH,SPACES_1
       00:0FDB: 69 0E CF 0F 
  2240 00:0FDF: 21 07 E2 0A  SPACES_2:       dw      DROP,EXIT
  2241                        
  2242                        ; TYPE ( c-addr u -- )
  2243                        ;
  2244                        ; If u is greater than zero, display the character string specified by c-addr
  2245                        ; and u.
  2246                        ;
  2247                        ; In this implementation it is defined as
  2248                        ;
  2249                        ;   ?DUP IF
  2250                        ;     OVER + SWAP DO I C@ EMIT LOOP
  2251                        ;   ELSE DROP THEN
  2252                        
  2253 00:0FE3: C2 0F 00                     HEADER  NORMAL
  2254 00:0FE6: 04 54 59 50                  db      4,"TYPE"
       00:0FEA: 45 
  2255 00:0FEB: 20 E2 0D     TYPE:           jsr     DO_COLON
  2256 00:0FEE: 12 07 7B 0E                  dw      QUERY_DUP,QUERY_BRANCH,TYPE_2
       00:0FF2: 0A 10 
  2257 00:0FF4: 4F 07 36 08                  dw      OVER,PLUS,SWAP,DO_DO
       00:0FF8: 62 07 4D 0E 
  2258 00:0FFC: ED 07 27 06  TYPE_1:         dw      I,C_FETCH,EMIT,DO_LOOP,TYPE_1
       00:1000: 8D 0F D3 0E 
       00:1004: FC 0F 
  2259 00:1006: 69 0E 0C 10                  dw      BRANCH,TYPE_3
  2260 00:100A: 21 07        TYPE_2          dw      DROP
  2261 00:100C: E2 0A        TYPE_3          dw      EXIT
  Wed Mar  9 2016 20:10                                                                                                    Page 45


  2262                        
  2263                        ;================================================================================
  2264                        ;--------------------------------------------------------------------------------
  2265                        
  2266                        ; #
  2267                        ; #>
  2268                        ; #S
  2269                        ; SIGN
  2270                        
  2271                        ;================================================================================
  2272                        ;--------------------------------------------------------------------------------
  2273                        
  2274                                        TRAILER
  2275                        NEXT_WORD:
  2276                        
  2277                                        end


      Lines assembled: 2941
      Errors: 2
