  Wed Mar 16 2016 22:39                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The Forth data stack is DP
    27                        ;
    28                        ; The Y register holds the forth instruction pointer and the direct page
    29                        ; register is used to access the word address pointer and user variables.
    30                        ;
    31                        ; Some of the high-level definitions are based on Bradford J. Rodriguez's
    32                        ; CamelForth implementations.
    33                        ;
    34                        ;==============================================================================
    35                        ;------------------------------------------------------------------------------
    36                        
    37                                        pw      132
    38                                        inclist on
    39                                        maclist off
    40                        
    41                                        chip    65816
    42                                        longi   off
    43                                        longa   off
    44                        
    45                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
     7                        ;
  Wed Mar 16 2016 22:39                                                                                                    Page 2


     8                        ; Western Design Center W65C816 device definitions                                          
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;===============================================================================
    25                        ; Revision History:
    26                        ;
    27                        ; 2015-12-18 AJ Initial version
    28                        ;-------------------------------------------------------------------------------
    29                        ; $Id$
    30                        ;-------------------------------------------------------------------------------
    31                        
    32                        ;==============================================================================
    33                        ; Status Register Bits
    34                        ;------------------------------------------------------------------------------
    35                        
    36             00000080   N_FLAG          equ     1<<7
    37             00000040   V_FLAG          equ     1<<6
    38             00000020   M_FLAG          equ     1<<5
    39             00000010   X_FLAG          equ     1<<4
    40             00000010   B_FLAG          equ     1<<4
    41             00000008   D_FLAG          equ     1<<3
    42             00000004   I_FLAG          equ     1<<2
    43             00000002   Z_FLAG          equ     1<<1
    44             00000001   C_FLAG          equ     1<<0
    45                        
    46                        ;==============================================================================
    47                        ; Macros
    48                        ;------------------------------------------------------------------------------
    49                        
    50                        ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
    51                        ; is fixed at $0100-$01ff. 
    52                        
    53                        emulate         macro
    54                                        sec
    55                                        xce
    56                                        endm
    57                        
    58                        ; Puts the processor in native mode. The size of the memory and index register
    59                        ; operations is not controlled by the M & X bits in the status register.
    60                        
    61                        native          macro
    62                                        clc
    63                                        xce
    64                                        endm
    65                        
  Wed Mar 16 2016 22:39                                                                                                    Page 3


    66                        ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
    67                         
    68                        long_a          macro
    69                                        rep     #M_FLAG
    70                                        longa   on
    71                                        endm
    72                        
    73                        ; Resets the X bit making the index registers 16-bits wide
    74                        
    75                        long_i          macro
    76                                        rep     #X_FLAG
    77                                        longi   on
    78                                        endm
    79                        
    80                        ; Resets the M and X bits making the accumulator, memory accesses and index
    81                        ; registers 16-bits wide.
    82                                        
    83                        long_ai         macro
    84                                        rep     #M_FLAG|X_FLAG
    85                                        longa   on
    86                                        longi   on
    87                                        endm
    88                        
    89                        ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
    90                        
    91                        short_a         macro
    92                                        sep     #M_FLAG
    93                                        longa   off
    94                                        endm
    95                        
    96                        ; Sets the X bit making the index registers 8-bits wide.
    97                        
    98                        short_i         macro
    99                                        sep     #X_FLAG
   100                                        longi   off
   101                                        endm
   102                                        
   103                        ; Sets the M & X bits making the accumulator, memory accesses and index
   104                        ; registers 8-bits wide.
   105                        
   106                        short_ai        macro
   107                                        sep     #M_FLAG|X_FLAG
   108                                        longa   off
   109                                        longi   off
   110                                        endm
    46                        
    47                        ;==============================================================================
    48                        ; Macros
    49                        ;------------------------------------------------------------------------------
    50                        
    51                        ; The LINK macro deposits the link section of a word header automatically
    52                        ; linking the new word to the last.
    53                        
    54             00000000   WORDZ           set     0                       ; Word counter
    55             00000000   WORD0           equ     0                       ; Null address for first word
    56                        
    57                        LINK            macro   TYPE
    58                                        dw      WORD@<WORDZ>            ; Link
  Wed Mar 16 2016 22:39                                                                                                    Page 4


    59                                        db      TYPE                    ; Type
    60                        WORDZ           set     WORDZ+1
    61                        WORD@<WORDZ>:
    62                                        endm
    63                        
    64                        ; Deposits a word header containing the name which is linked back to the
    65                        ; previous word.
    66                        ;
    67                        ; The WDC assembler does not handle string parameters to macros very well,
    68                        ; stopping at the first comma or space in them, so some headers must be
    69                        ; manually constructed.
    70                        
    71             00000000   NORMAL          equ     $00
    72             00000080   IMMEDIATE       equ     $80
    73                        
    74                        HEADER          macro   LEN,NAME,TYPE
    75                                        LINK    TYPE
    76                                        db      LEN,NAME
    77                                        endm
    78                        
    79                        ; The CONTINUE macro is used at the end of a native word to invoke the next
    80                        ; word pointer.
    81                        
    82                        CONTINUE        macro
    83                                        tyx                             ; Copy IP to X
    84                                        iny
    85                                        iny
    86                                        jmp     (0,x)                   ; Then execute word
    87                                        endm
    88                        
    89                        TRAILER         macro
    90                        LAST_WORD       equ     WORD@<WORDZ>
    91                                        endm
    92                        
    93                        ;==============================================================================
    94                        ; Definitions
    95                        ;------------------------------------------------------------------------------
    96                        
    97             00000014   USER_SIZE       equ     20
    98             00000080   DSTACK_SIZE     equ     128
    99             00000080   RSTACK_SIZE     equ     128
   100                        
   101             00000000   TO_IN_OFFSET    equ     0
   102             00000002   BASE_OFFSET     equ     2
   103             00000004   BLK_OFFSET      equ     4
   104             00000006   DP_OFFSET       equ     6
   105             00000008   LATEST_OFFSET   equ     8
   106             0000000A   SCR_OFFSET      equ     10
   107             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
   108             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
   109             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
   110             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
   111                        
   112             00000080   TIB_SIZE        equ     128
   113                        
   114                        ;==============================================================================
   115                        ; Data Areas
   116                        ;------------------------------------------------------------------------------
  Wed Mar 16 2016 22:39                                                                                                    Page 5


   117                        
   118                                        page0
   119                                        org     $00
   120                        
   121 00:0000:              USER_AREA       ds      USER_SIZE               ; User Variables
   122                        
   123                        
   124             00000100   DSTACK_START    equ     $0100
   125             00000180   DSTACK_END      equ     DSTACK_START+DSTACK_SIZE
   126                        
   127             00000180   RSTACK_START    equ     $0180
   128             00000200   RSTACK_END      equ     RSTACK_START+RSTACK_SIZE
   129                        
   130                        
   131                                        data
   132                                        org     $0200
   133                        
   134 00:0200:              TIB_AREA        ds      TIB_SIZE                ; Terminal Input Buffer
   135                        
   136                        ;==============================================================================
   137                        ; Forth Entry Point
   138                        ;------------------------------------------------------------------------------
   139                        
   140                        FORTH           section OFFSET $0400
   141                        
   142                                        public  Start
   143                        Start:
   144 00:0400: 18 FB                        native                          ; Go to native mode
   145 00:0402: C2 30                        long_ai                         ; And all 16-bit registers
   146 00:0404: A9 FF 01                     lda     #RSTACK_END-1           ; Initialise return stack
   147 00:0407: 1B                           tcs
   148 00:0408: A9 7F 01                     lda     #DSTACK_END-1           ; .. and data stack
   149 00:040B: 5B                           tcd
   150                        
   151 00:040C: A0 15 04                     ldy     #COLD                   ; Then perform COLD start
   152 00:040F: BB C8 C8 7C                  CONTINUE
       00:0413: 00 00 
   153                        
   154                        COLD:
   155 00:0415: 6B 05                        dw      DECIMAL
   156 00:0417: 14 05                        dw      ZERO
   157 00:0419: 94 04                        dw      BLK
   158 00:041B: 91 05                        dw      STORE
   159 00:041D: 3E 05                        dw      FALSE
   160 00:041F: FE 04                        dw      STATE
   161 00:0421: 91 05                        dw      STORE
   162 00:0423: A5 12                        dw      DO_LITERAL
   163 00:0425: 14 14                        dw      NEXT_WORD
   164 00:0427: B0 04                        dw      DP
   165 00:0429: 91 05                        dw      STORE
   166 00:042B: A5 12                        dw      DO_LITERAL
   167 00:042D: EC 13                        dw      LAST_WORD
   168 00:042F: BF 04                        dw      LATEST
   169 00:0431: 91 05                        dw      STORE
   170 00:0433: 74 13                        dw      CR
   171 00:0435: 74 13                        dw      CR
   172 00:0437: 4F 13                        dw      DO_S_QUOTE
   173 00:0439: 23 48 61 6E                  db      35,"HandCoded W65C816 ANS-Forth [16.03]"
  Wed Mar 16 2016 22:39                                                                                                    Page 6


       00:043D: 64 43 6F 64 
       00:0441: 65 64 20 57 
       00:0445: 36 35 43 38 
       00:0449: 31 36 20 41 
       00:044D: 4E 53 2D 46 
       00:0451: 6F 72 74 68 
       00:0455: 20 5B 31 36 
       00:0459: 2E 30 33 5D 
   174 00:045D: F1 13                        dw      TYPE
   175 00:045F: 74 13                        dw      CR
   176 00:0461: 74 13                        dw      CR
   177 00:0463: 43 0C                        dw      ABORT
   178                        
   179                        ;==============================================================================
   180                        ; System/User Variables
   181                        ;------------------------------------------------------------------------------
   182                        
   183                        ; #TIB ( -- a-addr )
   184                        ;
   185                        ; a-addr is the address of a cell containing the number of characters in the
   186                        ; terminal input buffer.
   187                        
   188 00:0465: 00 00 00 04                  HEADER  4,"#TIB",NORMAL
       00:0469: 23 54 49 42 
   189 00:046D: 20 FE 11     HASH_TIB:       jsr     DO_CONSTANT
   190 00:0470: 72 04                        dw      $+2
   191 00:0472: 7E 00                        dw      TIB_SIZE-2
   192                        
   193                        ; >IN ( -- a-addr )
   194                        ;
   195                        ; a-addr is the address of a cell containing the offset in characters from the
   196                        ; start of the input buffer to the start of the parse area.
   197                        
   198 00:0474: 68 04 00 03                  HEADER  3,">IN",NORMAL
       00:0478: 3E 49 4E 
   199 00:047B: 20 01 13     TO_IN:          jsr     DO_USER
   200 00:047E: 00 00                        dw      TO_IN_OFFSET
   201                        
   202                        ; BASE ( -- a-addr )
   203                        ;
   204                        ; a-addr is the address of a cell containing the current number-conversion
   205                        ; radix {{2...36}}.
   206                        
   207 00:0480: 77 04 00 04                  HEADER  4,"BASE",NORMAL
       00:0484: 42 41 53 45 
   208 00:0488: 20 01 13     BASE:           jsr     DO_USER
   209 00:048B: 02 00                        dw      BASE_OFFSET
   210                        
   211                        ; BLK ( -- a-addr )
   212                        ;
   213                        ; a-addr is the address of a cell containing zero or the number of the mass-
   214                        ; storage block being interpreted. If BLK contains zero, the input source is
   215                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   216                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   217                        
   218 00:048D: 83 04 00 03                  HEADER  3,"BLK",NORMAL
       00:0491: 42 4C 4B 
   219 00:0494: 20 01 13     BLK:            jsr     DO_USER
  Wed Mar 16 2016 22:39                                                                                                    Page 7


   220 00:0497: 04 00                        dw      BLK_OFFSET
   221                        
   222                        ; (BUFFER)
   223                        
   224 00:0499: 90 04 00 08                  HEADER  8,"(BUFFER)",NORMAL
       00:049D: 28 42 55 46 
       00:04A1: 46 45 52 29 
   225 00:04A5: 20 01 13     BUFFER:         jsr     DO_USER
   226 00:04A8: 10 00                        dw      BUFFER_OFFSET
   227                        
   228                        ; DP ( -- a-addr )
   229                        ;
   230                        ; Dictionary Pointer
   231                        
   232 00:04AA: 9C 04 00 02                  HEADER  2,"DP",NORMAL
       00:04AE: 44 50 
   233 00:04B0: 20 01 13     DP:             jsr     DO_USER
   234 00:04B3: 06 00                        dw      DP_OFFSET
   235                        
   236                        ; LATEST ( -- a-addr )
   237                        
   238 00:04B5: AD 04 00 06                  HEADER  6,"LATEST",NORMAL
       00:04B9: 4C 41 54 45 
       00:04BD: 53 54 
   239 00:04BF: 20 01 13     LATEST:         jsr     DO_USER
   240 00:04C2: 08 00                        dw      LATEST_OFFSET
   241                        
   242                        ; (LENGTH)
   243                        
   244 00:04C4: B8 04 00 08                  HEADER  8,"(LENGTH)",NORMAL
       00:04C8: 28 4C 45 4E 
       00:04CC: 47 54 48 29 
   245 00:04D0: 20 01 13     LENGTH:         jsr     DO_USER
   246 00:04D3: 12 00                        dw      LENGTH_OFFSET
   247                        
   248                        ; SCR ( -- a-addr )
   249                        ;
   250                        ; a-addr is the address of a cell containing the block number of the block most
   251                        ; recently LISTed.
   252                        
   253 00:04D5: C7 04 00 03                  HEADER  3,"SCR",NORMAL
       00:04D9: 53 43 52 
   254 00:04DC: 20 01 13     SCR:            jsr     DO_USER
   255 00:04DF: 0A 00                        dw      SCR_OFFSET
   256                        
   257                        ; (SOURCE-ID)
   258                        
   259 00:04E1: D8 04 00 0B                  HEADER  11,"(SOURCE-ID)",NORMAL
       00:04E5: 28 53 4F 55 
       00:04E9: 52 43 45 2D 
       00:04ED: 49 44 29 
   260 00:04F0: 20 01 13     SOURCEID:       jsr     DO_USER
   261 00:04F3: 0C 00                        dw      SOURCEID_OFFSET
   262                        
   263                        ; STATE ( -- a-addr )
   264                        ;
   265                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   266                        ; is true when in compilation state, false otherwise. The true value in STATE
  Wed Mar 16 2016 22:39                                                                                                    Page 8


   267                        ; is non-zero, but is otherwise implementation-defined.
   268                        
   269 00:04F5: E4 04 00 05                  HEADER  5,"STATE",NORMAL
       00:04F9: 53 54 41 54 
       00:04FD: 45 
   270 00:04FE: 20 01 13     STATE:          jsr     DO_USER
   271 00:0501: 0E 00                        dw      STATE_OFFSET
   272                        
   273                        ; TIB ( -- c-addr )
   274                        ;
   275                        ; c-addr is the address of the terminal input buffer.
   276                        
   277 00:0503: F8 04 00 03                  HEADER  3,"TIB",NORMAL
       00:0507: 54 49 42 
   278 00:050A: 20 FE 11     TIB:            jsr     DO_CONSTANT
   279 00:050D: 00 02                        dw      TIB_AREA
   280                        
   281                        ;==============================================================================
   282                        ; Constants
   283                        ;------------------------------------------------------------------------------
   284                        
   285                        ; 0 ( -- 0 )
   286                        ;
   287                        ; Push the constant value zero on the stack
   288                        
   289 00:050F: 06 05 00 01                  HEADER  1,"0",NORMAL
       00:0513: 30 
   290                        ZERO:
   291 00:0514: 7B                           tdc
   292 00:0515: 3A                           dec     a                       ; Make space on the stack
   293 00:0516: 3A                           dec     a
   294 00:0517: 5B                           tcd
   295 00:0518: 64 01                        stz     <1                      ; And create a zero value
   296 00:051A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:051E: 00 00 
   297                        
   298                        ; BL ( -- char )
   299                        ;
   300                        ; char is the character value for a space.
   301                        
   302 00:0520: 12 05 00 02                  HEADER  2,"BL",NORMAL
       00:0524: 42 4C 
   303                        BL:
   304 00:0526: 7B                           tdc
   305 00:0527: 3A                           dec     a                       ; Make space on the stack
   306 00:0528: 3A                           dec     a
   307 00:0529: 5B                           tcd
   308 00:052A: A9 20 00                     lda     #' '                    ; And save a space value
   309 00:052D: 85 01                        sta     <1
   310 00:052F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0533: 00 00 
   311                        
   312                        ; FALSE ( -- false )
   313                        ;
   314                        ; Return a false flag.
   315                        
   316 00:0535: 23 05 00 05                  HEADER  5,"FALSE",NORMAL
       00:0539: 46 41 4C 53 
  Wed Mar 16 2016 22:39                                                                                                    Page 9


       00:053D: 45 
   317                        FALSE:
   318 00:053E: 7B                           tdc
   319 00:053F: 3A                           dec     a                       ; Make space on the stack
   320 00:0540: 3A                           dec     a
   321 00:0541: 5B                           tcd
   322 00:0542: 64 01                        stz     <1                      ; And create a false value
   323 00:0544: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0548: 00 00 
   324                        
   325                        ; TRUE ( -- true )
   326                        ;
   327                        ; Return a true flag, a single-cell value with all bits set.
   328                        
   329 00:054A: 38 05 00 04                  HEADER  4,"TRUE",NORMAL
       00:054E: 54 52 55 45 
   330                        TRUE:
   331 00:0552: 7B                           tdc
   332 00:0553: 3A                           dec     a                       ; Make space on the stack
   333 00:0554: 3A                           dec     a
   334 00:0555: 5B                           tcd
   335 00:0556: 64 01                        stz     <1                      ; And create a true value
   336 00:0558: C6 01                        dec     <1
   337 00:055A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:055E: 00 00 
   338                        
   339                        ;==============================================================================
   340                        ; Radix
   341                        ;------------------------------------------------------------------------------
   342                        
   343                        ; DECIMAL ( -- )
   344                        ;
   345                        ; Set the numeric conversion radix to ten (decimal).
   346                        
   347 00:0560: 4D 05 00 07                  HEADER  7,"DECIMAL",NORMAL
       00:0564: 44 45 43 49 
       00:0568: 4D 41 4C 
   348 00:056B: 20 AF 11     DECIMAL:        jsr     DO_COLON
   349 00:056E: A5 12 0A 00                  dw      DO_LITERAL,10
   350 00:0572: 88 04                        dw      BASE
   351 00:0574: 91 05                        dw      STORE
   352 00:0576: A7 0C                        dw      EXIT
   353                        
   354                        ; HEX ( -- )
   355                        ;
   356                        ; Set contents of BASE to sixteen.
   357                        
   358 00:0578: 63 05 00 03                  HEADER  3,"HEX",NORMAL
       00:057C: 48 45 58 
   359 00:057F: 20 AF 11     HEX:            jsr     DO_COLON
   360 00:0582: A5 12 10 00                  dw      DO_LITERAL,16
   361 00:0586: 88 04                        dw      BASE
   362 00:0588: 91 05                        dw      STORE
   363 00:058A: A7 0C                        dw      EXIT
   364                        
   365                        ;==============================================================================
   366                        ; Memory Operations
   367                        ;------------------------------------------------------------------------------
  Wed Mar 16 2016 22:39                                                                                                    Page 10


   368                        
   369                        ; ! ( x a-addr -- )
   370                        ;
   371                        ; Store x at a-addr.
   372                        
   373 00:058C: 7B 05 00 01                  HEADER  1,"!",NORMAL
       00:0590: 21 
   374                        STORE:
   375 00:0591: A5 03                        lda     <3                      ; Fetch data value
   376 00:0593: 92 01                        sta     (1)                     ; .. and store
   377 00:0595: 7B                           tdc                             ; Clean up data stack
   378 00:0596: 1A                           inc     a
   379 00:0597: 1A                           inc     a
   380 00:0598: 1A                           inc     a
   381 00:0599: 1A                           inc     a
   382 00:059A: 5B                           tcd
   383 00:059B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:059F: 00 00 
   384                        
   385                        ; +! ( n|u a-addr -- )
   386                        ;
   387                        ; Add n|u to the single-cell number at a-addr.
   388                        
   389 00:05A1: 8F 05 00 02                  HEADER  2,"+!",NORMAL
       00:05A5: 2B 21 
   390                        PLUS_STORE:
   391 00:05A7: 18                           clc
   392 00:05A8: A5 03                        lda     <3                      ; Fetch data value
   393 00:05AA: 72 01                        adc     (1)
   394 00:05AC: 92 01                        sta     (1)
   395 00:05AE: 7B                           tdc                             ; Clean up data stack
   396 00:05AF: 1A                           inc     a
   397 00:05B0: 1A                           inc     a
   398 00:05B1: 1A                           inc     a
   399 00:05B2: 1A                           inc     a
   400 00:05B3: 5B                           tcd
   401 00:05B4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05B8: 00 00 
   402                        
   403                        ; , ( x -- )
   404                        ;
   405                        ; Reserve one cell of data space and store x in the cell. If the data-space
   406                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   407                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   408                        ; is not aligned prior to execution of ,.
   409                        ;
   410                        ;   HERE ! 1 CELLS ALLOT
   411                        
   412 00:05BA: A4 05 00                     LINK    NORMAL
   413 00:05BD: 01 2C                        db      1,","
   414 00:05BF: 20 AF 11     COMMA:          jsr     DO_COLON
   415 00:05C2: 6A 06                        dw      HERE
   416 00:05C4: 91 05                        dw      STORE
   417 00:05C6: A5 12 01 00                  dw      DO_LITERAL,1
   418 00:05CA: AF 06                        dw      CELLS
   419 00:05CC: 12 06                        dw      ALLOT
   420 00:05CE: A7 0C                        dw      EXIT
   421                        
  Wed Mar 16 2016 22:39                                                                                                    Page 11


   422                        ; 2! ( x1 x2 a-addr -- )
   423                        ;
   424                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   425                        ; consecutive cell. It is equivalent to the sequence SWAP OVER ! CELL+ !.
   426                        
   427 00:05D0: BD 05 00 02                  HEADER  2,"2!",NORMAL
       00:05D4: 32 21 
   428 00:05D6: 20 AF 11     TWO_STORE:      jsr     DO_COLON
   429 00:05D9: BD 07                        dw      SWAP
   430 00:05DB: A7 07                        dw      OVER
   431 00:05DD: 91 05                        dw      STORE
   432 00:05DF: 9C 06                        dw      CELL_PLUS
   433 00:05E1: 91 05                        dw      STORE
   434 00:05E3: A7 0C                        dw      EXIT
   435                        
   436                        ; 2@ ( a-addr -- x1 x2 )
   437                        ;
   438                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   439                        ; the next consecutive cell. It is equivalent to the sequence DUP CELL+ @ SWAP
   440                        ; @.
   441                        
   442 00:05E5: D3 05 00 02                  HEADER  2,"2@",NORMAL
       00:05E9: 32 40 
   443 00:05EB: 20 AF 11     TWO_FETCH:      jsr     DO_COLON
   444 00:05EE: 84 07                        dw      DUP
   445 00:05F0: 9C 06                        dw      CELL_PLUS
   446 00:05F2: FF 05                        dw      FETCH
   447 00:05F4: BD 07                        dw      SWAP
   448 00:05F6: FF 05                        dw      FETCH
   449 00:05F8: A7 0C                        dw      EXIT
   450                        
   451                        ; @ ( a-addr -- x )
   452                        ;
   453                        ; x is the value stored at a-addr.
   454                        
   455 00:05FA: E8 05 00 01                  HEADER  1,"@",NORMAL
       00:05FE: 40 
   456                        FETCH:
   457 00:05FF: B2 01                        lda     (1)                     ; Fetch from memory
   458 00:0601: 85 01                        sta     <1                      ; .. and replace top value
   459 00:0603: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0607: 00 00 
   460                        
   461                        ; ALLOT ( n -- )
   462                        ;
   463                        ; If n is greater than zero, reserve n address units of data space. If n is
   464                        ; less than zero, release |n| address units of data space. If n is zero, leave
   465                        ; the data-space pointer unchanged.
   466                        ;
   467                        ; In this implementation its is defined as:
   468                        ;
   469                        ;   DP +!
   470                        
   471 00:0609: FD 05 00 05                  HEADER  5,"ALLOT",NORMAL
       00:060D: 41 4C 4C 4F 
       00:0611: 54 
   472 00:0612: 20 AF 11     ALLOT:          jsr     DO_COLON
   473 00:0615: B0 04                        dw      DP
  Wed Mar 16 2016 22:39                                                                                                    Page 12


   474 00:0617: A7 05                        dw      PLUS_STORE
   475 00:0619: A7 0C                        dw      EXIT
   476                        
   477                        ; C! ( char c-addr -- )
   478                        ;
   479                        ; Store char at c-addr. When character size is smaller than cell size, only the
   480                        ; number of low-order bits corresponding to character size are transferred.
   481                        
   482 00:061B: 0C 06 00 02                  HEADER  2,"C!",NORMAL
       00:061F: 43 21 
   483                        C_STORE:
   484 00:0621: A5 03                        lda     <3                      ; Fetch the data value
   485 00:0623: E2 20                        short_a
   486 00:0625: 92 01                        sta     (1)                     ; And store it
   487 00:0627: C2 20                        long_a
   488 00:0629: 7B                           tdc                             ; Clean up the stack
   489 00:062A: 1A                           inc     a
   490 00:062B: 1A                           inc     a
   491 00:062C: 1A                           inc     a
   492 00:062D: 1A                           inc     a
   493 00:062E: 5B                           tcd
   494 00:062F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0633: 00 00 
   495                        
   496                        ; C, ( char -- )
   497                        ;
   498                        ; Reserve space for one character in the data space and store char in the
   499                        ; space. If the data-space pointer is character aligned when C, begins
   500                        ; execution, it will remain character aligned when C, finishes execution.
   501                        ; An ambiguous condition exists if the data-space pointer is not character-
   502                        ; aligned prior to execution of C,
   503                        ;
   504                        ;   HERE C! 1 CHARS ALLOT
   505                        
   506 00:0635: 1E 06 00                     LINK    NORMAL
   507 00:0638: 02 43 2C                     db      2,"C,"
   508 00:063B: 20 AF 11     C_COMMA:        jsr     DO_COLON
   509 00:063E: 6A 06                        dw      HERE
   510 00:0640: 21 06                        dw      C_STORE
   511 00:0642: A5 12 01 00                  dw      DO_LITERAL,1
   512 00:0646: E2 06                        dw      CHARS
   513 00:0648: 12 06                        dw      ALLOT
   514 00:064A: A7 0C                        dw      EXIT
   515                        
   516                        ; C@ ( c-addr -- char )
   517                        ;
   518                        ; Fetch the character stored at c-addr. When the cell size is greater than
   519                        ; character size, the unused high-order bits are all zeroes.
   520                        
   521 00:064C: 38 06 00 02                  HEADER  2,"C@",NORMAL
       00:0650: 43 40 
   522                        C_FETCH:
   523 00:0652: E2 20                        short_a
   524 00:0654: B2 01                        lda     (1)                     ; Fetch the data byte
   525 00:0656: 85 01                        sta     <1                      ; .. and replace stack value
   526 00:0658: 64 02                        stz     <2
   527 00:065A: C2 20                        long_a
   528 00:065C: BB C8 C8 7C                  CONTINUE                        ; Done
  Wed Mar 16 2016 22:39                                                                                                    Page 13


       00:0660: 00 00 
   529                        
   530                        ; HERE ( -- addr )
   531                        ;
   532                        ; addr is the data-space pointer.
   533                        
   534 00:0662: 4F 06 00 04                  HEADER  4,"HERE",NORMAL
       00:0666: 48 45 52 45 
   535 00:066A: 20 AF 11     HERE:           jsr     DO_COLON
   536 00:066D: B0 04                        dw      DP
   537 00:066F: FF 05                        dw      FETCH
   538 00:0671: A7 0C                        dw      EXIT
   539                        
   540                        ;==============================================================================
   541                        ; Alignment
   542                        ;------------------------------------------------------------------------------
   543                        
   544                        ; ALIGN ( -- )
   545                        ;
   546                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   547                        
   548 00:0673: 65 06 00 05                  HEADER  5,"ALIGN",NORMAL
       00:0677: 41 4C 49 47 
       00:067B: 4E 
   549                        ALIGN:
   550 00:067C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0680: 00 00 
   551                        
   552                        ; ALIGNED ( addr -- a-addr )
   553                        ;
   554                        ; a-addr is the first aligned address greater than or equal to addr.
   555                        
   556 00:0682: 76 06 00 07                  HEADER  7,"ALIGNED",NORMAL
       00:0686: 41 4C 49 47 
       00:068A: 4E 45 44 
   557                        ALIGNED:
   558 00:068D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0691: 00 00 
   559                        
   560                        ; CELL+ ( a-addr1 -- a-addr2 )
   561                        ;
   562                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   563                        
   564 00:0693: 85 06 00 05                  HEADER  5,"CELL+",NORMAL
       00:0697: 43 45 4C 4C 
       00:069B: 2B 
   565                        CELL_PLUS:
   566 00:069C: E6 01                        inc     <1                      ; Bump the address by two
   567 00:069E: E6 01                        inc     <1
   568 00:06A0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06A4: 00 00 
   569                        
   570                        ; CELLS ( n1 -- n2 )
   571                        ;
   572                        ; n2 is the size in address units of n1 cells.
   573                        
   574 00:06A6: 96 06 00 05                  HEADER  5,"CELLS",NORMAL
       00:06AA: 43 45 4C 4C 
  Wed Mar 16 2016 22:39                                                                                                    Page 14


       00:06AE: 53 
   575                        CELLS:
   576 00:06AF: 06 01                        asl     <1                      ; Two bytes per cell
   577 00:06B1: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06B5: 00 00 
   578                        
   579                        ; CHAR+ ( c-addr1 -- c-addr2 )
   580                        ;
   581                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
   582                        
   583 00:06B7: A9 06 00 05                  HEADER  5,"CHAR+",NORMAL
       00:06BB: 43 48 41 52 
       00:06BF: 2B 
   584                        CHAR_PLUS:
   585 00:06C0: E6 01                        inc     <1                      ; Bump the address by one
   586 00:06C2: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06C6: 00 00 
   587                        
   588                        ; CHAR- ( c-addr1 -- c-addr2 )
   589                        ;
   590                        ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
   591                        
   592 00:06C8: BA 06 00 05                  HEADER  5,"CHAR-",NORMAL
       00:06CC: 43 48 41 52 
       00:06D0: 2D 
   593                        CHAR_MINUS:
   594 00:06D1: C6 01                        dec     <1
   595 00:06D3: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06D7: 00 00 
   596                        
   597                        ; CHARS ( n1 -- n2 )
   598                        ;
   599                        ; n2 is the size in address units of n1 characters.
   600                        
   601 00:06D9: CB 06 00 05                  HEADER  5,"CHARS",NORMAL
       00:06DD: 43 48 41 52 
       00:06E1: 53 
   602                        CHARS:
   603 00:06E2: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06E6: 00 00 
   604                        
   605                        ;==============================================================================
   606                        ; Stack Operations
   607                        ;------------------------------------------------------------------------------
   608                        
   609                        ; 2DROP ( x1 x2 -- )
   610                        ;
   611                        ; Drop cell pair x1 x2 from the stack.
   612                        
   613 00:06E8: DC 06 00 05                  HEADER  5,"2DROP",NORMAL
       00:06EC: 32 44 52 4F 
       00:06F0: 50 
   614                        TWO_DROP:
   615 00:06F1: 7B                           tdc                             ; Removed two words from stack
   616 00:06F2: 1A                           inc     a
   617 00:06F3: 1A                           inc     a
   618 00:06F4: 1A                           inc     a
   619 00:06F5: 1A                           inc     a
  Wed Mar 16 2016 22:39                                                                                                    Page 15


   620 00:06F6: 5B                           tcd
   621 00:06F7: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06FB: 00 00 
   622                        
   623                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   624                        ;
   625                        ; Duplicate cell pair x1 x2.
   626                        
   627 00:06FD: EB 06 00 04                  HEADER  4,"2DUP",NORMAL
       00:0701: 32 44 55 50 
   628                        TWO_DUP:
   629 00:0705: 7B                           tdc                             ; Make space for new value
   630 00:0706: 3A                           dec     a
   631 00:0707: 3A                           dec     a
   632 00:0708: 3A                           dec     a
   633 00:0709: 3A                           dec     a
   634 00:070A: 5B                           tcd
   635 00:070B: A5 05                        lda     <5                      ; Copy top two values
   636 00:070D: 85 01                        sta     <1
   637 00:070F: A5 07                        lda     <7
   638 00:0711: 85 03                        sta     <3
   639 00:0713: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0717: 00 00 
   640                        
   641                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   642                        ;
   643                        ; Copy cell pair x1 x2 to the top of the stack.
   644                        
   645 00:0719: 00 07 00 05                  HEADER  5,"2OVER",NORMAL
       00:071D: 32 4F 56 45 
       00:0721: 52 
   646                        TWO_OVER:
   647 00:0722: 7B                           tdc                             ; Make space for new value
   648 00:0723: 3A                           dec     a
   649 00:0724: 3A                           dec     a
   650 00:0725: 3A                           dec     a
   651 00:0726: 3A                           dec     a
   652 00:0727: 5B                           tcd
   653 00:0728: A5 09                        lda     <9                      ; Ciopy top two values
   654 00:072A: 85 01                        sta     <1
   655 00:072C: A5 0B                        lda     <11
   656 00:072E: 85 03                        sta     <3
   657 00:0730: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0734: 00 00 
   658                        
   659                        ; 2ROT
   660                        
   661                        ; TODO
   662                        
   663                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   664                        ;
   665                        ; Exchange the top two cell pairs.
   666                        
   667 00:0736: 1C 07 00 05                  HEADER  5,"2SWAP",NORMAL
       00:073A: 32 53 57 41 
       00:073E: 50 
   668                        TWO_SWAP:
   669 00:073F: A5 03                        lda     <3                      ; Save x3
  Wed Mar 16 2016 22:39                                                                                                    Page 16


   670 00:0741: 48                           pha
   671 00:0742: A5 01                        lda     <1                      ; Save x4
   672 00:0744: 48                           pha
   673 00:0745: A5 07                        lda     <7                      ; Move x1
   674 00:0747: 85 03                        sta     <3
   675 00:0749: A5 05                        lda     <5                      ; Move x2
   676 00:074B: 85 01                        sta     <1
   677 00:074D: 68                           pla                             ; Move x4
   678 00:074E: 85 05                        sta     <5
   679 00:0750: 68                           pla                             ; Move x3
   680 00:0751: 85 07                        sta     <7
   681 00:0753: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0757: 00 00 
   682                        
   683                        ; ?DUP ( x -- 0 | x x )
   684                        ;
   685                        ; Duplicate x if it is non-zero.
   686                        
   687 00:0759: 39 07 00 04                  HEADER  4,"?DUP",NORMAL
       00:075D: 3F 44 55 50 
   688                        QUERY_DUP:
   689 00:0761: A5 01                        lda     <1                      ; Fetch top value
   690 00:0763: D0 1F                        bne     DUP                     ; Non-zero value?
   691 00:0765: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0769: 00 00 
   692                        
   693                        ; DROP ( x -- )
   694                        ;
   695                        ; Remove x from the stack.
   696                        
   697 00:076B: 5C 07 00 04                  HEADER  4,"DROP",NORMAL
       00:076F: 44 52 4F 50 
   698                        DROP:
   699 00:0773: 7B                           tdc                             ; Drop the top value
   700 00:0774: 1A                           inc     a
   701 00:0775: 1A                           inc     a
   702 00:0776: 5B                           tcd
   703 00:0777: BB C8 C8 7C                  CONTINUE                        ; Done
       00:077B: 00 00 
   704                        
   705                        ; DUP ( x -- x x )
   706                        ;
   707                        ; Duplicate x.
   708                        
   709 00:077D: 6E 07 00 03                  HEADER  3,"DUP",NORMAL
       00:0781: 44 55 50 
   710                        DUP:
   711 00:0784: 7B                           tdc
   712 00:0785: 3A                           dec     a
   713 00:0786: 3A                           dec     a
   714 00:0787: 5B                           tcd
   715 00:0788: A5 03                        lda     <3                      ; Fetch top value
   716 00:078A: 85 01                        sta     <1                      ; And make a copy
   717 00:078C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0790: 00 00 
   718                        
   719                        ; NIP ( x1 x2 -- x2 )
   720                        ;
  Wed Mar 16 2016 22:39                                                                                                    Page 17


   721                        ; Drop the first item below the top of stack.
   722                        
   723 00:0792: 80 07 00 03                  HEADER  3,"NIP",NORMAL
       00:0796: 4E 49 50 
   724                        NIP:
   725 00:0799: A5 01                        lda     <1                      ; Copy x2 over x1
   726 00:079B: 85 03                        sta     <3
   727 00:079D: 80 D4                        bra     DROP
   728                        
   729                        ; OVER ( x1 x2 -- x1 x2 x1 )
   730                        ;
   731                        ; Place a copy of x1 on top of the stack.
   732                        
   733 00:079F: 95 07 00 04                  HEADER  4,"OVER",NORMAL
       00:07A3: 4F 56 45 52 
   734                        OVER:
   735 00:07A7: 7B                           tdc
   736 00:07A8: 3A                           dec     a
   737 00:07A9: 3A                           dec     a
   738 00:07AA: 5B                           tcd
   739 00:07AB: A5 05                        lda     <5                      ; Fetch second value
   740 00:07AD: 85 01                        sta     <1                      ; And make a copy
   741 00:07AF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07B3: 00 00 
   742                        
   743                        ; SWAP ( x1 x2 -- x2 x1 )
   744                        ;
   745                        ; Exchange the top two stack items.
   746                        
   747 00:07B5: A2 07 00 04                  HEADER  4,"SWAP",NORMAL
       00:07B9: 53 57 41 50 
   748                        SWAP:
   749 00:07BD: A5 01                        lda     <1                      ; Switch top two words
   750 00:07BF: A6 03                        ldx     <3
   751 00:07C1: 85 03                        sta     <3
   752 00:07C3: 86 01                        stx     <1
   753 00:07C5: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07C9: 00 00 
   754                        
   755                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   756                        ;
   757                        ; Rotate the top three stack entries.
   758                        
   759 00:07CB: B8 07 00 03                  HEADER  3,"ROT",NORMAL
       00:07CF: 52 4F 54 
   760                        ROT:
   761 00:07D2: A6 05                        ldx     <5                      ; Save x1
   762 00:07D4: A5 03                        lda     <3                      ; Move x2
   763 00:07D6: 85 05                        sta     <5
   764 00:07D8: A5 01                        lda     <1                      ; Move x3
   765 00:07DA: 85 03                        sta     <3
   766 00:07DC: 86 01                        stx     <1                      ; Restore x1
   767 00:07DE: BB C8 C8 7C                  CONTINUE
       00:07E2: 00 00 
   768                        
   769                        ; ROLL [TODO]
   770                        
   771                        ; TUCK ( x1 x2 -- x2 x1 x2 )
  Wed Mar 16 2016 22:39                                                                                                    Page 18


   772                        ;
   773                        ; Copy the first (top) stack item below the second stack item.
   774                        
   775 00:07E4: CE 07 00 04                  HEADER  4,"TUCK",NORMAL
       00:07E8: 54 55 43 4B 
   776 00:07EC: 20 AF 11     TUCK:           jsr     DO_COLON
   777 00:07EF: BD 07                        dw      SWAP
   778 00:07F1: A7 07                        dw      OVER
   779 00:07F3: A7 0C                        dw      EXIT
   780                        
   781                        ;==============================================================================
   782                        ; Return Stack Operations
   783                        ;------------------------------------------------------------------------------
   784                        
   785                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   786                        ;
   787                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   788                        ; SWAP >R >R.
   789                        
   790 00:07F5: E7 07 00 03                  HEADER  3,"2>R",NORMAL
       00:07F9: 32 3E 52 
   791                        TWO_TO_R:
   792 00:07FC: A5 03                        lda     <3                      ; Transfer x1
   793 00:07FE: 48                           pha
   794 00:07FF: A5 01                        lda     <1                      ; Transfer x2
   795 00:0801: 48                           pha
   796 00:0802: 7B                           tdc
   797 00:0803: 1A                           inc     a                       ; Clean up data stack
   798 00:0804: 1A                           inc     a
   799 00:0805: 1A                           inc     a
   800 00:0806: 1A                           inc     a
   801 00:0807: 5B                           tcd
   802 00:0808: BB C8 C8 7C                  CONTINUE                        ; Done
       00:080C: 00 00 
   803                        
   804                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   805                        ;
   806                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   807                        ; R> SWAP.
   808                        
   809 00:080E: F8 07 00 03                  HEADER  3,"2R>",NORMAL
       00:0812: 32 52 3E 
   810                        TWO_R_FROM:
   811 00:0815: 7B                           tdc
   812 00:0816: 3A                           dec     a                       ; Make space for values
   813 00:0817: 3A                           dec     a
   814 00:0818: 3A                           dec     a
   815 00:0819: 3A                           dec     a
   816 00:081A: 5B                           tcd
   817 00:081B: 68                           pla                             ; Transfer x2
   818 00:081C: 85 01                        sta     <1
   819 00:081E: 68                           pla                             ; Transfer x1
   820 00:081F: 85 03                        sta     <3
   821 00:0821: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0825: 00 00 
   822                        
   823                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
   824                        ;
  Wed Mar 16 2016 22:39                                                                                                    Page 19


   825                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   826                        ; 2DUP >R >R SWAP.
   827                        
   828 00:0827: 11 08 00 03                  HEADER  3,"2R@",NORMAL
       00:082B: 32 52 40 
   829                        TWO_R_FETCH:
   830 00:082E: 7B                           tdc
   831 00:082F: 3A                           dec     a                       ; Make space for values
   832 00:0830: 3A                           dec     a
   833 00:0831: 3A                           dec     a
   834 00:0832: 3A                           dec     a
   835 00:0833: 5B                           tcd
   836 00:0834: A3 01                        lda     1,s                     ; Transfer x2
   837 00:0836: 85 01                        sta     <1
   838 00:0838: A3 03                        lda     3,s                     ; Transfer x1
   839 00:083A: 85 03                        sta     <3
   840 00:083C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0840: 00 00 
   841                        
   842                        ; >R ( x -- ) ( R: -- x )
   843                        ;
   844                        ; Move x to the return stack.
   845                        
   846 00:0842: 2A 08 00 02                  HEADER  2,">R",NORMAL
       00:0846: 3E 52 
   847                        TO_R:
   848 00:0848: A5 01                        lda     <1                      ; Transfer top value
   849 00:084A: 48                           pha                             ; .. to return stack
   850 00:084B: 7B                           tdc
   851 00:084C: 1A                           inc     a
   852 00:084D: 1A                           inc     a
   853 00:084E: 5B                           tcd
   854 00:084F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0853: 00 00 
   855                        
   856                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   857                        ;
   858                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   859                        ; exists if the loop control parameters are unavailable.
   860                        
   861 00:0855: 45 08 00 01                  HEADER  1,"I",NORMAL
       00:0859: 49 
   862                        I:
   863 00:085A: 7B                           tdc
   864 00:085B: 3A                           dec     a
   865 00:085C: 3A                           dec     a
   866 00:085D: 5B                           tcd
   867 00:085E: A3 01                        lda     1,s
   868 00:0860: 85 01                        sta     <1
   869 00:0862: BB C8 C8 7C                  CONTINUE
       00:0866: 00 00 
   870                        
   871                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   872                        ;
   873                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   874                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   875                        ; unavailable.
   876                        
  Wed Mar 16 2016 22:39                                                                                                    Page 20


   877 00:0868: 58 08 00 01                  HEADER  1,"J",NORMAL
       00:086C: 4A 
   878                        J:
   879 00:086D: 7B                           tdc
   880 00:086E: 3A                           dec     a
   881 00:086F: 3A                           dec     a
   882 00:0870: 5B                           tcd
   883 00:0871: A3 05                        lda     5,s
   884 00:0873: 85 01                        sta     <1
   885 00:0875: BB C8 C8 7C                  CONTINUE
       00:0879: 00 00 
   886                        
   887                        ; R> ( -- x ) ( R: x -- )
   888                        ;
   889                        ; Move x from the return stack to the data stack.
   890                        
   891 00:087B: 6B 08 00 02                  HEADER  2,"R>",NORMAL
       00:087F: 52 3E 
   892                        R_FROM:
   893 00:0881: 7B                           tdc
   894 00:0882: 3A                           dec     a
   895 00:0883: 3A                           dec     a
   896 00:0884: 5B                           tcd
   897 00:0885: 68                           pla                             ; Fetch return stack value
   898 00:0886: 85 01                        sta     <1
   899 00:0888: BB C8 C8 7C                  CONTINUE                        ; Done
       00:088C: 00 00 
   900                        
   901                        ; R@ ( -- x ) ( R: x -- x )
   902                        ;
   903                        ; Copy x from the return stack to the data stack.
   904                        
   905 00:088E: 7E 08 00 02                  HEADER  2,"R@",NORMAL
       00:0892: 52 40 
   906                        R_FETCH:
   907 00:0894: 7B                           tdc
   908 00:0895: 3A                           dec     a
   909 00:0896: 3A                           dec     a
   910 00:0897: 5B                           tcd
   911 00:0898: A3 01                        lda     1,s
   912 00:089A: 85 01                        sta     <1
   913 00:089C: BB C8 C8 7C                  CONTINUE
       00:08A0: 00 00 
   914                        
   915                        ;==============================================================================
   916                        ; Single Precision Arithmetic
   917                        ;------------------------------------------------------------------------------
   918                        
   919                        ; * ( n1|u1 n2|u2 -- n3|u3 )
   920                        ;
   921                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
   922                        
   923 00:08A2: 91 08 00 01                  HEADER  1,"*",NORMAL
       00:08A6: 2A 
   924                        STAR:
   925 00:08A7: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08AB: 00 00 
   926                        
  Wed Mar 16 2016 22:39                                                                                                    Page 21


   927                        ; */
   928                        
   929 00:08AD: A5 08 00 02                  HEADER  2,"*/",NORMAL
       00:08B1: 2A 2F 
   930                        STAR_SLASH:
   931 00:08B3: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08B7: 00 00 
   932                        
   933                        ; */MOD
   934                        
   935 00:08B9: B0 08 00 05                  HEADER  5,"*/MOD",NORMAL
       00:08BD: 2A 2F 4D 4F 
       00:08C1: 44 
   936                        STAR_SLASH_MOD:
   937 00:08C2: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08C6: 00 00 
   938                        
   939                        ; + ( n1|u1 n2|u2 -- n3|u3 )
   940                        ;
   941                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
   942                        
   943 00:08C8: BC 08 00 01                  HEADER  1,"+",NORMAL
       00:08CC: 2B 
   944                        PLUS:
   945 00:08CD: 18                           clc                             ; Add top two values
   946 00:08CE: A5 03                        lda     <3
   947 00:08D0: 65 01                        adc     <1
   948 00:08D2: 85 03                        sta     <3                      ; Save result
   949 00:08D4: 7B                           tdc
   950 00:08D5: 1A                           inc     a                       ; Clean up data stack
   951 00:08D6: 1A                           inc     a
   952 00:08D7: 5B                           tcd
   953 00:08D8: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08DC: 00 00 
   954                        
   955                        ; - ( n1|u1 n2|u2 -- n3|u3 )
   956                        ;
   957                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
   958                        
   959 00:08DE: CB 08 00 01                  HEADER  1,"-",NORMAL
       00:08E2: 2D 
   960                        MINUS:
   961 00:08E3: 38                           sec                             ; Subtract top two values
   962 00:08E4: A5 03                        lda     <3
   963 00:08E6: E5 01                        sbc     <1
   964 00:08E8: 85 03                        sta     <3                      ; Save result
   965 00:08EA: 7B                           tdc
   966 00:08EB: 1A                           inc     a                       ; Clean up data stack
   967 00:08EC: 1A                           inc     a
   968 00:08ED: 5B                           tcd
   969 00:08EE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08F2: 00 00 
   970                        
   971                        ; /
   972                        
   973 00:08F4: E1 08 00 01                  HEADER  1,"/",NORMAL
       00:08F8: 2F 
   974                        SLASH:
  Wed Mar 16 2016 22:39                                                                                                    Page 22


   975 00:08F9: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08FD: 00 00 
   976                        
   977                        ; /MOD
   978                        
   979 00:08FF: F7 08 00 04                  HEADER  4,"/MOD",NORMAL
       00:0903: 2F 4D 4F 44 
   980                        SLASH_MOD:
   981 00:0907: BB C8 C8 7C                  CONTINUE                        ; Done
       00:090B: 00 00 
   982                        
   983                        ; 1+ ( n1|u1 -- n2|u2 )
   984                        ;
   985                        ; Add one (1) to n1|u1 giving the sum n2|u2.
   986                        
   987 00:090D: 02 09 00 02                  HEADER  2,"1+",NORMAL
       00:0911: 31 2B 
   988                        ONE_PLUS:
   989 00:0913: E6 01                        inc     <1                      ; Increment top of stack
   990 00:0915: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0919: 00 00 
   991                        
   992                        ; 1- ( n1|u1 -- n2|u2 )
   993                        ;
   994                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
   995                        
   996 00:091B: 10 09 00 02                  HEADER  2,"1-",NORMAL
       00:091F: 31 2D 
   997                        ONE_MINUS:
   998 00:0921: C6 01                        dec     <1                      ; Decrement top of stack
   999 00:0923: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0927: 00 00 
  1000                        
  1001                        ; 2* ( x1 -- x2 )
  1002                        ;
  1003                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
  1004                        ; filling the vacated least-significant bit with zero.
  1005                        
  1006 00:0929: 1E 09 00 02                  HEADER  2,"2*",NORMAL
       00:092D: 32 2A 
  1007                        TWO_STAR:
  1008 00:092F: 06 01                        asl     <1                      ; Multiply top value by two
  1009 00:0931: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0935: 00 00 
  1010                        
  1011                        ; 2/ ( x1 -- x2 )
  1012                        ;
  1013                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
  1014                        ; leaving the most-significant bit unchanged.
  1015                        
  1016 00:0937: 2C 09 00 02                  HEADER  2,"2/",NORMAL
       00:093B: 32 2F 
  1017                        TWO_SLASH:
  1018 00:093D: A5 01                        lda     <1                      ; Load the top value
  1019 00:093F: 2A                           rol     a                       ; Extract the top bit
  1020 00:0940: 66 01                        ror     <1                      ; And shift back into value
  1021 00:0942: BB C8 C8 7C                  CONTINUE
       00:0946: 00 00 
  Wed Mar 16 2016 22:39                                                                                                    Page 23


  1022                        
  1023                        ; ABS ( n -- u )
  1024                        ;
  1025                        ; u is the absolute value of n.
  1026                        
  1027 00:0948: 3A 09 00 03                  HEADER  3,"ABS",NORMAL
       00:094C: 41 42 53 
  1028                        ABS:
  1029 00:094F: A5 01                        lda     <1
  1030 00:0951: 30 10                        bmi     NEGATE
  1031 00:0953: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0957: 00 00 
  1032                        
  1033                        ; MAX
  1034                        ; MIN
  1035                        ; MOD
  1036                        
  1037                        ; NEGATE ( n1 -- n2 )
  1038                        ;
  1039                        ; Negate n1, giving its arithmetic inverse n2.
  1040                        
  1041 00:0959: 4B 09 00 06                  HEADER  6,"NEGATE",NORMAL
       00:095D: 4E 45 47 41 
       00:0961: 54 45 
  1042                        NEGATE:
  1043 00:0963: 38                           sec                             ; Negate the top of stack
  1044 00:0964: A9 00 00                     lda     #0
  1045 00:0967: E5 01                        sbc     <1
  1046 00:0969: 85 01                        sta     <1
  1047 00:096B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:096F: 00 00 
  1048                        
  1049                        ; UMAX ( x1 x2 -- x1|x2 )
  1050                        
  1051 00:0971: 5C 09 00 04                  HEADER  4,"UMAX",NORMAL
       00:0975: 55 4D 41 58 
  1052                        UMAX:
  1053 00:0979: A5 01                        lda     <1                      ; Compare the top values
  1054 00:097B: C5 03                        cmp     <3
  1055 00:097D: B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
  1056 00:097F: 4C 73 07                     jmp     DROP                    ; No, x1 is
  1057 00:0982: 4C 99 07     UMAX_EXIT:      jmp     NIP
  1058                        
  1059                        ; UMIN ( x1 x2 -- x1|x2 )
  1060                        
  1061 00:0985: 74 09 00 04                  HEADER  4,"UMIN",NORMAL
       00:0989: 55 4D 49 4E 
  1062                        UMIN:
  1063 00:098D: A5 01                        lda     <1                      ; Compare the top values
  1064 00:098F: C5 03                        cmp     <3
  1065 00:0991: 90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
  1066 00:0993: 4C 73 07                     jmp     DROP                    ; No, x1 is
  1067 00:0996: 4C 99 07     UMIN_EXIT:      jmp     NIP
  1068                        
  1069                        ;==============================================================================
  1070                        ; Double Precision Arithmetic
  1071                        ;------------------------------------------------------------------------------
  1072                        
  Wed Mar 16 2016 22:39                                                                                                    Page 24


  1073                        ; D+ ( d1|ud1 d2|ud2 -- d3|ud3 )
  1074                        ;
  1075                        ; Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
  1076                        
  1077 00:0999: 88 09 00 02                  HEADER  2,"D+",NORMAL
       00:099D: 44 2B 
  1078                        D_PLUS:
  1079 00:099F: 18                           clc
  1080 00:09A0: A5 07                        lda     <7                      ; Add low words
  1081 00:09A2: 65 03                        adc     <3
  1082 00:09A4: 85 07                        sta     <7
  1083 00:09A6: A5 05                        lda     <5                      ; Then the high words
  1084 00:09A8: 65 01                        adc     <1
  1085 00:09AA: 85 05                        sta     <5
  1086 00:09AC: 7B                           tdc                             ; Drop top double
  1087 00:09AD: 1A                           inc     a
  1088 00:09AE: 1A                           inc     a
  1089 00:09AF: 1A                           inc     a
  1090 00:09B0: 1A                           inc     a
  1091 00:09B1: 5B                           tcd
  1092 00:09B2: BB C8 C8 7C                  CONTINUE                        ; Done
       00:09B6: 00 00 
  1093                        
  1094                        ; D- ( d1|ud1 d2|ud2 -- d3|ud3 )
  1095                        ;
  1096                        ; Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
  1097                        
  1098 00:09B8: 9C 09 00 02                  HEADER  2,"D-",NORMAL
       00:09BC: 44 2D 
  1099                        D_MINUS:
  1100 00:09BE: 38                           sec
  1101 00:09BF: A5 07                        lda     <7                      ; Subtract low words
  1102 00:09C1: E5 03                        sbc     <3
  1103 00:09C3: 85 07                        sta     <7
  1104 00:09C5: A5 05                        lda     <5                      ; Then the high words
  1105 00:09C7: E5 01                        sbc     <1
  1106 00:09C9: 85 05                        sta     <5
  1107 00:09CB: 7B                           tdc                             ; Drop top double
  1108 00:09CC: 1A                           inc     a
  1109 00:09CD: 1A                           inc     a
  1110 00:09CE: 1A                           inc     a
  1111 00:09CF: 1A                           inc     a
  1112 00:09D0: 5B                           tcd
  1113 00:09D1: BB C8 C8 7C                  CONTINUE                        ; Done
       00:09D5: 00 00 
  1114                        
  1115                        ; D2* ( xd1 -- xd2 )
  1116                        ;
  1117                        ; xd2 is the result of shifting xd1 one bit toward the most-significant bit,
  1118                        ; filling the vacated least-significant bit with zero.
  1119                        
  1120 00:09D7: BB 09 00 03                  HEADER  3,"D2*",NORMAL
       00:09DB: 44 32 2A 
  1121                        D_TWO_STAR:
  1122 00:09DE: 06 03                        asl     <3
  1123 00:09E0: 26 01                        rol     <1
  1124 00:09E2: BB C8 C8 7C                  CONTINUE
       00:09E6: 00 00 
  Wed Mar 16 2016 22:39                                                                                                    Page 25


  1125                        
  1126                        ; D2/ ( xd1 -- xd2 )
  1127                        ;
  1128                        ; xd2 is the result of shifting xd1 one bit toward the least-significant bit,
  1129                        ; leaving the most-significant bit unchanged.
  1130                        
  1131 00:09E8: DA 09 00 03                  HEADER  3,"D2/",NORMAL
       00:09EC: 44 32 2F 
  1132                        D_TWO_SLASH:
  1133 00:09EF: A5 01                        lda     <1
  1134 00:09F1: 2A                           rol     a
  1135 00:09F2: 66 01                        ror     <1
  1136 00:09F4: 66 03                        ror     <3
  1137 00:09F6: BB C8 C8 7C                  CONTINUE
       00:09FA: 00 00 
  1138                        
  1139                        ; DABS
  1140                        ; DMAX
  1141                        ; DMIN
  1142                        
  1143                        ; DNEGATE ( d1 -- d2 )
  1144                        ;
  1145                        ; d2 is the negation of d1.
  1146                        
  1147 00:09FC: EB 09 00 07                  HEADER  7,"DNEGATE",NORMAL
       00:0A00: 44 4E 45 47 
       00:0A04: 41 54 45 
  1148                        DNEGATE:
  1149 00:0A07: 38                           sec
  1150 00:0A08: A9 00 00                     lda     #0                      ; Subtract low word from zero
  1151 00:0A0B: E5 03                        sbc     <3
  1152 00:0A0D: 85 03                        sta     <3
  1153 00:0A0F: A9 00 00                     lda     #0                      ; Then the high word
  1154 00:0A12: E5 01                        sbc     <1
  1155 00:0A14: 85 01                        sta     <1
  1156 00:0A16: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A1A: 00 00 
  1157                        
  1158                        ; UD* ( ud1 d2 -- ud3)
  1159                        ;
  1160                        ; 32*16->32 multiply
  1161                        ;
  1162                        ;   DUP >R UM* DROP  SWAP R> UM* ROT + ;
  1163                        
  1164 00:0A1C: FF 09 00 03                  HEADER  3,"UD*",NORMAL
       00:0A20: 55 44 2A 
  1165 00:0A23: 20 AF 11     UD_STAR:        jsr     DO_COLON
  1166 00:0A26: 84 07                        dw      DUP
  1167 00:0A28: 48 08                        dw      TO_R
  1168 00:0A2A: 86 0A                        dw      UM_STAR
  1169 00:0A2C: 73 07                        dw      DROP
  1170 00:0A2E: BD 07                        dw      SWAP
  1171 00:0A30: 81 08                        dw      R_FROM
  1172 00:0A32: 86 0A                        dw      UM_STAR
  1173 00:0A34: D2 07                        dw      ROT
  1174 00:0A36: CD 08                        dw      PLUS
  1175 00:0A38: A7 0C                        dw      EXIT
  1176                        
  Wed Mar 16 2016 22:39                                                                                                    Page 26


  1177                        ;==============================================================================
  1178                        ; Mixed Arithmetic
  1179                        ;------------------------------------------------------------------------------
  1180                        
  1181                        
  1182                        ; D>S ( d -- n )
  1183                        ;
  1184                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1185                        ; range of a signed single-cell number.
  1186                        
  1187 00:0A3A: 1F 0A 00 03                  HEADER  3,"D>S",NORMAL
       00:0A3E: 44 3E 53 
  1188                        D_TO_S:
  1189 00:0A41: 7B                           tdc
  1190 00:0A42: 1A                           inc     a                       ; Drop the high word
  1191 00:0A43: 1A                           inc     a
  1192 00:0A44: 5B                           tcd
  1193 00:0A45: BB C8 C8 7C                  CONTINUE
       00:0A49: 00 00 
  1194                        
  1195                        ; M*/
  1196                        
  1197                        ; M+ ( d1|ud1 n -- d2|ud2 )
  1198                        ;
  1199                        ; Add n to d1|ud1, giving the sum d2|ud2.
  1200                        
  1201 00:0A4B: 3D 0A 00 02                  HEADER  2,"M+",NORMAL
       00:0A4F: 4D 2B 
  1202                        M_PLUS:
  1203 00:0A51: 18                           clc
  1204 00:0A52: A5 01                        lda     <1
  1205 00:0A54: 65 05                        adc     <5
  1206 00:0A56: 85 05                        sta     <5
  1207 00:0A58: 90 02                        bcc     $+4
  1208 00:0A5A: E6 03                        inc     <3
  1209 00:0A5C: 7B                           tdc
  1210 00:0A5D: 1A                           inc     a
  1211 00:0A5E: 1A                           inc     a
  1212 00:0A5F: 5B                           tcd
  1213 00:0A60: BB C8 C8 7C                  CONTINUE
       00:0A64: 00 00 
  1214                        
  1215                        ; S>D ( n -- d )
  1216                        ;
  1217                        ; Convert the number n to the double-cell number d with the same numerical
  1218                        ; value.
  1219                        
  1220 00:0A66: 4E 0A 00 03                  HEADER  3,"S>D",NORMAL
       00:0A6A: 53 3E 44 
  1221                        S_TO_D:
  1222 00:0A6D: 7B                           tdc
  1223 00:0A6E: 3A                           dec     a                       ; Assume n is positive
  1224 00:0A6F: 3A                           dec     a
  1225 00:0A70: 5B                           tcd
  1226 00:0A71: 64 01                        stz     <1                      ; .. push a zero value
  1227 00:0A73: A5 03                        lda     <3                      ; Test the number
  1228 00:0A75: 10 02                        bpl     S_TO_D_1
  1229 00:0A77: C6 01                        dec     <1                      ; Make top -1 if negative
  Wed Mar 16 2016 22:39                                                                                                    Page 27


  1230 00:0A79: BB C8 C8 7C  S_TO_D_1        CONTINUE                        ; Done
       00:0A7D: 00 00 
  1231                        
  1232                        ; UM* ( n1 n2 -- d )
  1233                        
  1234 00:0A7F: 69 0A 00 03                  HEADER  3,"UM*",NORMAL
       00:0A83: 55 4D 2A 
  1235                        UM_STAR:
  1236 00:0A86: A5 01                        lda     <1                      ; Fetch multiplier
  1237 00:0A88: 48                           pha
  1238 00:0A89: 64 01                        stz     <1                      ; Clear the result
  1239 00:0A8B: A2 10 00                     ldx     #16
  1240 00:0A8E: A5 03        UM_STAR_1:      lda     <3                      ; Shift multiplier one bit
  1241 00:0A90: 4A                           lsr     a
  1242 00:0A91: 90 06                        bcc     UM_STAR_2               ; Not set, no add
  1243 00:0A93: A3 01                        lda     1,s                     ; Fetch multiplicand
  1244 00:0A95: 65 01                        adc     <1
  1245 00:0A97: 85 01                        sta     <1
  1246 00:0A99: 66 01        UM_STAR_2:      ror     <1                      ; Rotate high word down
  1247 00:0A9B: 66 03                        ror     <3
  1248 00:0A9D: CA                           dex
  1249 00:0A9E: D0 EE                        bne     UM_STAR_1
  1250 00:0AA0: 68                           pla
  1251 00:0AA1: 68                           pla
  1252 00:0AA2: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0AA6: 00 00 
  1253                        
  1254                        ;==============================================================================
  1255                        ; Comparisons
  1256                        ;------------------------------------------------------------------------------
  1257                        
  1258                        ; 0< ( n -- flag )
  1259                        ;
  1260                        ; flag is true if and only if n is less than zero.
  1261                        
  1262 00:0AA8: 82 0A 00 02                  HEADER  2,"0<",NORMAL
       00:0AAC: 30 3C 
  1263                        ZERO_LESS:
  1264 00:0AAE: A5 01                        lda     <1                      ; Test top of stack
  1265 00:0AB0: 64 01                        stz     <1                      ; Assume false result
  1266 00:0AB2: 10 02                        bpl     ZERO_LT_1               ; Was the value negative?
  1267 00:0AB4: C6 01                        dec     <1                      ; Yes, make true result
  1268 00:0AB6: BB C8 C8 7C  ZERO_LT_1:      CONTINUE                        ; Done
       00:0ABA: 00 00 
  1269                        
  1270                        ; 0<> ( x -- flag )
  1271                        ;
  1272                        ; flag is true if and only if x is not equal to zero.
  1273                        
  1274 00:0ABC: AB 0A 00 03                  HEADER  3,"0<>",NORMAL
       00:0AC0: 30 3C 3E 
  1275                        ZERO_NOT_EQUAL:
  1276 00:0AC3: A5 01                        lda     <1                      ; Test top of stack
  1277 00:0AC5: 64 01                        stz     <1                      ; Assume false result
  1278 00:0AC7: F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
  1279 00:0AC9: C6 01                        dec     <1                      ; Yes, make true result
  1280 00:0ACB: BB C8 C8 7C  ZERO_NE_1:      CONTINUE                        ; Done
       00:0ACF: 00 00 
  Wed Mar 16 2016 22:39                                                                                                    Page 28


  1281                        
  1282                        ; 0= ( x -- flag )
  1283                        ;
  1284                        ; flag is true if and only if x is equal to zero.
  1285                        
  1286 00:0AD1: BF 0A 00 02                  HEADER  2,"0=",NORMAL
       00:0AD5: 30 3D 
  1287                        ZERO_EQUAL:
  1288 00:0AD7: A5 01                        lda     <1                      ; Test top of stack
  1289 00:0AD9: 64 01                        stz     <1                      ; Assume false result
  1290 00:0ADB: D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
  1291 00:0ADD: C6 01                        dec     <1                      ; Yes, make true result
  1292 00:0ADF: BB C8 C8 7C  ZERO_EQ_1:      CONTINUE                        ; Done
       00:0AE3: 00 00 
  1293                        
  1294                        ; 0> ( n -- flag )
  1295                        ;
  1296                        ; flag is true if and only if n is greater than zero.
  1297                        
  1298 00:0AE5: D4 0A 00 02                  HEADER  2,"0>",NORMAL
       00:0AE9: 30 3E 
  1299                        ZERO_GREATER:
  1300 00:0AEB: A5 01                        lda     <1                      ; Test top of stack
  1301 00:0AED: 64 01                        stz     <1                      ; Assume false result
  1302 00:0AEF: 30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
  1303 00:0AF1: F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
  1304 00:0AF3: C6 01                        dec     <1                      ; Yes, make true result
  1305 00:0AF5: BB C8 C8 7C  ZERO_GT_EXIT:   CONTINUE                        ; Done
       00:0AF9: 00 00 
  1306                        
  1307                        ; <
  1308                        
  1309 00:0AFB: E8 0A 00 01                  HEADER  1,"<",NORMAL
       00:0AFF: 3C 
  1310                        LESS:
  1311 00:0B00: A6 01                        ldx     <1                      ; Pull x2 from stack
  1312 00:0B02: 7B                           tdc
  1313 00:0B03: 1A                           inc     a
  1314 00:0B04: 1A                           inc     a
  1315 00:0B05: 5B                           tcd
  1316 00:0B06: 38                           sec                             ; Compare with x1
  1317 00:0B07: E5 01                        sbc     <1
  1318 00:0B09: 64 01                        stz     <1                      ; Assume false result
  1319 00:0B0B: 70 04                        bvs     LESS_1
  1320 00:0B0D: 10 04                        bpl     LESS_2                  ; V == 0 && N == 0
  1321 00:0B0F: 80 04                        bra     LESS_3
  1322 00:0B11: 10 02        LESS_1:         bpl     LESS_3                  ; V == 1 && N == 1
  1323 00:0B13: C6 01        LESS_2:         dec     <1
  1324 00:0B15: BB C8 C8 7C  LESS_3:         CONTINUE
       00:0B19: 00 00 
  1325                        
  1326                        ; <>
  1327                        
  1328 00:0B1B: FE 0A 00 02                  HEADER  2,"<>",NORMAL
       00:0B1F: 3C 3E 
  1329                        NOT_EQUAL:
  1330 00:0B21: A6 01                        ldx     <1                      ; Pull x2 from stack
  1331 00:0B23: 7B                           tdc
  Wed Mar 16 2016 22:39                                                                                                    Page 29


  1332 00:0B24: 1A                           inc     a
  1333 00:0B25: 1A                           inc     a
  1334 00:0B26: 5B                           tcd
  1335 00:0B27: E4 01                        cpx     <1                      ; Compare with x1
  1336 00:0B29: 64 01                        stz     <1                      ; Assume equal
  1337 00:0B2B: F0 02                        beq     NE_EXIT                 ; Test flags
  1338 00:0B2D: C6 01                        dec     <1                      ; Make result true
  1339 00:0B2F: BB C8 C8 7C  NE_EXIT:        CONTINUE                        ; Done
       00:0B33: 00 00 
  1340                        
  1341                        ; = ( x1 x2 -- flag )
  1342                        ;
  1343                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  1344                        
  1345 00:0B35: 1E 0B 00 01                  HEADER  1,"=",NORMAL
       00:0B39: 3D 
  1346                        EQUAL:
  1347 00:0B3A: A6 01                        ldx     <1                      ; Pull x2 from stack
  1348 00:0B3C: 7B                           tdc
  1349 00:0B3D: 1A                           inc     a
  1350 00:0B3E: 1A                           inc     a
  1351 00:0B3F: 5B                           tcd
  1352 00:0B40: E4 01                        cpx     <1                      ; Compare with x1
  1353 00:0B42: 64 01                        stz     <1                      ; Assume not equal
  1354 00:0B44: D0 02                        bne     EQ_EXIT                 ; Test the flags
  1355 00:0B46: C6 01                        dec     <1                      ; Make result true
  1356 00:0B48: BB C8 C8 7C  EQ_EXIT:        CONTINUE                        ; Done
       00:0B4C: 00 00 
  1357                        
  1358                        ; >
  1359                        
  1360 00:0B4E: 38 0B 00 01                  HEADER  1,">",NORMAL
       00:0B52: 3E 
  1361 00:0B53: 20 AF 11     GREATER:        jsr     DO_COLON
  1362 00:0B56: BD 07                        dw      SWAP
  1363 00:0B58: 00 0B                        dw      LESS
  1364 00:0B5A: A7 0C                        dw      EXIT
  1365                        
  1366                        ; U<
  1367                        
  1368 00:0B5C: 51 0B 00 02                  HEADER  2,"U<",NORMAL
       00:0B60: 55 3C 
  1369                        U_LESS:
  1370 00:0B62: A6 01                        ldx     <1                      ; Pull x2
  1371 00:0B64: 7B                           tdc                             ; Drop from stack
  1372 00:0B65: 1A                           inc     a
  1373 00:0B66: 1A                           inc     a
  1374 00:0B67: 5B                           tcd
  1375 00:0B68: E4 01                        cpx     <1                      ; Compare with x1
  1376 00:0B6A: 64 01                        stz     <1                      ; Assume false
  1377 00:0B6C: F0 04                        beq     U_LESS_1                ; Equal
  1378 00:0B6E: 90 02                        bcc     U_LESS_1                ; Less
  1379 00:0B70: C6 01                        dec     <1
  1380 00:0B72: BB C8 C8 7C  U_LESS_1:       CONTINUE
       00:0B76: 00 00 
  1381                        
  1382                        ; U>
  1383                        
  Wed Mar 16 2016 22:39                                                                                                    Page 30


  1384 00:0B78: 5F 0B 00 02                  HEADER  2,"U>",NORMAL
       00:0B7C: 55 3E 
  1385 00:0B7E: 20 AF 11     U_GREATER:      jsr     DO_COLON
  1386 00:0B81: BD 07                        dw      SWAP
  1387 00:0B83: 62 0B                        dw      U_LESS
  1388 00:0B85: A7 0C                        dw      EXIT
  1389                        
  1390                        ;==============================================================================
  1391                        ; Logical Operations
  1392                        ;------------------------------------------------------------------------------
  1393                        
  1394                        ; AND ( x1 x2 -- x3 )
  1395                        ;
  1396                        ; x3 is the bit-by-bit logical and of x1 with x2.
  1397                        
  1398 00:0B87: 7B 0B 00 03                  HEADER  3,"AND",NORMAL
       00:0B8B: 41 4E 44 
  1399                        AND:
  1400 00:0B8E: A5 01                        lda     <1
  1401 00:0B90: 25 03                        and     <3
  1402 00:0B92: 85 03                        sta     <3
  1403 00:0B94: 7B                           tdc
  1404 00:0B95: 1A                           inc     a
  1405 00:0B96: 1A                           inc     a
  1406 00:0B97: 5B                           tcd
  1407 00:0B98: BB C8 C8 7C                  CONTINUE
       00:0B9C: 00 00 
  1408                        
  1409                        ; INVERT ( x1 -- x2 )
  1410                        ;
  1411                        ; Invert all bits of x1, giving its logical inverse x2.
  1412                        
  1413 00:0B9E: 8A 0B 00 06                  HEADER  6,"INVERT",NORMAL
       00:0BA2: 49 4E 56 45 
       00:0BA6: 52 54 
  1414                        INVERT:
  1415 00:0BA8: A5 01                        lda     <1                      ; Fetch top value
  1416 00:0BAA: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1417 00:0BAD: 85 01                        sta     <1                      ; .. and write back
  1418 00:0BAF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0BB3: 00 00 
  1419                        
  1420                        ; LSHIFT ( x1 u -- x2 )
  1421                        ;
  1422                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1423                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1424                        ; exists if u is greater than or equal to the number of bits in a cell.
  1425                        
  1426 00:0BB5: A1 0B 00 06                  HEADER  6,"LSHIFT",NORMAL
       00:0BB9: 4C 53 48 49 
       00:0BBD: 46 54 
  1427                        LSHIFT:
  1428 00:0BBF: A6 01                        ldx     <1                      ; Pull bit count
  1429 00:0BC1: 08                           php
  1430 00:0BC2: 7B                           tdc
  1431 00:0BC3: 1A                           inc     a                       ; .. from the stack
  1432 00:0BC4: 1A                           inc     a
  1433 00:0BC5: 5B                           tcd
  Wed Mar 16 2016 22:39                                                                                                    Page 31


  1434 00:0BC6: 28                           plp
  1435 00:0BC7: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1436 00:0BC9: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1437 00:0BCC: B0 0B                        bcs     LSHIFT_2                ; Yes, result will be zero
  1438 00:0BCE: 06 01        LSHIFT_1        asl     <1                      ; Shift one bit left
  1439 00:0BD0: CA                           dex                             ; Update count
  1440 00:0BD1: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  1441 00:0BD3: BB C8 C8 7C  LSHIFT_0        CONTINUE                        ; Done
       00:0BD7: 00 00 
  1442 00:0BD9: 64 01        LSHIFT_2        stz     <1                      ; Clear top value
  1443 00:0BDB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0BDF: 00 00 
  1444                        
  1445                        ; OR ( x1 x2 -- x3 )
  1446                        ;
  1447                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1448                        
  1449 00:0BE1: B8 0B 00 02                  HEADER  2,"OR",NORMAL
       00:0BE5: 4F 52 
  1450                        OR:
  1451 00:0BE7: A5 01                        lda     <1
  1452 00:0BE9: 05 03                        ora     <3
  1453 00:0BEB: 85 03                        sta     <3
  1454 00:0BED: 7B                           tdc
  1455 00:0BEE: 1A                           inc     a
  1456 00:0BEF: 1A                           inc     a
  1457 00:0BF0: 5B                           tcd
  1458 00:0BF1: BB C8 C8 7C                  CONTINUE
       00:0BF5: 00 00 
  1459                        
  1460                        ; RSHIFT ( x1 u -- x2 )
  1461                        ;
  1462                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1463                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1464                        ; exists if u is greater than or equal to the number of bits in a cell.
  1465                        
  1466 00:0BF7: E4 0B 00 06                  HEADER  6,"RSHIFT",NORMAL
       00:0BFB: 52 53 48 49 
       00:0BFF: 46 54 
  1467                        RSHIFT:
  1468 00:0C01: A6 01                        ldx     <1                      ; Pull bit count
  1469 00:0C03: 08                           php
  1470 00:0C04: 7B                           tdc
  1471 00:0C05: 1A                           inc     a                       ; .. from the stack
  1472 00:0C06: 1A                           inc     a
  1473 00:0C07: 5B                           tcd
  1474 00:0C08: 28                           plp
  1475 00:0C09: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1476 00:0C0B: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1477 00:0C0E: B0 0B                        bcs     RSHIFT_2                ; Yes, result will be zero
  1478 00:0C10: 46 01        RSHIFT_1        lsr     <1                      ; Shift one bit left
  1479 00:0C12: CA                           dex                             ; Update count
  1480 00:0C13: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1481 00:0C15: BB C8 C8 7C  RSHIFT_0        CONTINUE                        ; Done
       00:0C19: 00 00 
  1482 00:0C1B: 64 01        RSHIFT_2        stz     <1                      ; Clear top value
  1483 00:0C1D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0C21: 00 00 
  Wed Mar 16 2016 22:39                                                                                                    Page 32


  1484                        
  1485                        ; XOR ( x1 x2 -- x3 )
  1486                        ;
  1487                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1488                        
  1489 00:0C23: FA 0B 00 03                  HEADER  3,"XOR",NORMAL
       00:0C27: 58 4F 52 
  1490                        XOR:
  1491 00:0C2A: A5 01                        lda     <1
  1492 00:0C2C: 45 03                        eor     <3
  1493 00:0C2E: 85 03                        sta     <3
  1494 00:0C30: 7B                           tdc
  1495 00:0C31: 1A                           inc     a
  1496 00:0C32: 1A                           inc     a
  1497 00:0C33: 5B                           tcd
  1498 00:0C34: BB C8 C8 7C                  CONTINUE
       00:0C38: 00 00 
  1499                        
  1500                        ;==============================================================================
  1501                        ; Control Words
  1502                        ;------------------------------------------------------------------------------
  1503                        
  1504                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1505                        ;
  1506                        ; Empty the data stack and perform the function of QUIT, which includes
  1507                        ; emptying the return stack, without displaying a message.
  1508                        
  1509 00:0C3A: 26 0C 00 05                  HEADER  5,"ABORT",NORMAL
       00:0C3E: 41 42 4F 52 
       00:0C42: 54 
  1510 00:0C43: 20 AF 11     ABORT:          jsr     DO_COLON
  1511 00:0C46: 4A 0C                        dw      DO_ABORT
  1512 00:0C48: B6 0C                        dw      QUIT
  1513                        
  1514                        DO_ABORT:
  1515 00:0C4A: A9 7F 01                     lda     #DSTACK_END-1
  1516 00:0C4D: 5B                           tcd
  1517 00:0C4E: BB C8 C8 7C                  CONTINUE
       00:0C52: 00 00 
  1518                        
  1519                        ; (BUILD) ( dtc-addr -- )
  1520                        ;
  1521                        ; Adds a jump the to exection function for the new word.
  1522                        
  1523 00:0C54: 3D 0C 00 07                  HEADER  7,"(BUILD)",NORMAL
       00:0C58: 28 42 55 49 
       00:0C5C: 4C 44 29 
  1524 00:0C5F: 20 AF 11     BUILD:          jsr     DO_COLON
  1525 00:0C62: A5 12 20 00                  dw      DO_LITERAL,$20
  1526 00:0C66: 3B 06                        dw      C_COMMA
  1527 00:0C68: BF 05                        dw      COMMA
  1528 00:0C6A: A7 0C                        dw      EXIT
  1529                        
  1530                        ; CREATE ( -- ) [TODO]
  1531                        ;
  1532                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1533                        ; definition for name with the execution semantics defined below. If the data-
  1534                        ; space pointer is not aligned, reserve enough data space to align it. The new
  Wed Mar 16 2016 22:39                                                                                                    Page 33


  1535                        ; data-space pointer defines names data field. CREATE does not allocate data
  1536                        ; space in names data field.
  1537                        
  1538 00:0C6C: 57 0C 00 06                  HEADER  6,"CREATE",NORMAL
       00:0C70: 43 52 45 41 
       00:0C74: 54 45 
  1539 00:0C76: 20 AF 11     CREATE:         jsr     DO_COLON
  1540                                        ; parse
  1541 00:0C79: 6A 06                        dw      HERE
  1542 00:0C7B: BF 04 FF 05                  dw      LATEST,FETCH,COMMA
       00:0C7F: BF 05 
  1543 00:0C81: 14 05                        dw      ZERO
  1544 00:0C83: 3B 06                        dw      C_COMMA
  1545 00:0C85: BF 04                        dw      LATEST
  1546 00:0C87: 91 05                        dw      STORE
  1547                                        ; move name
  1548 00:0C89: A7 0C                        dw      EXIT
  1549                        
  1550                        ; EXECUTE ( i*x xt -- j*x )
  1551                        ;
  1552                        ; Remove xt from the stack and perform the semantics identified by it. Other
  1553                        ; stack effects are due to the word EXECUTEd.
  1554                        
  1555 00:0C8B: 6F 0C 00 07                  HEADER  7,"EXECUTE",NORMAL
       00:0C8F: 45 58 45 43 
       00:0C93: 55 54 45 
  1556                        EXECUTE:
  1557 00:0C96: A6 01                        ldx     <1
  1558 00:0C98: 7B                           tdc
  1559 00:0C99: 1A                           inc     a
  1560 00:0C9A: 1A                           inc     a
  1561 00:0C9B: 5B                           tcd
  1562 00:0C9C: CA                           dex
  1563 00:0C9D: DA                           phx
  1564 00:0C9E: 60                           rts
  1565                        
  1566                        ; EXIT ( -- ) ( R: nest-sys -- )
  1567                        ;
  1568                        ; Return control to the calling definition specified by nest-sys. Before
  1569                        ; executing EXIT within a do-loop, a program shall discard the loop-control
  1570                        ; parameters by executing UNLOOP.
  1571                        
  1572 00:0C9F: 8E 0C 00 04                  HEADER  4,"EXIT",NORMAL
       00:0CA3: 45 58 49 54 
  1573                        EXIT:
  1574 00:0CA7: 7A                           ply
  1575 00:0CA8: BB C8 C8 7C                  CONTINUE
       00:0CAC: 00 00 
  1576                        
  1577                        ; QUIT ( -- ) ( R: i*x -- )
  1578                        ;
  1579                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  1580                        ; user input device the input source, and enter interpretation state. Do not
  1581                        ; display a message. Repeat the following:
  1582                        ;  Accept a line from the input source into the input buffer, set >IN to zero,
  1583                        ;   and interpret.
  1584                        ;  Display the implementation-defined system prompt if in interpretation state,
  1585                        ;   all processing has been completed, and no ambiguous condition exists.
  Wed Mar 16 2016 22:39                                                                                                    Page 34


  1586                        ;
  1587                        ; In this implementation it is defined as:
  1588                        ;
  1589                        ;   DO_QUIT 0 STATE !
  1590                        ;   0 (SOURCE-ID) !
  1591                        ;   BEGIN
  1592                        ;     REFILL
  1593                        ;     WHILE SOURCE EVALUATE
  1594                        ;     STATE @ 0= IF S" Ok" CR TYPE THEN
  1595                        ;   AGAIN ;
  1596                        
  1597 00:0CAE: A2 0C 00 04                  HEADER  4,"QUIT",NORMAL
       00:0CB2: 51 55 49 54 
  1598 00:0CB6: 20 AF 11     QUIT:           jsr     DO_COLON
  1599 00:0CB9: E6 0C                        dw      DO_QUIT
  1600 00:0CBB: 14 05                        dw      ZERO
  1601 00:0CBD: FE 04                        dw      STATE
  1602 00:0CBF: 91 05                        dw      STORE
  1603 00:0CC1: 14 05                        dw      ZERO
  1604 00:0CC3: F0 04                        dw      SOURCEID
  1605 00:0CC5: 91 05                        dw      STORE
  1606 00:0CC7: 88 0F        QUIT_1:         dw      REFILL
  1607 00:0CC9: 6F 12 CF 0C                  dw      QUERY_BRANCH,QUIT_2
  1608 00:0CCD: A7 0E                        dw      INTERPRET
  1609 00:0CCF: FE 04        QUIT_2:         dw      STATE
  1610 00:0CD1: FF 05                        dw      FETCH
  1611 00:0CD3: D7 0A                        dw      ZERO_EQUAL
  1612 00:0CD5: 6F 12 E2 0C                  dw      QUERY_BRANCH,QUIT_3
  1613 00:0CD9: 4F 13                        dw      DO_S_QUOTE
  1614 00:0CDB: 02 4F 6B                     db      2,"Ok"
  1615 00:0CDE: F1 13                        dw      TYPE
  1616 00:0CE0: 74 13                        dw      CR
  1617 00:0CE2: 4D 12 C7 0C  QUIT_3:         dw      BRANCH,QUIT_1
  1618                        
  1619                        DO_QUIT:
  1620 00:0CE6: A9 FF 01                     lda     #RSTACK_END-1           ; Reset the return stack
  1621 00:0CE9: 1B                           tcs
  1622 00:0CEA: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0CEE: 00 00 
  1623                        
  1624                        ;==============================================================================
  1625                        ; Parser & Interpreter
  1626                        ;------------------------------------------------------------------------------
  1627                        
  1628                        ; ?NUMBER
  1629                        ;   DUP  0 0 ROT COUNT      -- ca ud adr n
  1630                        ;   ?SIGN >R  >NUMBER       -- ca ud adr' n'
  1631                        ;   IF   R> 2DROP 2DROP 0   -- ca 0   (error)
  1632                        ;   ELSE 2DROP NIP R>
  1633                        ;       IF NEGATE THEN  -1  -- n -1   (ok)
  1634                        ;   THEN ;
  1635                        
  1636 00:0CF0: B1 0C 00 07                  HEADER  7,"?NUMBER",NORMAL
       00:0CF4: 3F 4E 55 4D 
       00:0CF8: 42 45 52 
  1637 00:0CFB: 20 AF 11     QUERY_NUMBER:   jsr     DO_COLON
  1638 00:0CFE: 84 07                        dw      DUP
  1639 00:0D00: 14 05                        dw      ZERO
  Wed Mar 16 2016 22:39                                                                                                    Page 35


  1640 00:0D02: 14 05                        dw      ZERO
  1641 00:0D04: D2 07                        dw      ROT
  1642 00:0D06: 79 11                        dw      COUNT
  1643 00:0D08: 39 0D                        dw      QUERY_SIGN
  1644 00:0D0A: 48 08                        dw      TO_R
  1645 00:0D0C: 80 0D                        dw      TO_NUMBER
  1646 00:0D0E: 6F 12 1E 0D                  dw      QUERY_BRANCH,QNUM_1
  1647 00:0D12: 81 08                        dw      R_FROM
  1648 00:0D14: F1 06                        dw      TWO_DROP
  1649 00:0D16: F1 06                        dw      TWO_DROP
  1650 00:0D18: 14 05                        dw      ZERO
  1651 00:0D1A: 4D 12 2E 0D                  dw      BRANCH,QNUM_3
  1652 00:0D1E: F1 06        QNUM_1:         dw      TWO_DROP
  1653 00:0D20: 99 07                        dw      NIP
  1654 00:0D22: 81 08                        dw      R_FROM
  1655 00:0D24: 6F 12 2A 0D                  dw      QUERY_BRANCH,QNUM_2
  1656 00:0D28: 63 09                        dw      NEGATE
  1657 00:0D2A: A5 12 FF FF  QNUM_2:         dw      DO_LITERAL,-1
  1658 00:0D2E: A7 0C        QNUM_3:         dw      EXIT
  1659                        
  1660                        ; ?SIGN
  1661                        ;
  1662                        ;   OVER C@                 -- adr n c
  1663                        ;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else 0
  1664                        ;   DUP IF 1+               -- +=0, -=+2
  1665                        ;       >R 1 /STRING R>     -- adr' n' f
  1666                        ;   THEN ;
  1667                        
  1668 00:0D30: F3 0C 00 04                  HEADER  4,"?SIGN",NORMAL
       00:0D34: 3F 53 49 47 
       00:0D38: 4E 
  1669 00:0D39: 20 AF 11     QUERY_SIGN:     jsr     DO_COLON
  1670 00:0D3C: A7 07                        dw      OVER
  1671 00:0D3E: 52 06                        dw      C_FETCH
  1672 00:0D40: A5 12 2D 00                  dw      DO_LITERAL,'-'
  1673 00:0D44: E3 08                        dw      MINUS
  1674 00:0D46: 84 07                        dw      DUP
  1675 00:0D48: 4F 09                        dw      ABS
  1676 00:0D4A: A5 12 01 00                  dw      DO_LITERAL,1
  1677 00:0D4E: 3A 0B                        dw      EQUAL
  1678 00:0D50: 8E 0B                        dw      AND
  1679 00:0D52: 84 07                        dw      DUP
  1680 00:0D54: 6F 12 64 0D                  dw      QUERY_BRANCH,QSIGN_1
  1681 00:0D58: 13 09                        dw      ONE_PLUS
  1682 00:0D5A: 48 08                        dw      TO_R
  1683 00:0D5C: A5 12 01 00                  dw      DO_LITERAL,1
  1684 00:0D60: F1 10                        dw      SLASH_STRING
  1685 00:0D62: 81 08                        dw      R_FROM
  1686 00:0D64: A7 0C        QSIGN_1:        dw      EXIT
  1687                        
  1688                        ; >COUNTED
  1689                        ;
  1690                        ; 2DUP C! CHAR+ SWAP CMOVE
  1691                        
  1692 00:0D66: 20 AF 11     TO_COUNTED:     jsr     DO_COLON
  1693 00:0D69: 05 07                        dw      TWO_DUP
  1694 00:0D6B: 21 06                        dw      C_STORE
  1695 00:0D6D: C0 06                        dw      CHAR_PLUS
  Wed Mar 16 2016 22:39                                                                                                    Page 36


  1696 00:0D6F: BD 07                        dw      SWAP
  1697 00:0D71: 0B 11                        dw      CMOVE
  1698 00:0D73: A7 0C                        dw      EXIT
  1699                        
  1700                        ; >NUMBER
  1701                        ;   BEGIN
  1702                        ;   DUP WHILE
  1703                        ;       OVER C@ DIGIT?
  1704                        ;       0= IF DROP EXIT THEN
  1705                        ;       >R 2SWAP BASE @ UD*
  1706                        ;       R> M+ 2SWAP
  1707                        ;       1 /STRING
  1708                        ;   REPEAT ;
  1709                        
  1710 00:0D75: 33 0D 00 07                  HEADER  7,">NUMBER",NORMAL
       00:0D79: 3E 4E 55 4D 
       00:0D7D: 42 45 52 
  1711 00:0D80: 20 AF 11     TO_NUMBER:      jsr     DO_COLON
  1712 00:0D83: 84 07        TO_NUM_1:       dw      DUP
  1713 00:0D85: 6F 12 B3 0D                  dw      QUERY_BRANCH,TO_NUM_3
  1714 00:0D89: A7 07                        dw      OVER
  1715 00:0D8B: 52 06                        dw      C_FETCH
  1716 00:0D8D: 32 0E                        dw      DIGIT_QUERY
  1717 00:0D8F: D7 0A                        dw      ZERO_EQUAL
  1718 00:0D91: 6F 12 99 0D                  dw      QUERY_BRANCH,TO_NUM_2
  1719 00:0D95: 73 07                        dw      DROP
  1720 00:0D97: A7 0C                        dw      EXIT
  1721 00:0D99: 48 08        TO_NUM_2:       dw      TO_R
  1722 00:0D9B: 3F 07                        dw      TWO_SWAP
  1723 00:0D9D: 88 04                        dw      BASE
  1724 00:0D9F: FF 05                        dw      FETCH
  1725 00:0DA1: 23 0A                        dw      UD_STAR
  1726 00:0DA3: 81 08                        dw      R_FROM
  1727 00:0DA5: 51 0A                        dw      M_PLUS
  1728 00:0DA7: 3F 07                        dw      TWO_SWAP
  1729 00:0DA9: A5 12 01 00                  dw      DO_LITERAL,1
  1730 00:0DAD: F1 10                        dw      SLASH_STRING
  1731 00:0DAF: 4D 12 83 0D                  dw      BRANCH,TO_NUM_1
  1732 00:0DB3: A7 0C        TO_NUM_3:       dw      EXIT
  1733                        
  1734                        ; ACCEPT ( c-addr +n1 -- +n2 )
  1735                        ;
  1736                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  1737                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  1738                        ; received. A program that depends on the presence or absence of non-graphic
  1739                        ; characters in the string has an environmental dependency. The editing
  1740                        ; functions, if any, that the system performs in order to construct the string
  1741                        ; are implementation-defined.
  1742                        ;
  1743                        ; Input terminates when an implementation-defined line terminator is received.
  1744                        ; When input terminates, nothing is appended to the string, and the display is
  1745                        ; maintained in an implementation-defined way.
  1746                        ;
  1747                        ; +n2 is the length of the string stored at c-addr.
  1748                        ;
  1749                        ;   OVER + 1- OVER      -- sa ea a
  1750                        ;   BEGIN KEY           -- sa ea a c
  1751                        ;   DUP 0D <> WHILE
  Wed Mar 16 2016 22:39                                                                                                    Page 37


  1752                        ;     DUP 8 = OVER 127 = OR IF
  1753                        ;       DROP 1-
  1754                        ;       >R OVER R> UMAX
  1755                        ;       8 EMIT SPACE 8 EMIT
  1756                        ;     ELSE
  1757                        ;       DUP EMIT        -- sa ea a c
  1758                        ;       OVER C! 1+ OVER UMIN
  1759                        ;     THEN              -- sa ea a
  1760                        ;   REPEAT              -- sa ea a c
  1761                        ;   DROP NIP SWAP - ;
  1762                        
  1763 00:0DB5: 78 0D 00 06                  HEADER  6,"ACCEPT",NORMAL
       00:0DB9: 41 43 43 45 
       00:0DBD: 50 54 
  1764 00:0DBF: 20 AF 11     ACCEPT:         jsr     DO_COLON
  1765 00:0DC2: A7 07                        dw      OVER
  1766 00:0DC4: CD 08                        dw      PLUS
  1767 00:0DC6: 21 09                        dw      ONE_MINUS
  1768 00:0DC8: A7 07                        dw      OVER
  1769 00:0DCA: A3 13        ACCEPT_1:       dw      KEY
  1770 00:0DCC: 84 07                        dw      DUP
  1771 00:0DCE: A5 12 0D 00                  dw      DO_LITERAL,$0D
  1772 00:0DD2: 21 0B                        dw      NOT_EQUAL
  1773 00:0DD4: 6F 12 1E 0E                  dw      QUERY_BRANCH,ACCEPT_4
  1774 00:0DD8: 84 07                        dw      DUP
  1775 00:0DDA: A5 12 08 00                  dw      DO_LITERAL,$08
  1776 00:0DDE: 3A 0B                        dw      EQUAL
  1777 00:0DE0: A7 07                        dw      OVER
  1778 00:0DE2: A5 12 7F 00                  dw      DO_LITERAL,$7f
  1779 00:0DE6: 3A 0B                        dw      EQUAL
  1780 00:0DE8: E7 0B                        dw      OR
  1781 00:0DEA: 6F 12 0C 0E                  dw      QUERY_BRANCH,ACCEPT_2
  1782 00:0DEE: 73 07                        dw      DROP
  1783 00:0DF0: 21 09                        dw      ONE_MINUS
  1784 00:0DF2: 48 08                        dw      TO_R
  1785 00:0DF4: A7 07                        dw      OVER
  1786 00:0DF6: 81 08                        dw      R_FROM
  1787 00:0DF8: 79 09                        dw      UMAX
  1788 00:0DFA: A5 12 08 00                  dw      DO_LITERAL,8
  1789 00:0DFE: 8D 13                        dw      EMIT
  1790 00:0E00: BF 13                        dw      SPACE
  1791 00:0E02: A5 12 08 00                  dw      DO_LITERAL,8
  1792 00:0E06: 8D 13                        dw      EMIT
  1793 00:0E08: 4D 12 1A 0E                  dw      BRANCH,ACCEPT_3
  1794 00:0E0C: 84 07        ACCEPT_2:       dw      DUP
  1795 00:0E0E: 8D 13                        dw      EMIT
  1796 00:0E10: A7 07                        dw      OVER
  1797 00:0E12: 21 06                        dw      C_STORE
  1798 00:0E14: 13 09                        dw      ONE_PLUS
  1799 00:0E16: A7 07                        dw      OVER
  1800 00:0E18: 8D 09                        dw      UMIN
  1801 00:0E1A: 4D 12 CA 0D  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  1802 00:0E1E: 73 07        ACCEPT_4:       dw      DROP
  1803 00:0E20: 99 07                        dw      NIP
  1804 00:0E22: BD 07                        dw      SWAP
  1805 00:0E24: E3 08                        dw      MINUS
  1806 00:0E26: A7 0C                        dw      EXIT
  1807                        
  Wed Mar 16 2016 22:39                                                                                                    Page 38


  1808                        ; DIGIT?
  1809                        ;
  1810                        ;   [ HEX ] DUP 39 > 100 AND +     silly looking
  1811                        ;   DUP 140 > 107 AND -   30 -     but it works!
  1812                        ;   DUP BASE @ U< ;
  1813                        
  1814 00:0E28: B8 0D 00 06                  HEADER  6,"DIGIT?",NORMAL
       00:0E2C: 44 49 47 49 
       00:0E30: 54 3F 
  1815 00:0E32: 20 AF 11     DIGIT_QUERY:    jsr     DO_COLON
  1816 00:0E35: 84 07                        dw      DUP
  1817 00:0E37: A5 12 39 00                  dw      DO_LITERAL,'9'
  1818 00:0E3B: 53 0B                        dw      GREATER
  1819 00:0E3D: A5 12 00 01                  dw      DO_LITERAL,$100
  1820 00:0E41: 8E 0B                        dw      AND
  1821 00:0E43: CD 08                        dw      PLUS
  1822 00:0E45: 84 07                        dw      DUP
  1823 00:0E47: A5 12 40 01                  dw      DO_LITERAL,$140
  1824 00:0E4B: 53 0B                        dw      GREATER
  1825 00:0E4D: A5 12 07 01                  dw      DO_LITERAL,$107
  1826 00:0E51: 8E 0B                        dw      AND
  1827 00:0E53: E3 08                        dw      MINUS
  1828 00:0E55: A5 12 30 00                  dw      DO_LITERAL,'0'
  1829 00:0E59: E3 08                        dw      MINUS
  1830 00:0E5B: 84 07                        dw      DUP
  1831 00:0E5D: 88 04                        dw      BASE
  1832 00:0E5F: FF 05                        dw      FETCH
  1833 00:0E61: 62 0B                        dw      U_LESS
  1834 00:0E63: A7 0C                        dw      EXIT
  1835                        
  1836                        ; EVALUATE ( i*x c-addr u -- j*x )
  1837                        ;
  1838                        ; Save the current input source specification. Store minus-one (-1) in
  1839                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  1840                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  1841                        ; parse area is empty, restore the prior input source specification. Other
  1842                        ; stack effects are due to the words EVALUATEd.
  1843                        ;
  1844                        ;   >R >R SAVE-INPUT
  1845                        ;   -1 (SOURCE-ID) !
  1846                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  1847                        ;   INTERPRET
  1848                        ;   RESTORE-INPUT DROP
  1849                        
  1850 00:0E65: 2B 0E 00 08                  HEADER  8,"EVALUATE",NORMAL
       00:0E69: 45 56 41 4C 
       00:0E6D: 55 41 54 45 
  1851 00:0E71: 20 AF 11     EVALUATE:       jsr     DO_COLON
  1852 00:0E74: 48 08                        dw      TO_R
  1853 00:0E76: 48 08                        dw      TO_R
  1854 00:0E78: 15 10                        dw      SAVE_INPUT
  1855 00:0E7A: 81 08                        dw      R_FROM
  1856 00:0E7C: 81 08                        dw      R_FROM
  1857 00:0E7E: 52 05                        dw      TRUE
  1858 00:0E80: F0 04                        dw      SOURCEID
  1859 00:0E82: 91 05                        dw      STORE
  1860 00:0E84: 14 05                        dw      ZERO
  1861 00:0E86: 7B 04                        dw      TO_IN
  Wed Mar 16 2016 22:39                                                                                                    Page 39


  1862 00:0E88: 91 05                        dw      STORE
  1863 00:0E8A: D0 04                        dw      LENGTH
  1864 00:0E8C: 91 05                        dw      STORE
  1865 00:0E8E: A5 04                        dw      BUFFER
  1866 00:0E90: 91 05                        dw      STORE
  1867 00:0E92: A7 0E                        dw      INTERPRET
  1868 00:0E94: C6 0F                        dw      RESTORE_INPUT
  1869 00:0E96: 73 07                        dw      DROP
  1870 00:0E98: A7 0C                        dw      EXIT
  1871                        
  1872                        ; INTERPRET ( -- )
  1873                        ;
  1874                        ;
  1875                        ;   BEGIN
  1876                        ;   BL WORD DUP C@ WHILE        -- textadr
  1877                        ;       FIND                    -- a 0/1/-1
  1878                        ;       ?DUP IF                 -- xt 1/-1
  1879                        ;           1+ STATE @ 0= OR    immed or interp?
  1880                        ;           IF EXECUTE ELSE , THEN
  1881                        ;       ELSE                    -- textadr
  1882                        ;           ?NUMBER
  1883                        ;           IF POSTPONE LITERAL     converted ok
  1884                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  1885                        ;           THEN
  1886                        ;       THEN
  1887                        ;   REPEAT DROP ;
  1888                        
  1889 00:0E9A: 68 0E 00 09                  HEADER  9,"INTERPRET",NORMAL
       00:0E9E: 49 4E 54 45 
       00:0EA2: 52 50 52 45 
       00:0EA6: 54 
  1890 00:0EA7: 20 AF 11     INTERPRET:      jsr     DO_COLON
  1891 00:0EAA: 26 05        INTERPRET_1:    dw      BL
  1892 00:0EAC: 8D 10                        dw      WORD
  1893 00:0EAE: 84 07                        dw      DUP
  1894 00:0EB0: 52 06                        dw      C_FETCH
  1895 00:0EB2: 6F 12 F6 0E                  dw      QUERY_BRANCH,INTERPRET_7
  1896 00:0EB6: 02 0F                        dw      FIND
  1897 00:0EB8: 61 07                        dw      QUERY_DUP
  1898 00:0EBA: 6F 12 D8 0E                  dw      QUERY_BRANCH,INTERPRET_4
  1899 00:0EBE: 13 09                        dw      ONE_PLUS
  1900 00:0EC0: FE 04                        dw      STATE
  1901 00:0EC2: FF 05                        dw      FETCH
  1902 00:0EC4: D7 0A                        dw      ZERO_EQUAL
  1903 00:0EC6: E7 0B                        dw      OR
  1904 00:0EC8: 6F 12 D2 0E                  dw      QUERY_BRANCH,INTERPRET_2
  1905 00:0ECC: 96 0C                        dw      EXECUTE
  1906 00:0ECE: 4D 12 D4 0E                  dw      BRANCH,INTERPRET_3
  1907 00:0ED2: BF 05        INTERPRET_2:    dw      COMMA
  1908 00:0ED4: 4D 12 F2 0E  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  1909 00:0ED8: FB 0C        INTERPRET_4:    dw      QUERY_NUMBER
  1910 00:0EDA: 6F 12 E4 0E                  dw      QUERY_BRANCH,INTERPRET_5
  1911 00:0EDE: 8B 12                        dw      LITERAL
  1912 00:0EE0: 4D 12 F2 0E                  dw      BRANCH,INTERPRET_6
  1913 00:0EE4: 79 11        INTERPRET_5:    dw      COUNT
  1914 00:0EE6: F1 13                        dw      TYPE
  1915 00:0EE8: A5 12 3F 00                  dw      DO_LITERAL,$3f
  1916 00:0EEC: 8D 13                        dw      EMIT
  Wed Mar 16 2016 22:39                                                                                                    Page 40


  1917 00:0EEE: 74 13                        dw      CR
  1918 00:0EF0: 43 0C                        dw      ABORT
  1919 00:0EF2: 4D 12 AA 0E  INTERPRET_6     dw      BRANCH,INTERPRET_1
  1920 00:0EF6: 73 07        INTERPRET_7:    dw      DROP
  1921 00:0EF8: A7 0C                        dw      EXIT
  1922                        
  1923                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  1924                        ;
  1925                        ; Find the definition named in the counted string at c-addr. If the definition
  1926                        ; is not found, return c-addr and zero. If the definition is found, return its
  1927                        ; execution token xt. If the definition is immediate, also return one (1),
  1928                        ; otherwise also return minus-one (-1). For a given string, the values returned
  1929                        ; by FIND while compiling may differ from those returned while not compiling.
  1930                        ;
  1931                        ;   LATEST @ BEGIN             -- a nfa
  1932                        ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
  1933                        ;       S=                     -- a nfa f
  1934                        ;       DUP IF
  1935                        ;           DROP
  1936                        ;           NFA>LFA @ DUP      -- a link link
  1937                        ;       THEN
  1938                        ;   0= UNTIL                   -- a nfa  OR  a 0
  1939                        ;   DUP IF
  1940                        ;       NIP DUP NFA>CFA        -- nfa xt
  1941                        ;       SWAP IMMED?            -- xt iflag
  1942                        ;       0= 1 OR                -- xt 1/-1
  1943                        ;   THEN ;
  1944                        
  1945 00:0EFA: 9D 0E 00 04                  HEADER  4,"FIND",NORMAL
       00:0EFE: 46 49 4E 44 
  1946 00:0F02: 20 AF 11     FIND:           jsr     DO_COLON
  1947 00:0F05: BF 04                        dw      LATEST
  1948 00:0F07: FF 05                        dw      FETCH
  1949 00:0F09: 05 07        FIND1:          dw      TWO_DUP
  1950 00:0F0B: A7 07                        dw      OVER
  1951 00:0F0D: 52 06                        dw      C_FETCH
  1952 00:0F0F: C0 06                        dw      CHAR_PLUS
  1953 00:0F11: DD 0F                        dw      S_EQUAL
  1954 00:0F13: 84 07                        dw      DUP
  1955 00:0F15: 6F 12 21 0F                  dw      QUERY_BRANCH,FIND2
  1956 00:0F19: 73 07                        dw      DROP
  1957 00:0F1B: 73 0F                        dw      NFA_TO_LFA
  1958 00:0F1D: FF 05                        dw      FETCH
  1959 00:0F1F: 84 07                        dw      DUP
  1960 00:0F21: D7 0A        FIND2:          dw      ZERO_EQUAL
  1961 00:0F23: 6F 12 09 0F                  dw      QUERY_BRANCH,FIND1
  1962 00:0F27: 84 07                        dw      DUP
  1963 00:0F29: 6F 12 3F 0F                  dw      QUERY_BRANCH,FIND3
  1964 00:0F2D: 99 07                        dw      NIP
  1965 00:0F2F: 84 07                        dw      DUP
  1966 00:0F31: 5F 0F                        dw      NFA_TO_CFA
  1967 00:0F33: BD 07                        dw      SWAP
  1968 00:0F35: 4B 0F                        dw      IMMED_QUERY
  1969 00:0F37: D7 0A                        dw      ZERO_EQUAL
  1970 00:0F39: A5 12 01 00                  dw      DO_LITERAL,1
  1971 00:0F3D: E7 0B                        dw      OR
  1972 00:0F3F: A7 0C        FIND3:          dw      EXIT
  1973                        
  Wed Mar 16 2016 22:39                                                                                                    Page 41


  1974                        ; IMMED? ( nfa -- f )
  1975                        
  1976 00:0F41: FD 0E 00 06                  HEADER  6,"IMMED?",NORMAL
       00:0F45: 49 4D 4D 45 
       00:0F49: 44 3F 
  1977 00:0F4B: 20 AF 11     IMMED_QUERY:    jsr     DO_COLON
  1978 00:0F4E: 21 09                        dw      ONE_MINUS
  1979 00:0F50: 52 06                        dw      C_FETCH
  1980 00:0F52: A7 0C                        dw      EXIT
  1981                        
  1982                        ; NFA>CFA ( nfa -- cfa )
  1983                        
  1984 00:0F54: 44 0F 00 07                  HEADER  7,"NFA>CFA",NORMAL
       00:0F58: 4E 46 41 3E 
       00:0F5C: 43 46 41 
  1985 00:0F5F: 20 AF 11     NFA_TO_CFA:     jsr     DO_COLON
  1986 00:0F62: 79 11                        dw      COUNT
  1987 00:0F64: CD 08                        dw      PLUS
  1988 00:0F66: A7 0C                        dw      EXIT
  1989                        
  1990                        ; NFA>LFA ( nfa -- lfa )
  1991                        
  1992 00:0F68: 57 0F 00 07                  HEADER  7,"NFA>LFA",NORMAL
       00:0F6C: 4E 46 41 3E 
       00:0F70: 4C 46 41 
  1993 00:0F73: 20 AF 11     NFA_TO_LFA:     jsr     DO_COLON
  1994 00:0F76: A5 12 03 00                  dw      DO_LITERAL,3
  1995 00:0F7A: E3 08                        dw      MINUS
  1996 00:0F7C: A7 0C                        dw      EXIT
  1997                        
  1998                        ; REFILL ( -- flag )
  1999                        ;
  2000                        ; Attempt to fill the input buffer from the input source, returning a true flag
  2001                        ; if successful.
  2002                        ;
  2003                        ; When the input source is the user input device, attempt to receive input into
  2004                        ; the terminal input buffer. If successful, make the result the input buffer,
  2005                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  2006                        ; is considered successful. If there is no input available from the current
  2007                        ; input source, return false.
  2008                        ;
  2009                        ; When the input source is a string from EVALUATE, return false and perform no
  2010                        ; other action.
  2011                        ;
  2012                        ;   SOURCE-ID 0= IF
  2013                        ;     TIB DUP #TIB @ ACCEPT SPACE
  2014                        ;     LENGTH ! BUFFER !
  2015                        ;     0 >IN ! TRUE EXIT
  2016                        ;   THEN
  2017                        ;   FALSE
  2018                        
  2019 00:0F7E: 6B 0F 00 06                  HEADER  6,"REFILL",NORMAL
       00:0F82: 52 45 46 49 
       00:0F86: 4C 4C 
  2020 00:0F88: 20 AF 11     REFILL:         jsr     DO_COLON
  2021 00:0F8B: 7C 10                        dw      SOURCE_ID
  2022 00:0F8D: D7 0A                        dw      ZERO_EQUAL
  2023 00:0F8F: 6F 12 B1 0F                  dw      QUERY_BRANCH,REFILL_1
  Wed Mar 16 2016 22:39                                                                                                    Page 42


  2024 00:0F93: 0A 05                        dw      TIB
  2025 00:0F95: 84 07                        dw      DUP
  2026 00:0F97: 6D 04                        dw      HASH_TIB
  2027 00:0F99: FF 05                        dw      FETCH
  2028 00:0F9B: BF 0D                        dw      ACCEPT
  2029 00:0F9D: BF 13                        dw      SPACE
  2030 00:0F9F: D0 04                        dw      LENGTH
  2031 00:0FA1: 91 05                        dw      STORE
  2032 00:0FA3: A5 04                        dw      BUFFER
  2033 00:0FA5: 91 05                        dw      STORE
  2034 00:0FA7: 14 05                        dw      ZERO
  2035 00:0FA9: 7B 04                        dw      TO_IN
  2036 00:0FAB: 91 05                        dw      STORE
  2037 00:0FAD: 52 05                        dw      TRUE
  2038 00:0FAF: A7 0C                        dw      EXIT
  2039 00:0FB1: 3E 05        REFILL_1:       dw      FALSE
  2040 00:0FB3: A7 0C                        dw      EXIT
  2041                        
  2042                        ; RESTORE-INPUT
  2043                        ;
  2044                        ;   >IN ! (LENGTH) ! BUFFER !
  2045                        ;   SOURCEID !
  2046                        ;   TRUE
  2047                        
  2048 00:0FB5: 81 0F 00 0D                  HEADER  13,"RESTORE-INPUT",NORMAL
       00:0FB9: 52 45 53 54 
       00:0FBD: 4F 52 45 2D 
       00:0FC1: 49 4E 50 55 
       00:0FC5: 54 
  2049 00:0FC6: 20 AF 11     RESTORE_INPUT   jsr     DO_COLON
  2050 00:0FC9: 7B 04                        dw      TO_IN
  2051 00:0FCB: 91 05                        dw      STORE
  2052 00:0FCD: D0 04                        dw      LENGTH
  2053 00:0FCF: 91 05                        dw      STORE
  2054 00:0FD1: A5 04                        dw      BUFFER
  2055 00:0FD3: 91 05                        dw      STORE
  2056 00:0FD5: F0 04                        dw      SOURCEID
  2057 00:0FD7: 91 05                        dw      STORE
  2058 00:0FD9: 52 05                        dw      TRUE
  2059 00:0FDB: A7 0C                        dw      EXIT
  2060                        
  2061                        ; S= ( c-addr1 caddr2 u -- n)
  2062                        ;
  2063                        ; Misnamed, more like C's strncmp. Note that counted length bytes are compared!
  2064                        
  2065                        S_EQUAL:
  2066 00:0FDD: 5A                           phy
  2067 00:0FDE: A6 01                        ldx     <1                      ; Fetch maximum length
  2068 00:0FE0: F0 14                        beq     S_EQUAL_3
  2069 00:0FE2: A0 00 00                     ldy     #0
  2070 00:0FE5: E2 20                        short_a
  2071                        S_EQUAL_1:
  2072 00:0FE7: B1 05                        lda     (5),y                   ; Compare bytes
  2073 00:0FE9: D1 03                        cmp     (3),y
  2074 00:0FEB: D0 06                        bne     S_EQUAL_2
  2075 00:0FED: C8                           iny
  2076 00:0FEE: CA                           dex                             ; End of strings?
  2077 00:0FEF: D0 F6                        bne     S_EQUAL_1               ; No
  Wed Mar 16 2016 22:39                                                                                                    Page 43


  2078 00:0FF1: 80 03                        bra     S_EQUAL_3               ; Yes. must be the same
  2079                        S_EQUAL_2:
  2080 00:0FF3: A2 FF FF                     ldx     #$ffff                  ; Difference found
  2081                        S_EQUAL_3:
  2082 00:0FF6: C2 20                        long_a
  2083 00:0FF8: 7B                           tdc                             ; Clean up the stack
  2084 00:0FF9: 1A                           inc     a
  2085 00:0FFA: 1A                           inc     a
  2086 00:0FFB: 1A                           inc     a
  2087 00:0FFC: 1A                           inc     a
  2088 00:0FFD: 5B                           tcd
  2089 00:0FFE: 86 01                        stx     <1                      ; Save the flag
  2090 00:1000: 7A                           ply
  2091 00:1001: BB C8 C8 7C                  CONTINUE
       00:1005: 00 00 
  2092                        
  2093                        ; SAVE-INPUT
  2094                        
  2095 00:1007: B8 0F 00 0A                  HEADER  10,"SAVE-INPUT",NORMAL
       00:100B: 53 41 56 45 
       00:100F: 2D 49 4E 50 
       00:1013: 55 54 
  2096 00:1015: 20 AF 11     SAVE_INPUT:     jsr     DO_COLON
  2097 00:1018: F0 04                        dw      SOURCEID
  2098 00:101A: FF 05                        dw      FETCH
  2099 00:101C: A5 04                        dw      BUFFER
  2100 00:101E: FF 05                        dw      FETCH
  2101 00:1020: D0 04                        dw      LENGTH
  2102 00:1022: FF 05                        dw      FETCH
  2103 00:1024: 7B 04                        dw      TO_IN
  2104 00:1026: FF 05                        dw      FETCH
  2105 00:1028: A7 0C                        dw      EXIT
  2106                        
  2107                        ; SCAN ( c-addr n c == c-addr' n' )
  2108                        
  2109                        SCAN:
  2110                        SCAN_1:
  2111 00:102A: A5 03                        lda     <3                      ; Any data left to scan?
  2112 00:102C: F0 10                        beq     SCAN_2                  ; No.
  2113 00:102E: A5 01                        lda     <1                      ; Fetch and compare with scan
  2114 00:1030: E2 20                        short_a
  2115 00:1032: D2 05                        cmp     (5)
  2116 00:1034: C2 20                        long_a
  2117 00:1036: F0 06                        beq     SCAN_2
  2118 00:1038: E6 05                        inc     <5
  2119 00:103A: C6 03                        dec     <3
  2120 00:103C: 80 EC                        bra     SCAN_1
  2121                        SCAN_2:
  2122 00:103E: 4C 73 07                     jmp     DROP                    ; Drop the character
  2123                        
  2124                        ; SKIP ( c-addr n c == c-addr' n' )
  2125                        ;
  2126                        
  2127                        SKIP:
  2128 00:1041: A5 03        SKIP_1:         lda     <3                      ; Any data left to skip over?
  2129 00:1043: F0 10                        beq     SKIP_2                  ; No.
  2130 00:1045: A5 01                        lda     <1                      ; Fetch and compare with skip
  2131 00:1047: E2 20                        short_a
  Wed Mar 16 2016 22:39                                                                                                    Page 44


  2132 00:1049: D2 05                        cmp     (5)
  2133 00:104B: C2 20                        long_a
  2134 00:104D: D0 06                        bne     SKIP_2                  ; Cannot be skipped
  2135 00:104F: E6 05                        inc     <5                      ; Bump data address
  2136 00:1051: C6 03                        dec     <3                      ; and update length
  2137 00:1053: 80 EC                        bra     SKIP_1                  ; And repeat
  2138                        SKIP_2:
  2139 00:1055: 4C 73 07                     jmp     DROP                    ; Drop the character
  2140                        
  2141                        ; SOURCE ( -- c-addr u )
  2142                        ;
  2143                        ; c-addr is the address of, and u is the number of characters in, the input
  2144                        ; buffer.
  2145                        ;
  2146                        ; In this implementation it is defined as
  2147                        ;
  2148                        ;   BUFFER @ LENGTH @
  2149                        
  2150 00:1058: 0A 10 00 06                  HEADER  6,"SOURCE",NORMAL
       00:105C: 53 4F 55 52 
       00:1060: 43 45 
  2151 00:1062: 20 AF 11     SOURCE:         jsr     DO_COLON
  2152 00:1065: A5 04                        dw      BUFFER
  2153 00:1067: FF 05                        dw      FETCH
  2154 00:1069: D0 04                        dw      LENGTH
  2155 00:106B: FF 05                        dw      FETCH
  2156 00:106D: A7 0C                        dw      EXIT
  2157                        
  2158                        ; SOURCE-ID ( -- 0 | -1 )
  2159                        ;
  2160                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  2161                        ; device.
  2162                        
  2163 00:106F: 5B 10 00 09                  HEADER  9,"SOURCE-ID",NORMAL
       00:1073: 53 4F 55 52 
       00:1077: 43 45 2D 49 
       00:107B: 44 
  2164 00:107C: 20 AF 11     SOURCE_ID:      jsr     DO_COLON
  2165 00:107F: F0 04                        dw      SOURCEID
  2166 00:1081: FF 05                        dw      FETCH
  2167 00:1083: A7 0C                        dw      EXIT
  2168                        
  2169                        ; WORD
  2170                        ;
  2171                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  2172                        ;   DUP >R   ROT SKIP           -- c adr' n'
  2173                        ;   OVER >R  ROT SCAN           -- adr" n"
  2174                        ;   DUP IF CHAR- THEN        skip trailing delim.
  2175                        ;   R> R> ROT -   >IN +!        update >IN offset
  2176                        ;   TUCK -                      -- adr' N
  2177                        ;   HERE >counted               --
  2178                        ;   HERE                        -- a
  2179                        ;   BL OVER COUNT + C! ;    append trailing blank
  2180                        
  2181 00:1085: 72 10 00 04                  HEADER  4,"WORD",NORMAL
       00:1089: 57 4F 52 44 
  2182 00:108D: 20 AF 11     WORD:           jsr     DO_COLON
  2183 00:1090: 84 07                        dw      DUP
  Wed Mar 16 2016 22:39                                                                                                    Page 45


  2184 00:1092: 62 10                        dw      SOURCE
  2185 00:1094: 7B 04                        dw      TO_IN
  2186 00:1096: FF 05                        dw      FETCH
  2187 00:1098: F1 10                        dw      SLASH_STRING
  2188 00:109A: 84 07                        dw      DUP
  2189 00:109C: 48 08                        dw      TO_R
  2190 00:109E: D2 07                        dw      ROT
  2191 00:10A0: 41 10                        dw      SKIP
  2192 00:10A2: A7 07                        dw      OVER
  2193 00:10A4: 48 08                        dw      TO_R
  2194 00:10A6: D2 07                        dw      ROT
  2195 00:10A8: 2A 10                        dw      SCAN
  2196 00:10AA: 84 07                        dw      DUP
  2197 00:10AC: 6F 12 B2 10                  dw      QUERY_BRANCH,WORD_1
  2198 00:10B0: D1 06                        dw      CHAR_MINUS
  2199 00:10B2: 81 08        WORD_1:         dw      R_FROM
  2200 00:10B4: 81 08                        dw      R_FROM
  2201 00:10B6: D2 07                        dw      ROT
  2202 00:10B8: E3 08                        dw      MINUS
  2203 00:10BA: 7B 04                        dw      TO_IN
  2204 00:10BC: A7 05                        dw      PLUS_STORE
  2205 00:10BE: EC 07                        dw      TUCK
  2206 00:10C0: E3 08                        dw      MINUS
  2207 00:10C2: 6A 06                        dw      HERE
  2208 00:10C4: 66 0D                        dw      TO_COUNTED
  2209 00:10C6: 6A 06                        dw      HERE
  2210 00:10C8: 26 05                        dw      BL
  2211 00:10CA: A7 07                        dw      OVER
  2212 00:10CC: 79 11                        dw      COUNT
  2213 00:10CE: CD 08                        dw      PLUS
  2214 00:10D0: 21 06                        dw      C_STORE
  2215 00:10D2: A7 0C                        dw      EXIT
  2216                        
  2217                        ;==============================================================================
  2218                        ; String Words
  2219                        ;------------------------------------------------------------------------------
  2220                        
  2221                        ; -TRAILING
  2222                        
  2223 00:10D4: 88 10 00 09                  HEADER  9,"-TRAILING",NORMAL
       00:10D8: 2D 54 52 41 
       00:10DC: 49 4C 49 4E 
       00:10E0: 47 
  2224 00:10E1: 20 AF 11     DASH_TRAILING:  jsr     DO_COLON
  2225                        
  2226 00:10E4: A7 0C                        dw      EXIT
  2227                        
  2228                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  2229                        ;
  2230                        ; Adjust the character string at c-addr1 by n characters. The resulting
  2231                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  2232                        ; characters and is u1 minus n characters long.
  2233                        ;
  2234                        ;   ROT OVER + ROT ROT -
  2235                        
  2236 00:10E6: D7 10 00 07                  HEADER  7,"/STRING",NORMAL
       00:10EA: 2F 53 54 52 
       00:10EE: 49 4E 47 
  Wed Mar 16 2016 22:39                                                                                                    Page 46


  2237 00:10F1: 20 AF 11     SLASH_STRING:   jsr     DO_COLON
  2238 00:10F4: D2 07                        dw      ROT
  2239 00:10F6: A7 07                        dw      OVER
  2240 00:10F8: CD 08                        dw      PLUS
  2241 00:10FA: D2 07                        dw      ROT
  2242 00:10FC: D2 07                        dw      ROT
  2243 00:10FE: E3 08                        dw      MINUS
  2244 00:1100: A7 0C                        dw      EXIT
  2245                        
  2246                        ; BLANK
  2247                        
  2248                        ; CMOVE ( c-addr1 c-addr2 u -- )
  2249                        ;
  2250                        ; If u is greater than zero, copy u consecutive characters from the data space
  2251                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2252                        ; character from lower addresses to higher addresses.
  2253                        
  2254 00:1102: E9 10 00 05                  HEADER  5,"CMOVE",NORMAL
       00:1106: 43 4D 4F 56 
       00:110A: 45 
  2255                        CMOVE:
  2256 00:110B: 5A                           phy
  2257 00:110C: A6 01                        ldx     <1                      ; Any characters to move?
  2258 00:110E: F0 0F                        beq     CMOVE_2                 ; No
  2259 00:1110: A0 00 00                     ldy     #0
  2260 00:1113: E2 20                        short_a
  2261                        CMOVE_1:                                        ; Transfer a byte
  2262 00:1115: B1 05                        lda     (5),y
  2263 00:1117: 91 03                        sta     (3),y
  2264 00:1119: C8                           iny
  2265 00:111A: CA                           dex                             ; Decrement count
  2266 00:111B: D0 F8                        bne     CMOVE_1                 ; .. and repeat until done
  2267 00:111D: C2 20                        long_a
  2268                        CMOVE_2:
  2269 00:111F: 7B                           tdc                             ; Clean up the stack
  2270 00:1120: 18                           clc
  2271 00:1121: 69 06 00                     adc     #6
  2272 00:1124: 5B                           tcd
  2273 00:1125: 7A                           ply
  2274 00:1126: BB C8 C8 7C                  CONTINUE                        ; Done
       00:112A: 00 00 
  2275                        
  2276                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  2277                        ;
  2278                        ; If u is greater than zero, copy u consecutive characters from the data space
  2279                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2280                        ; character from higher addresses to lower addresses.
  2281                        
  2282 00:112C: 05 11 00 06                  HEADER  6,"CMOVE>",NORMAL
       00:1130: 43 4D 4F 56 
       00:1134: 45 3E 
  2283                        CMOVE_GREATER:
  2284 00:1136: 5A                           phy
  2285 00:1137: A6 01                        ldx     <1                      ; Any characters to move?
  2286 00:1139: F0 0E                        beq     CMOVE_GT_2              ; No.
  2287 00:113B: A4 01                        ldy     <1
  2288 00:113D: E2 20                        short_a
  2289                        CMOVE_GT_1:
  Wed Mar 16 2016 22:39                                                                                                    Page 47


  2290 00:113F: 88                           dey                             ; Transfer a byte
  2291 00:1140: B1 05                        lda     (5),y
  2292 00:1142: 91 03                        sta     (3),y
  2293 00:1144: CA                           dex                             ; Decrement length
  2294 00:1145: D0 F8                        bne     CMOVE_GT_1              ; .. and repeat until done
  2295 00:1147: C2 20                        long_a
  2296                        CMOVE_GT_2:
  2297 00:1149: 7B                           tdc                             ; Clean up the stack
  2298 00:114A: 18                           clc
  2299 00:114B: 69 06 00                     adc     #6
  2300 00:114E: 5B                           tcd
  2301 00:114F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1153: 00 00 
  2302                        
  2303                        ; COMPARE ( c-addr1 u1 c-addr2 u2 -- n )
  2304                        ;
  2305                        ; Compare the string specified by c-addr1 u1 to the string specified by c-addr2
  2306                        ; u2. The strings are compared, beginning at the given addresses, character by
  2307                        ; character, up to the length of the shorter string or until a difference is
  2308                        ; found. If the two strings are identical, n is zero. If the two strings are
  2309                        ; identical up to the length of the shorter string, n is minus-one (-1) if u1
  2310                        ; is less than u2 and one (1) otherwise. If the two strings are not identical
  2311                        ; up to the length of the shorter string, n is minus-one (-1) if the first
  2312                        ; non-matching character in the string specified by c-addr1 u1 has a lesser
  2313                        ; numeric value than the corresponding character in the string specified by
  2314                        ; c-addr2 u2 and one (1) otherwise.
  2315                        
  2316 00:1155: 2F 11 00 07                  HEADER  7,"COMPARE",NORMAL
       00:1159: 43 4F 4D 50 
       00:115D: 41 52 45 
  2317                        COMPARE:
  2318 00:1160: 5A                           phy
  2319                        
  2320                        ; TODO
  2321                        
  2322 00:1161: 7B                           tdc
  2323 00:1162: 18                           clc
  2324 00:1163: 69 06 00                     adc     #6
  2325 00:1166: 5B                           tcd
  2326 00:1167: 86 01                        stx     <1
  2327 00:1169: 7A                           ply
  2328 00:116A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:116E: 00 00 
  2329                        
  2330                        ; COUNT
  2331                        ;
  2332                        ; DUP CHAR+ SWAP C@
  2333                        
  2334 00:1170: 58 11 00 05                  HEADER  5,"COUNT",NORMAL
       00:1174: 43 4F 55 4E 
       00:1178: 54 
  2335 00:1179: 20 AF 11     COUNT:          jsr     DO_COLON
  2336 00:117C: 84 07                        dw      DUP
  2337 00:117E: C0 06                        dw      CHAR_PLUS
  2338 00:1180: BD 07                        dw      SWAP
  2339 00:1182: 52 06                        dw      C_FETCH
  2340 00:1184: A7 0C                        dw      EXIT
  2341                        
  Wed Mar 16 2016 22:39                                                                                                    Page 48


  2342                        ; SEARCH
  2343                        
  2344                        
  2345                        
  2346                        
  2347                        ;==============================================================================
  2348                        ; Compiling Words
  2349                        ;------------------------------------------------------------------------------
  2350                        
  2351                        ; +LOOP ( -- )
  2352                        
  2353 00:1186: 73 11 80 05                  HEADER  5,"+LOOP",IMMEDIATE
       00:118A: 2B 4C 4F 4F 
       00:118E: 50 
  2354 00:118F: 20 AF 11     PLUS_LOOP:      jsr     DO_COLON
  2355                        
  2356 00:1192: A7 0C                        dw      EXIT
  2357                        
  2358                        ; (+LOOP)
  2359                        
  2360 00:1194: 89 11 00 07                  HEADER  7,"(+LOOP)",NORMAL
       00:1198: 28 2B 4C 4F 
       00:119C: 4F 50 29 
  2361                        DO_PLUS_LOOP:
  2362                        
  2363 00:119F: BB C8 C8 7C                  CONTINUE
       00:11A3: 00 00 
  2364                        
  2365                        ; : ( -- )
  2366                        
  2367 00:11A5: 97 11 00 01                  HEADER  1,":",NORMAL
       00:11A9: 3A 
  2368 00:11AA: 20 AF 11     COLON:          jsr     DO_COLON
  2369                        
  2370 00:11AD: A7 0C                        dw      EXIT
  2371                        
  2372                        DO_COLON:
  2373 00:11AF: FA                           plx                             ; Pull new word IP-1
  2374 00:11B0: 5A                           phy                             ; Save the old IP
  2375 00:11B1: E8                           inx                             ; Work out new IP
  2376 00:11B2: 9B                           txy
  2377 00:11B3: BB C8 C8 7C                  CONTINUE                        ; Done
       00:11B7: 00 00 
  2378                        
  2379                        ; AGAIN
  2380                        
  2381 00:11B9: A8 11 80 05                  HEADER  5,"AGAIN",IMMEDIATE
       00:11BD: 41 47 41 49 
       00:11C1: 4E 
  2382 00:11C2: 20 AF 11     AGAIN:          jsr     DO_COLON
  2383                        
  2384 00:11C5: A7 0C                        dw      EXIT
  2385                        
  2386                        ; BEGIN
  2387                        
  2388 00:11C7: BC 11 80 05                  HEADER  5,"BEGIN",IMMEDIATE
       00:11CB: 42 45 47 49 
       00:11CF: 4E 
  Wed Mar 16 2016 22:39                                                                                                    Page 49


  2389 00:11D0: 20 AF 11     BEGIN:          jsr     DO_COLON
  2390                        
  2391 00:11D3: A7 0C                        dw      EXIT
  2392                        
  2393                        ; CONSTANT ( x <spaces>name -- )
  2394                        ;
  2395                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2396                        ; definition for name with the execution semantics defined below.
  2397                        
  2398 00:11D5: CA 11 00 08                  HEADER  8,"CONSTANT",NORMAL
       00:11D9: 43 4F 4E 53 
       00:11DD: 54 41 4E 54 
  2399 00:11E1: 20 AF 11     CONSTANT:       jsr     DO_COLON
  2400 00:11E4: 76 0C                        dw      CREATE
  2401 00:11E6: A5 12 FE 11                  dw      DO_LITERAL,DO_CONSTANT
  2402 00:11EA: 5F 0C                        dw      BUILD
  2403 00:11EC: BF 05                        dw      COMMA
  2404 00:11EE: A7 0C                        dw      EXIT
  2405                        
  2406                        ; (CONSTANT) ( -- x )
  2407                        
  2408 00:11F0: D8 11 00 0A                  HEADER  10,"(CONSTANT)",NORMAL
       00:11F4: 28 43 4F 4E 
       00:11F8: 53 54 41 4E 
       00:11FC: 54 29 
  2409                        DO_CONSTANT:
  2410 00:11FE: FA                           plx
  2411 00:11FF: 7B                           tdc
  2412 00:1200: 3A                           dec     a
  2413 00:1201: 3A                           dec     a
  2414 00:1202: 5B                           tcd
  2415 00:1203: BD 01 00                     lda     !1,x
  2416 00:1206: 85 01                        sta     <1
  2417 00:1208: BB C8 C8 7C                  CONTINUE                        ; Done
       00:120C: 00 00 
  2418                        
  2419                        ; DO ( -- )
  2420                        
  2421 00:120E: F3 11 80 02                  HEADER  2,"DO",IMMEDIATE
       00:1212: 44 4F 
  2422 00:1214: 20 AF 11     DO:             jsr     DO_COLON
  2423                        
  2424 00:1217: A7 0C                        dw      EXIT
  2425                        
  2426                        ; (DO) ( -- )
  2427                        
  2428 00:1219: 11 12 00 04                  HEADER  4,"(DO)",NORMAL
       00:121D: 28 44 4F 29 
  2429 00:1221: 00                           db
  2430                        DO_DO:
  2431 00:1222: A5 03                        lda     <3
  2432 00:1224: 48                           pha
  2433 00:1225: A5 01                        lda     <1
  2434 00:1227: 48                           pha
  2435 00:1228: 7B                           tdc
  2436 00:1229: 1A                           inc     a
  2437 00:122A: 1A                           inc     a
  2438 00:122B: 1A                           inc     a
  Wed Mar 16 2016 22:39                                                                                                    Page 50


  2439 00:122C: 1A                           inc     a
  2440 00:122D: 5B                           tcd
  2441 00:122E: BB C8 C8 7C                  CONTINUE
       00:1232: 00 00 
  2442                        
  2443                        ; ELSE
  2444                        
  2445 00:1234: 1C 12 80 04                  HEADER  4,"ELSE",IMMEDIATE
       00:1238: 45 4C 53 45 
  2446 00:123C: 20 AF 11     ELSE:           jsr     DO_COLON
  2447                        
  2448 00:123F: A7 0C                        dw      EXIT
  2449                        
  2450                        ; (BRANCH) ( -- )
  2451                        ;
  2452                        ; Cause the IP to be loaded with the word following the link to this word.
  2453                        
  2454 00:1241: 37 12 00 08                  HEADER  8,"(BRANCH)",NORMAL
       00:1245: 28 42 52 41 
       00:1249: 4E 43 48 29 
  2455                        BRANCH:
  2456 00:124D: B9 00 00                     lda     !0,y                    ; Load branch address into IP
  2457 00:1250: A8                           tay
  2458 00:1251: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1255: 00 00 
  2459                        
  2460                        ; IF
  2461                        
  2462 00:1257: 44 12 80 02                  HEADER  2,"IF",IMMEDIATE
       00:125B: 49 46 
  2463 00:125D: 20 AF 11     IF:             jsr     DO_COLON
  2464                        
  2465 00:1260: A7 0C                        dw      EXIT
  2466                        
  2467                        ; (?BRANCH) ( flag -- )
  2468                        ;
  2469                        ; If flag is false then cause the IP to be loaded with the word following the
  2470                        ; link to this word, otherwise skip over it.
  2471                        
  2472 00:1262: 5A 12 00 09                  HEADER  9,"(?BRANCH)",NORMAL
       00:1266: 28 3F 42 52 
       00:126A: 41 4E 43 48 
       00:126E: 29 
  2473                        QUERY_BRANCH:
  2474 00:126F: A6 01                        ldx     <1                      ; Pull the top of stack value
  2475 00:1271: 7B                           tdc
  2476 00:1272: 1A                           inc     a                       ; Drop top item
  2477 00:1273: 1A                           inc     a
  2478 00:1274: 5B                           tcd
  2479 00:1275: 8A                           txa
  2480 00:1276: F0 D5                        beq     BRANCH                  ; Branch if top was zero
  2481 00:1278: C8                           iny                             ; Otherwise skip address
  2482 00:1279: C8                           iny
  2483 00:127A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:127E: 00 00 
  2484                        
  2485                        ; LITERAL ( x -- )
  2486                        ;
  Wed Mar 16 2016 22:39                                                                                                    Page 51


  2487                        ; Append the run-time semantics given below to the current definition.
  2488                        
  2489 00:1280: 65 12 80 07                  HEADER  7,"LITERAL",IMMEDIATE
       00:1284: 4C 49 54 45 
       00:1288: 52 41 4C 
  2490 00:128B: 20 AF 11     LITERAL:        jsr     DO_COLON
  2491 00:128E: A5 12 A5 12                  dw      DO_LITERAL,DO_LITERAL
  2492 00:1292: BF 05                        dw      COMMA
  2493 00:1294: BF 05                        dw      COMMA
  2494 00:1296: A7 0C                        dw      EXIT
  2495                        
  2496                        ; (LITERAL) ( -- x )
  2497                        ;
  2498                        ; Place x on the stack.
  2499                        
  2500 00:1298: 83 12 00 09                  HEADER  9,"(LITERAL)",NORMAL
       00:129C: 28 4C 49 54 
       00:12A0: 45 52 41 4C 
       00:12A4: 29 
  2501                        DO_LITERAL:
  2502 00:12A5: 7B                           tdc
  2503 00:12A6: 3A                           dec     a
  2504 00:12A7: 3A                           dec     a
  2505 00:12A8: 5B                           tcd
  2506 00:12A9: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  2507 00:12AC: C8                           iny
  2508 00:12AD: C8                           iny
  2509 00:12AE: 85 01                        sta     <1
  2510 00:12B0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:12B4: 00 00 
  2511                        
  2512                        ; LOOP
  2513                        
  2514 00:12B6: 9B 12 80 04                  HEADER  4,"LOOP",IMMEDIATE
       00:12BA: 4C 4F 4F 50 
  2515 00:12BE: 20 AF 11     LOOP:           jsr     DO_COLON
  2516                        
  2517 00:12C1: A7 0C                        dw      EXIT
  2518                        
  2519                        ; (LOOP)
  2520                        
  2521 00:12C3: B9 12 00 06                  HEADER  6,"(LOOP)",NORMAL
       00:12C7: 28 4C 4F 4F 
       00:12CB: 50 29 
  2522                        DO_LOOP
  2523 00:12CD: A3 01                        lda     1,s                     ; Add one to loop counter
  2524 00:12CF: 1A                           inc     a
  2525 00:12D0: 83 01                        sta     1,s
  2526 00:12D2: C3 03                        cmp     3,s                     ; Reached limit?
  2527 00:12D4: B0 0A                        bcs     DO_LOOP_END             ; Yes
  2528 00:12D6: B9 00 00                     lda     !0,y                    ; No, branch back to start
  2529 00:12D9: A8                           tay
  2530 00:12DA: BB C8 C8 7C                  CONTINUE                        ; Done
       00:12DE: 00 00 
  2531                        
  2532 00:12E0: C8           DO_LOOP_END:    iny                             ; Skip over address
  2533 00:12E1: C8                           iny
  2534 00:12E2: 68                           pla                             ; Drop loop variables
  Wed Mar 16 2016 22:39                                                                                                    Page 52


  2535 00:12E3: 68                           pla
  2536 00:12E4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:12E8: 00 00 
  2537                        
  2538                        ; USER
  2539                        
  2540 00:12EA: C6 12 00 04                  HEADER  4,"USER",NORMAL
       00:12EE: 55 53 45 52 
  2541 00:12F2: 20 AF 11     USER:           jsr     DO_COLON
  2542                        
  2543 00:12F5: A7 0C                        dw      EXIT
  2544                        
  2545 00:12F7: ED 12 00 06                  HEADER  6,"(USER)",NORMAL
       00:12FB: 28 55 53 45 
       00:12FF: 52 29 
  2546                        DO_USER:
  2547 00:1301: 7B                           tdc
  2548 00:1302: 3A                           dec     a                       ; Push on data stack
  2549 00:1303: 3A                           dec     a
  2550 00:1304: 5B                           tcd
  2551 00:1305: FA                           plx
  2552 00:1306: 18                           clc
  2553 00:1307: BD 01 00                     lda     !1,x
  2554 00:130A: 69 00 00                     adc     #USER_AREA
  2555 00:130D: 85 01                        sta     <1
  2556 00:130F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1313: 00 00 
  2557                        
  2558                        ; VARIABLE ( <spaces>name -- )
  2559                        ;
  2560                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2561                        ; definition for name with the execution semantics defined below. Reserve one
  2562                        ; cell of data space at an aligned address.
  2563                        
  2564 00:1315: FA 12 00                     LINK    NORMAL
  2565 00:1318: 08 56 41 52                  db      8,"VARIABLE"
       00:131C: 49 41 42 4C 
       00:1320: 45 
  2566 00:1321: 20 AF 11     VARIABLE:       jsr     DO_COLON
  2567 00:1324: 76 0C                        dw      CREATE
  2568 00:1326: A5 12 36 13                  dw      DO_LITERAL,DO_VARIABLE,BUILD
       00:132A: 5F 0C 
  2569 00:132C: A5 12 01 00                  dw      DO_LITERAL,1,CELLS,ALLOT
       00:1330: AF 06 12 06 
  2570 00:1334: A7 0C                        dw      EXIT
  2571                        
  2572                        DO_VARIABLE:
  2573 00:1336: 7B                           tdc
  2574 00:1337: 3A                           dec     a
  2575 00:1338: 3A                           dec     a
  2576 00:1339: 5B                           tcd
  2577 00:133A: 68                           pla
  2578 00:133B: 1A                           inc     a
  2579 00:133C: 85 01                        sta     <1
  2580 00:133E: BB C8 C8 7C                  CONTINUE
       00:1342: 00 00 
  2581                        
  2582                        ; S"
  Wed Mar 16 2016 22:39                                                                                                    Page 53


  2583                        
  2584 00:1344: 18 13 80                     LINK    IMMEDIATE
  2585 00:1347: 02 53 22                     db      2,"S",'"'
  2586 00:134A: 20 AF 11     S_QUOTE:        jsr     DO_COLON
  2587 00:134D: A7 0C                        dw      EXIT
  2588                        
  2589                        ; (S") ( -- c-addr u )
  2590                        
  2591                        DO_S_QUOTE:
  2592 00:134F: 7B                           tdc
  2593 00:1350: 3A                           dec     a                       ; Reserve space for values
  2594 00:1351: 3A                           dec     a
  2595 00:1352: 3A                           dec     a
  2596 00:1353: 3A                           dec     a
  2597 00:1354: 5B                           tcd
  2598 00:1355: E2 20                        short_a
  2599 00:1357: B9 00 00                     lda     !0,y                    ; Fetch the length
  2600 00:135A: 85 01                        sta     <1
  2601 00:135C: 64 02                        stz     <2
  2602 00:135E: C2 20                        long_a
  2603 00:1360: C8                           iny
  2604 00:1361: 98                           tya                             ; Save the text address
  2605 00:1362: 85 03                        sta     <3
  2606 00:1364: 18                           clc                             ; And update IP
  2607 00:1365: 65 01                        adc     <1
  2608 00:1367: A8                           tay
  2609 00:1368: BB C8 C8 7C                  CONTINUE                        ; Done
       00:136C: 00 00 
  2610                        
  2611                        ;==============================================================================
  2612                        ; I/O Operations
  2613                        ;------------------------------------------------------------------------------
  2614                        
  2615                        ; CR ( -- )
  2616                        ;
  2617                        ; Cause subsequent output to appear at the beginning of the next line.
  2618                        ;
  2619                        ; In this implementation it is defined as
  2620                        ;
  2621                        ;   13 EMIT 10 EMIT
  2622                        
  2623 00:136E: 47 13 00 02                  HEADER  2,"CR",NORMAL
       00:1372: 43 52 
  2624 00:1374: 20 AF 11     CR:             jsr     DO_COLON
  2625 00:1377: A5 12 0D 00                  dw      DO_LITERAL,13
  2626 00:137B: 8D 13                        dw      EMIT
  2627 00:137D: A5 12 0A 00                  dw      DO_LITERAL,10
  2628 00:1381: 8D 13                        dw      EMIT
  2629 00:1383: A7 0C                        dw      EXIT
  2630                        
  2631                        ; EMIT ( x -- )
  2632                        ;
  2633                        ; If x is a graphic character in the implementation-defined character set,
  2634                        ; display x. The effect of EMIT for all other values of x is implementation
  2635                        ; -defined.
  2636                        
  2637 00:1385: 71 13 00 04                  HEADER  4,"EMIT",NORMAL
       00:1389: 45 4D 49 54 
  Wed Mar 16 2016 22:39                                                                                                    Page 54


  2638                                        extern  UartTx
  2639                        EMIT:
  2640 00:138D: A5 01                        lda     <1                      ; Fetch character from stack
  2641 00:138F: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  2642 00:1392: 7B                           tdc
  2643 00:1393: 1A                           inc     a                       ; Drop the character
  2644 00:1394: 1A                           inc     a
  2645 00:1395: 5B                           tcd
  2646 00:1396: BB C8 C8 7C                  CONTINUE                        ; Done
       00:139A: 00 00 
  2647                        
  2648                        ; KEY ( -- char )
  2649                        ;
  2650                        ; Receive one character char, a member of the implementation-defined character
  2651                        ; set. Keyboard events that do not correspond to such characters are discarded
  2652                        ; until a valid character is received, and those events are subsequently
  2653                        ; unavailable.
  2654                        ;
  2655                        ; All standard characters can be received. Characters received by KEY are not
  2656                        ; displayed.
  2657                        
  2658 00:139C: 88 13 00 03                  HEADER  3,"KEY",NORMAL
       00:13A0: 4B 45 59 
  2659                                        extern  UartRx
  2660                        KEY:
  2661 00:13A3: 20 xx xx                     jsr     UartRx                  ; Receive a character
  2662 00:13A6: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  2663 00:13A9: AA                           tax
  2664 00:13AA: 7B                           tdc
  2665 00:13AB: 3A                           dec     a                       ; And push to stack
  2666 00:13AC: 3A                           dec     a
  2667 00:13AD: 5B                           tcd
  2668 00:13AE: 86 01                        stx     <1
  2669 00:13B0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:13B4: 00 00 
  2670                        
  2671                        ; SPACE ( -- )
  2672                        ;
  2673                        ; Display one space.
  2674                        ;
  2675                        ; In this implementation it is defined as
  2676                        ;
  2677                        ;   BL EMIT
  2678                        
  2679 00:13B6: 9F 13 00 05                  HEADER  5,"SPACE",NORMAL
       00:13BA: 53 50 41 43 
       00:13BE: 45 
  2680 00:13BF: 20 AF 11     SPACE:          jsr     DO_COLON
  2681 00:13C2: 26 05                        dw      BL
  2682 00:13C4: 8D 13                        dw      EMIT
  2683 00:13C6: A7 0C                        dw      EXIT
  2684                        
  2685                        ; SPACES ( n -- )
  2686                        ;
  2687                        ; If n is greater than zero, display n spaces.
  2688                        ;
  2689                        ; In this implementation it is defined as
  2690                        ;
  Wed Mar 16 2016 22:39                                                                                                    Page 55


  2691                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  2692                        
  2693 00:13C8: B9 13 00 06                  HEADER  6,"SPACES",NORMAL
       00:13CC: 53 50 41 43 
       00:13D0: 45 53 
  2694 00:13D2: 20 AF 11     SPACES:         jsr     DO_COLON
  2695 00:13D5: 84 07        SPACES_1:       dw      DUP
  2696 00:13D7: EB 0A                        dw      ZERO_GREATER
  2697 00:13D9: 6F 12 E5 13                  dw      QUERY_BRANCH,SPACES_2
  2698 00:13DD: BF 13                        dw      SPACE
  2699 00:13DF: 21 09                        dw      ONE_MINUS
  2700 00:13E1: 4D 12 D5 13                  dw      BRANCH,SPACES_1
  2701 00:13E5: 73 07        SPACES_2:       dw      DROP
  2702 00:13E7: A7 0C                        dw      EXIT
  2703                        
  2704                        ; TYPE ( c-addr u -- )
  2705                        ;
  2706                        ; If u is greater than zero, display the character string specified by c-addr
  2707                        ; and u.
  2708                        ;
  2709                        ; In this implementation it is defined as
  2710                        ;
  2711                        ;   ?DUP IF
  2712                        ;     OVER + SWAP DO I C@ EMIT LOOP
  2713                        ;   ELSE DROP THEN
  2714                        
  2715 00:13E9: CB 13 00 04                  HEADER  4,"TYPE",NORMAL
       00:13ED: 54 59 50 45 
  2716 00:13F1: 20 AF 11     TYPE:           jsr     DO_COLON
  2717 00:13F4: 61 07                        dw      QUERY_DUP
  2718 00:13F6: 6F 12 10 14                  dw      QUERY_BRANCH,TYPE_2
  2719 00:13FA: A7 07                        dw      OVER
  2720 00:13FC: CD 08                        dw      PLUS
  2721 00:13FE: BD 07                        dw      SWAP
  2722 00:1400: 22 12                        dw      DO_DO
  2723 00:1402: 5A 08        TYPE_1:         dw      I
  2724 00:1404: 52 06                        dw      C_FETCH
  2725 00:1406: 8D 13                        dw      EMIT
  2726 00:1408: CD 12 02 14                  dw      DO_LOOP,TYPE_1
  2727 00:140C: 4D 12 12 14                  dw      BRANCH,TYPE_3
  2728 00:1410: 73 07        TYPE_2          dw      DROP
  2729 00:1412: A7 0C        TYPE_3          dw      EXIT
  2730                        
  2731                        ;================================================================================
  2732                        ;--------------------------------------------------------------------------------
  2733                        
  2734                        ; #
  2735                        ; #>
  2736                        ; #S
  2737                        ; SIGN
  2738                        
  2739                        ;================================================================================
  2740                        ;--------------------------------------------------------------------------------
  2741                        
  2742                                        TRAILER
  2743                        NEXT_WORD:
  2744                        
  2745                                        end
  Wed Mar 16 2016 22:39                                                                                                    Page 56




      Lines assembled: 4179
      Errors: 0
