  Tue Aug 22 2017 23:21                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;===============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;-------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The DP register is used for the Forth data stack is values can be accessed
    27                        ; using the direct-page addressing modes. The code uses the same offsets as
    28                        ; would be used with the stack relative instructions (i.e <1, <3, etc.).
    29                        ;
    30                        ; The Y register holds the forth instruction pointer leaving X free for general
    31                        ; use in words. Some words push Y if they need an extra register.
    32                        ;
    33                        ; Some of the high-level definitions are based on Bradford J. Rodriguez's
    34                        ; CamelForth implementations.
    35                        ;
    36                        ;-------------------------------------------------------------------------------
    37                        
    38                                        pw      132
    39                                        inclist on
    40                                        maclist off
    41                        
    42                                        chip    65816
    43                                        longi   off
    44                                        longa   off
    45                        
    46                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
  Tue Aug 22 2017 23:21                                                                                                    Page 2


     7                        ;
     8                        ; Western Design Center W65C816 device definitions                                          
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;===============================================================================
    25                        ; Revision History:
    26                        ;
    27                        ; 2015-12-18 AJ Initial version
    28                        ;-------------------------------------------------------------------------------
    29                        ; $Id$
    30                        ;-------------------------------------------------------------------------------
    31                        
    32                        ;==============================================================================
    33                        ; Status Register Bits
    34                        ;------------------------------------------------------------------------------
    35                        
    36             00000080   N_FLAG          equ     1<<7
    37             00000040   V_FLAG          equ     1<<6
    38             00000020   M_FLAG          equ     1<<5
    39             00000010   X_FLAG          equ     1<<4
    40             00000010   B_FLAG          equ     1<<4
    41             00000008   D_FLAG          equ     1<<3
    42             00000004   I_FLAG          equ     1<<2
    43             00000002   Z_FLAG          equ     1<<1
    44             00000001   C_FLAG          equ     1<<0
    45                        
    46                        ;==============================================================================
    47                        ; Macros
    48                        ;------------------------------------------------------------------------------
    49                        
    50                        ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
    51                        ; is fixed at $0100-$01ff. 
    52                        
    53                        emulate         macro
    54                                        sec
    55                                        xce
    56                                        endm
    57                        
    58                        ; Puts the processor in native mode. The size of the memory and index register
    59                        ; operations is not controlled by the M & X bits in the status register.
    60                        
    61                        native          macro
    62                                        clc
    63                                        xce
    64                                        endm
  Tue Aug 22 2017 23:21                                                                                                    Page 3


    65                        
    66                        ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
    67                         
    68                        long_a          macro
    69                                        rep     #M_FLAG
    70                                        longa   on
    71                                        endm
    72                        
    73                        ; Resets the X bit making the index registers 16-bits wide
    74                        
    75                        long_i          macro
    76                                        rep     #X_FLAG
    77                                        longi   on
    78                                        endm
    79                        
    80                        ; Resets the M and X bits making the accumulator, memory accesses and index
    81                        ; registers 16-bits wide.
    82                                        
    83                        long_ai         macro
    84                                        rep     #M_FLAG|X_FLAG
    85                                        longa   on
    86                                        longi   on
    87                                        endm
    88                        
    89                        ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
    90                        
    91                        short_a         macro
    92                                        sep     #M_FLAG
    93                                        longa   off
    94                                        endm
    95                        
    96                        ; Sets the X bit making the index registers 8-bits wide.
    97                        
    98                        short_i         macro
    99                                        sep     #X_FLAG
   100                                        longi   off
   101                                        endm
   102                                        
   103                        ; Sets the M & X bits making the accumulator, memory accesses and index
   104                        ; registers 8-bits wide.
   105                        
   106                        short_ai        macro
   107                                        sep     #M_FLAG|X_FLAG
   108                                        longa   off
   109                                        longi   off
   110                                        endm
    47                        
    48                        ;===============================================================================
    49                        ; Macros
    50                        ;-------------------------------------------------------------------------------
    51                        
    52                        ; The LINK macro deposits the link section of a word header automatically
    53                        ; linking the new word to the last.
    54                        
    55             00000000   WORDZ           set     0                       ; Word counter
    56             00000000   WORD0           equ     0                       ; Null address for first word
    57                        
    58                        LINK            macro   TYPE
  Tue Aug 22 2017 23:21                                                                                                    Page 4


    59                                        dw      WORD@<WORDZ>            ; Link
    60                                        db      TYPE                    ; Type
    61                        WORDZ           set     WORDZ+1
    62                        WORD@<WORDZ>:
    63                                        endm
    64                        
    65                        ; Deposits a word header containing the name which is linked back to the
    66                        ; previous word.
    67                        ;
    68                        ; The WDC assembler does not handle string parameters to macros very well,
    69                        ; stopping at the first comma or space in them, so some headers must be
    70                        ; manually constructed.
    71                        
    72             00000000   NORMAL          equ     $00
    73             00000080   IMMEDIATE       equ     $80
    74                        
    75                        HEADER          macro   LEN,NAME,TYPE
    76                                        LINK    TYPE
    77                                        db      LEN,NAME
    78                                        endm
    79                        
    80                        ; The CONTINUE macro is used at the end of a native word to invoke the next
    81                        ; word pointer.
    82                        
    83                        CONTINUE        macro
    84                                        tyx                             ; Copy IP to X
    85                                        iny
    86                                        iny
    87                                        jmp     (0,x)                   ; Then execute word
    88                                        endm
    89                        
    90                        TRAILER         macro
    91                        LAST_WORD       equ     WORD@<WORDZ>
    92                                        endm
    93                        
    94                        ;===============================================================================
    95                        ; Definitions
    96                        ;-------------------------------------------------------------------------------
    97                        
    98             00000016   USER_SIZE       equ     22
    99             00000080   DSTACK_SIZE     equ     128
   100             00000080   RSTACK_SIZE     equ     128
   101                        
   102             00000000   TO_IN_OFFSET    equ     0
   103             00000002   BASE_OFFSET     equ     2
   104             00000004   BLK_OFFSET      equ     4
   105             00000006   DP_OFFSET       equ     6
   106             00000008   LATEST_OFFSET   equ     8
   107             0000000A   SCR_OFFSET      equ     10
   108             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
   109             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
   110             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
   111             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
   112             00000014   HP_OFFSET       equ     20
   113                        
   114             00000080   TIB_SIZE        equ     128
   115             00000030   PAD_SIZE        equ     48
   116                        
  Tue Aug 22 2017 23:21                                                                                                    Page 5


   117                        ;===============================================================================
   118                        ; Data Areas
   119                        ;-------------------------------------------------------------------------------
   120                        
   121                                        page0
   122                                        org     $00
   123                        
   124 00:0000:              USER_AREA       ds      USER_SIZE               ; User Variables
   125                        
   126                        
   127             00000100   DSTACK_START    equ     $0100
   128             00000180   DSTACK_END      equ     DSTACK_START+DSTACK_SIZE
   129                        
   130             00000180   RSTACK_START    equ     $0180
   131             00000200   RSTACK_END      equ     RSTACK_START+RSTACK_SIZE
   132                        
   133                        
   134                                        data
   135                                        org     $0200
   136                        
   137 00:0200:              TIB_AREA:       ds      TIB_SIZE                ; Terminal Input Buffer
   138 00:0280:                              ds      PAD_SIZE                ; Pad area
   139                        PAD_AREA:       ds      0
   140                        
   141                        ;===============================================================================
   142                        ; Forth Entry Point
   143                        ;-------------------------------------------------------------------------------
   144                        
   145                        FORTH           section OFFSET $0400
   146                        
   147                                        public  Start
   148                        Start:
   149 00:0400: 18 FB                        native                          ; Go to native mode
   150 00:0402: C2 30                        long_ai                         ; And all 16-bit registers
   151 00:0404: A9 FF 01                     lda     #RSTACK_END-1           ; Initialise return stack
   152 00:0407: 1B                           tcs
   153 00:0408: A9 7F 01                     lda     #DSTACK_END-1           ; .. and data stack
   154 00:040B: 5B                           tcd
   155                        
   156 00:040C: A0 15 04                     ldy     #COLD                   ; Then perform COLD start
   157 00:040F: BB C8 C8 7C                  CONTINUE
       00:0413: 00 00 
   158                        
   159                        COLD:
   160 00:0415: 25 05                        dw      DECIMAL
   161 00:0417: CE 04                        dw      ZERO
   162 00:0419: 70 04                        dw      BLK
   163 00:041B: 4B 05                        dw      STORE
   164 00:041D: F8 04                        dw      FALSE
   165 00:041F: B8 04                        dw      STATE
   166 00:0421: 4B 05                        dw      STORE
   167 00:0423: C4 16 94 1E                  dw      DO_LITERAL,NEXT_WORD
   168 00:0427: 80 04                        dw      DP
   169 00:0429: 4B 05                        dw      STORE
   170 00:042B: C4 16 85 1E                  dw      DO_LITERAL,LAST_WORD
   171 00:042F: 94 04                        dw      LATEST
   172 00:0431: 4B 05                        dw      STORE
   173 00:0433: 7F 18                        dw      CR
  Tue Aug 22 2017 23:21                                                                                                    Page 6


   174 00:0435: 7F 18                        dw      CR
   175 00:0437: FD 1A                        dw      DO_TITLE
   176 00:0439: FC 18                        dw      TYPE
   177 00:043B: 7F 18                        dw      CR
   178 00:043D: 7F 18                        dw      CR
   179 00:043F: 80 0E                        dw      ABORT
   180                        
   181                        ;===============================================================================
   182                        ; System/User Variables
   183                        ;-------------------------------------------------------------------------------
   184                        
   185                        ; #TIB ( -- a-addr )
   186                        ;
   187                        ; a-addr is the address of a cell containing the number of characters in the
   188                        ; terminal input buffer.
   189                        
   190 00:0441: 00 00 00 04                  HEADER  4,"#TIB",NORMAL
       00:0445: 23 54 49 42 
   191 00:0449: 20 06 16     HASH_TIB:       jsr     DO_CONSTANT
   192 00:044C: 4E 04                        dw      $+2
   193 00:044E: 7E 00                        dw      TIB_SIZE-2
   194                        
   195                        ; >IN ( -- a-addr )
   196                        ;
   197                        ; a-addr is the address of a cell containing the offset in characters from the
   198                        ; start of the input buffer to the start of the parse area.
   199                        
   200 00:0450: 44 04 00 03                  HEADER  3,">IN",NORMAL
       00:0454: 3E 49 4E 
   201 00:0457: 20 DA 17     TO_IN:          jsr     DO_USER
   202 00:045A: 00 00                        dw      TO_IN_OFFSET
   203                        
   204                        ; BASE ( -- a-addr )
   205                        ;
   206                        ; a-addr is the address of a cell containing the current number-conversion
   207                        ; radix {{2...36}}.
   208                        
   209 00:045C: 53 04 00 04                  HEADER  4,"BASE",NORMAL
       00:0460: 42 41 53 45 
   210 00:0464: 20 DA 17     BASE:           jsr     DO_USER
   211 00:0467: 02 00                        dw      BASE_OFFSET
   212                        
   213                        ; BLK ( -- a-addr )
   214                        ;
   215                        ; a-addr is the address of a cell containing zero or the number of the mass-
   216                        ; storage block being interpreted. If BLK contains zero, the input source is
   217                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   218                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   219                        
   220 00:0469: 5F 04 00 03                  HEADER  3,"BLK",NORMAL
       00:046D: 42 4C 4B 
   221 00:0470: 20 DA 17     BLK:            jsr     DO_USER
   222 00:0473: 04 00                        dw      BLK_OFFSET
   223                        
   224                        ; (BUFFER)
   225                        
   226 00:0475: 20 DA 17     BUFFER:         jsr     DO_USER
   227 00:0478: 10 00                        dw      BUFFER_OFFSET
  Tue Aug 22 2017 23:21                                                                                                    Page 7


   228                        
   229                        ; DP ( -- a-addr )
   230                        ;
   231                        ; Dictionary Pointer
   232                        
   233 00:047A: 6C 04 00 02                  HEADER  2,"DP",NORMAL
       00:047E: 44 50 
   234 00:0480: 20 DA 17     DP:             jsr     DO_USER
   235 00:0483: 06 00                        dw      DP_OFFSET
   236                        
   237                        ; HP ( -- a-addr )
   238                        ;
   239                        ; Hold Pointer
   240                        
   241 00:0485: 20 DA 17     HP:             jsr     DO_USER
   242 00:0488: 14 00                        dw      HP_OFFSET
   243                        
   244                        ; LATEST ( -- a-addr )
   245                        
   246 00:048A: 7D 04 00 06                  HEADER  6,"LATEST",NORMAL
       00:048E: 4C 41 54 45 
       00:0492: 53 54 
   247 00:0494: 20 DA 17     LATEST:         jsr     DO_USER
   248 00:0497: 08 00                        dw      LATEST_OFFSET
   249                        
   250                        ; (LENGTH)
   251                        
   252 00:0499: 20 DA 17     LENGTH:         jsr     DO_USER
   253 00:049C: 12 00                        dw      LENGTH_OFFSET
   254                        
   255                        ; SCR ( -- a-addr )
   256                        ;
   257                        ; a-addr is the address of a cell containing the block number of the block most
   258                        ; recently LISTed.
   259                        
   260 00:049E: 8D 04 00 03                  HEADER  3,"SCR",NORMAL
       00:04A2: 53 43 52 
   261 00:04A5: 20 DA 17     SCR:            jsr     DO_USER
   262 00:04A8: 0A 00                        dw      SCR_OFFSET
   263                        
   264                        ; (SOURCE-ID)
   265                        
   266 00:04AA: 20 DA 17     SOURCEID:       jsr     DO_USER
   267 00:04AD: 0C 00                        dw      SOURCEID_OFFSET
   268                        
   269                        ; STATE ( -- a-addr )
   270                        ;
   271                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   272                        ; is true when in compilation state, false otherwise. The true value in STATE
   273                        ; is non-zero, but is otherwise implementation-defined.
   274                        
   275 00:04AF: A1 04 00 05                  HEADER  5,"STATE",NORMAL
       00:04B3: 53 54 41 54 
       00:04B7: 45 
   276 00:04B8: 20 DA 17     STATE:          jsr     DO_USER
   277 00:04BB: 0E 00                        dw      STATE_OFFSET
   278                        
   279                        ; TIB ( -- c-addr )
  Tue Aug 22 2017 23:21                                                                                                    Page 8


   280                        ;
   281                        ; c-addr is the address of the terminal input buffer.
   282                        
   283 00:04BD: B2 04 00 03                  HEADER  3,"TIB",NORMAL
       00:04C1: 54 49 42 
   284 00:04C4: 20 06 16     TIB:            jsr     DO_CONSTANT
   285 00:04C7: 00 02                        dw      TIB_AREA
   286                        
   287                        ;===============================================================================
   288                        ; Constants
   289                        ;-------------------------------------------------------------------------------
   290                        
   291                        ; 0 ( -- 0 )
   292                        ;
   293                        ; Push the constant value zero on the stack
   294                        
   295 00:04C9: C0 04 00 01                  HEADER  1,"0",NORMAL
       00:04CD: 30 
   296                        ZERO:
   297 00:04CE: 7B                           tdc
   298 00:04CF: 3A                           dec     a                       ; Make space on the stack
   299 00:04D0: 3A                           dec     a
   300 00:04D1: 5B                           tcd
   301 00:04D2: 64 01                        stz     <1                      ; And create a zero value
   302 00:04D4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04D8: 00 00 
   303                        
   304                        ; BL ( -- char )
   305                        ;
   306                        ; char is the character value for a space.
   307                        
   308 00:04DA: CC 04 00 02                  HEADER  2,"BL",NORMAL
       00:04DE: 42 4C 
   309                        BL:
   310 00:04E0: 7B                           tdc
   311 00:04E1: 3A                           dec     a                       ; Make space on the stack
   312 00:04E2: 3A                           dec     a
   313 00:04E3: 5B                           tcd
   314 00:04E4: A9 20 00                     lda     #' '                    ; And save a space value
   315 00:04E7: 85 01                        sta     <1
   316 00:04E9: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04ED: 00 00 
   317                        
   318                        ; FALSE ( -- false )
   319                        ;
   320                        ; Return a false flag.
   321                        
   322 00:04EF: DD 04 00 05                  HEADER  5,"FALSE",NORMAL
       00:04F3: 46 41 4C 53 
       00:04F7: 45 
   323                        FALSE:
   324 00:04F8: 7B                           tdc
   325 00:04F9: 3A                           dec     a                       ; Make space on the stack
   326 00:04FA: 3A                           dec     a
   327 00:04FB: 5B                           tcd
   328 00:04FC: 64 01                        stz     <1                      ; And create a false value
   329 00:04FE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0502: 00 00 
  Tue Aug 22 2017 23:21                                                                                                    Page 9


   330                        
   331                        ; TRUE ( -- true )
   332                        ;
   333                        ; Return a true flag, a single-cell value with all bits set.
   334                        
   335 00:0504: F2 04 00 04                  HEADER  4,"TRUE",NORMAL
       00:0508: 54 52 55 45 
   336                        TRUE:
   337 00:050C: 7B                           tdc
   338 00:050D: 3A                           dec     a                       ; Make space on the stack
   339 00:050E: 3A                           dec     a
   340 00:050F: 5B                           tcd
   341 00:0510: 64 01                        stz     <1                      ; And create a true value
   342 00:0512: C6 01                        dec     <1
   343 00:0514: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0518: 00 00 
   344                        
   345                        ;===============================================================================
   346                        ; Radix
   347                        ;-------------------------------------------------------------------------------
   348                        
   349                        ; DECIMAL ( -- )
   350                        ;
   351                        ; Set the numeric conversion radix to ten (decimal).
   352                        
   353 00:051A: 07 05 00 07                  HEADER  7,"DECIMAL",NORMAL
       00:051E: 44 45 43 49 
       00:0522: 4D 41 4C 
   354 00:0525: 20 BE 14     DECIMAL:        jsr     DO_COLON
   355 00:0528: C4 16 0A 00                  dw      DO_LITERAL,10
   356 00:052C: 64 04                        dw      BASE
   357 00:052E: 4B 05                        dw      STORE
   358 00:0530: E3 0E                        dw      EXIT
   359                        
   360                        ; HEX ( -- )
   361                        ;
   362                        ; Set contents of BASE to sixteen.
   363                        
   364 00:0532: 1D 05 00 03                  HEADER  3,"HEX",NORMAL
       00:0536: 48 45 58 
   365 00:0539: 20 BE 14     HEX:            jsr     DO_COLON
   366 00:053C: C4 16 10 00                  dw      DO_LITERAL,16
   367 00:0540: 64 04                        dw      BASE
   368 00:0542: 4B 05                        dw      STORE
   369 00:0544: E3 0E                        dw      EXIT
   370                        
   371                        ;===============================================================================
   372                        ; Memory Operations
   373                        ;-------------------------------------------------------------------------------
   374                        
   375                        ; ! ( x a-addr -- )
   376                        ;
   377                        ; Store x at a-addr.
   378                        
   379 00:0546: 35 05 00 01                  HEADER  1,"!",NORMAL
       00:054A: 21 
   380                        STORE:
   381 00:054B: A5 03                        lda     <3                      ; Fetch data value
  Tue Aug 22 2017 23:21                                                                                                    Page 10


   382 00:054D: 92 01                        sta     (1)                     ; .. and store
   383 00:054F: 7B                           tdc                             ; Clean up data stack
   384 00:0550: 1A                           inc     a
   385 00:0551: 1A                           inc     a
   386 00:0552: 1A                           inc     a
   387 00:0553: 1A                           inc     a
   388 00:0554: 5B                           tcd
   389 00:0555: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0559: 00 00 
   390                        
   391                        ; +! ( n|u a-addr -- )
   392                        ;
   393                        ; Add n|u to the single-cell number at a-addr.
   394                        
   395 00:055B: 49 05 00 02                  HEADER  2,"+!",NORMAL
       00:055F: 2B 21 
   396                        PLUS_STORE:
   397 00:0561: 18                           clc
   398 00:0562: A5 03                        lda     <3                      ; Fetch data value
   399 00:0564: 72 01                        adc     (1)
   400 00:0566: 92 01                        sta     (1)
   401 00:0568: 7B                           tdc                             ; Clean up data stack
   402 00:0569: 1A                           inc     a
   403 00:056A: 1A                           inc     a
   404 00:056B: 1A                           inc     a
   405 00:056C: 1A                           inc     a
   406 00:056D: 5B                           tcd
   407 00:056E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0572: 00 00 
   408                        
   409                        ; , ( x -- )
   410                        ;
   411                        ; Reserve one cell of data space and store x in the cell. If the data-space
   412                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   413                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   414                        ; is not aligned prior to execution of ,.
   415                        ;
   416                        ; In this implementation is its defined as:
   417                        ;
   418                        ;   HERE ! 1 CELLS ALLOT
   419                        
   420 00:0574: 5E 05 00                     LINK    NORMAL
   421 00:0577: 01 2C                        db      1,","
   422 00:0579: 20 BE 14     COMMA:          jsr     DO_COLON
   423 00:057C: 24 06                        dw      HERE
   424 00:057E: 4B 05                        dw      STORE
   425 00:0580: C4 16 01 00                  dw      DO_LITERAL,1
   426 00:0584: 69 06                        dw      CELLS
   427 00:0586: CC 05                        dw      ALLOT
   428 00:0588: E3 0E                        dw      EXIT
   429                        
   430                        ; 2! ( x1 x2 a-addr -- )
   431                        ;
   432                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   433                        ; consecutive cell.
   434                        ;
   435                        ; In this implementation is its defined as:
   436                        ;
  Tue Aug 22 2017 23:21                                                                                                    Page 11


   437                        ;   SWAP OVER ! CELL+ !.
   438                        
   439 00:058A: 77 05 00 02                  HEADER  2,"2!",NORMAL
       00:058E: 32 21 
   440 00:0590: 20 BE 14     TWO_STORE:      jsr     DO_COLON
   441 00:0593: 09 08                        dw      SWAP
   442 00:0595: A5 07                        dw      OVER
   443 00:0597: 4B 05                        dw      STORE
   444 00:0599: 56 06                        dw      CELL_PLUS
   445 00:059B: 4B 05                        dw      STORE
   446 00:059D: E3 0E                        dw      EXIT
   447                        
   448                        ; 2@ ( a-addr -- x1 x2 )
   449                        ;
   450                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   451                        ; the next consecutive cell.
   452                        ;
   453                        ; In this implementation is its defined as:
   454                        ;
   455                        ;   DUP CELL+ @ SWAP @
   456                        
   457 00:059F: 8D 05 00 02                  HEADER  2,"2@",NORMAL
       00:05A3: 32 40 
   458 00:05A5: 20 BE 14     TWO_FETCH:      jsr     DO_COLON
   459 00:05A8: 82 07                        dw      DUP
   460 00:05AA: 56 06                        dw      CELL_PLUS
   461 00:05AC: B9 05                        dw      FETCH
   462 00:05AE: 09 08                        dw      SWAP
   463 00:05B0: B9 05                        dw      FETCH
   464 00:05B2: E3 0E                        dw      EXIT
   465                        
   466                        ; @ ( a-addr -- x )
   467                        ;
   468                        ; x is the value stored at a-addr.
   469                        
   470 00:05B4: A2 05 00 01                  HEADER  1,"@",NORMAL
       00:05B8: 40 
   471                        FETCH:
   472 00:05B9: B2 01                        lda     (1)                     ; Fetch from memory
   473 00:05BB: 85 01                        sta     <1                      ; .. and replace top value
   474 00:05BD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05C1: 00 00 
   475                        
   476                        ; ALLOT ( n -- )
   477                        ;
   478                        ; If n is greater than zero, reserve n address units of data space. If n is
   479                        ; less than zero, release |n| address units of data space. If n is zero, leave
   480                        ; the data-space pointer unchanged.
   481                        ;
   482                        ; In this implementation its is defined as:
   483                        ;
   484                        ;   DP +!
   485                        
   486 00:05C3: B7 05 00 05                  HEADER  5,"ALLOT",NORMAL
       00:05C7: 41 4C 4C 4F 
       00:05CB: 54 
   487 00:05CC: 20 BE 14     ALLOT:          jsr     DO_COLON
   488 00:05CF: 80 04                        dw      DP
  Tue Aug 22 2017 23:21                                                                                                    Page 12


   489 00:05D1: 61 05                        dw      PLUS_STORE
   490 00:05D3: E3 0E                        dw      EXIT
   491                        
   492                        ; C! ( char c-addr -- )
   493                        ;
   494                        ; Store char at c-addr. When character size is smaller than cell size, only the
   495                        ; number of low-order bits corresponding to character size are transferred.
   496                        
   497 00:05D5: C6 05 00 02                  HEADER  2,"C!",NORMAL
       00:05D9: 43 21 
   498                        C_STORE:
   499 00:05DB: A5 03                        lda     <3                      ; Fetch the data value
   500 00:05DD: E2 20                        short_a
   501 00:05DF: 92 01                        sta     (1)                     ; And store it
   502 00:05E1: C2 20                        long_a
   503 00:05E3: 7B                           tdc                             ; Clean up the stack
   504 00:05E4: 1A                           inc     a
   505 00:05E5: 1A                           inc     a
   506 00:05E6: 1A                           inc     a
   507 00:05E7: 1A                           inc     a
   508 00:05E8: 5B                           tcd
   509 00:05E9: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05ED: 00 00 
   510                        
   511                        ; C, ( char -- )
   512                        ;
   513                        ; Reserve space for one character in the data space and store char in the
   514                        ; space. If the data-space pointer is character aligned when C, begins
   515                        ; execution, it will remain character aligned when C, finishes execution.
   516                        ; An ambiguous condition exists if the data-space pointer is not character-
   517                        ; aligned prior to execution of C,
   518                        ;
   519                        ;   HERE C! 1 CHARS ALLOT
   520                        
   521 00:05EF: D8 05 00                     LINK    NORMAL
   522 00:05F2: 02 43 2C                     db      2,"C,"
   523 00:05F5: 20 BE 14     C_COMMA:        jsr     DO_COLON
   524 00:05F8: 24 06                        dw      HERE
   525 00:05FA: DB 05                        dw      C_STORE
   526 00:05FC: C4 16 01 00                  dw      DO_LITERAL,1
   527 00:0600: 9C 06                        dw      CHARS
   528 00:0602: CC 05                        dw      ALLOT
   529 00:0604: E3 0E                        dw      EXIT
   530                        
   531                        ; C@ ( c-addr -- char )
   532                        ;
   533                        ; Fetch the character stored at c-addr. When the cell size is greater than
   534                        ; character size, the unused high-order bits are all zeroes.
   535                        
   536 00:0606: F2 05 00 02                  HEADER  2,"C@",NORMAL
       00:060A: 43 40 
   537                        C_FETCH:
   538 00:060C: E2 20                        short_a
   539 00:060E: B2 01                        lda     (1)                     ; Fetch the data byte
   540 00:0610: 85 01                        sta     <1                      ; .. and replace stack value
   541 00:0612: 64 02                        stz     <2
   542 00:0614: C2 20                        long_a
   543 00:0616: BB C8 C8 7C                  CONTINUE                        ; Done
  Tue Aug 22 2017 23:21                                                                                                    Page 13


       00:061A: 00 00 
   544                        
   545                        ; HERE ( -- addr )
   546                        ;
   547                        ; addr is the data-space pointer.
   548                        
   549 00:061C: 09 06 00 04                  HEADER  4,"HERE",NORMAL
       00:0620: 48 45 52 45 
   550 00:0624: 20 BE 14     HERE:           jsr     DO_COLON
   551 00:0627: 80 04                        dw      DP
   552 00:0629: B9 05                        dw      FETCH
   553 00:062B: E3 0E                        dw      EXIT
   554                        
   555                        ;===============================================================================
   556                        ; Alignment
   557                        ;-------------------------------------------------------------------------------
   558                        
   559                        ; ALIGN ( -- )
   560                        ;
   561                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   562                        
   563 00:062D: 1F 06 00 05                  HEADER  5,"ALIGN",NORMAL
       00:0631: 41 4C 49 47 
       00:0635: 4E 
   564                        ALIGN:
   565 00:0636: BB C8 C8 7C                  CONTINUE                        ; Done
       00:063A: 00 00 
   566                        
   567                        ; ALIGNED ( addr -- a-addr )
   568                        ;
   569                        ; a-addr is the first aligned address greater than or equal to addr.
   570                        
   571 00:063C: 30 06 00 07                  HEADER  7,"ALIGNED",NORMAL
       00:0640: 41 4C 49 47 
       00:0644: 4E 45 44 
   572                        ALIGNED:
   573 00:0647: BB C8 C8 7C                  CONTINUE                        ; Done
       00:064B: 00 00 
   574                        
   575                        ; CELL+ ( a-addr1 -- a-addr2 )
   576                        ;
   577                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   578                        
   579 00:064D: 3F 06 00 05                  HEADER  5,"CELL+",NORMAL
       00:0651: 43 45 4C 4C 
       00:0655: 2B 
   580                        CELL_PLUS:
   581 00:0656: E6 01                        inc     <1                      ; Bump the address by two
   582 00:0658: E6 01                        inc     <1
   583 00:065A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:065E: 00 00 
   584                        
   585                        ; CELLS ( n1 -- n2 )
   586                        ;
   587                        ; n2 is the size in address units of n1 cells.
   588                        
   589 00:0660: 50 06 00 05                  HEADER  5,"CELLS",NORMAL
       00:0664: 43 45 4C 4C 
  Tue Aug 22 2017 23:21                                                                                                    Page 14


       00:0668: 53 
   590                        CELLS:
   591 00:0669: 06 01                        asl     <1                      ; Two bytes per cell
   592 00:066B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:066F: 00 00 
   593                        
   594                        ; CHAR+ ( c-addr1 -- c-addr2 )
   595                        ;
   596                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
   597                        
   598 00:0671: 63 06 00 05                  HEADER  5,"CHAR+",NORMAL
       00:0675: 43 48 41 52 
       00:0679: 2B 
   599                        CHAR_PLUS:
   600 00:067A: E6 01                        inc     <1                      ; Bump the address by one
   601 00:067C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0680: 00 00 
   602                        
   603                        ; CHAR- ( c-addr1 -- c-addr2 )
   604                        ;
   605                        ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
   606                        
   607 00:0682: 74 06 00 05                  HEADER  5,"CHAR-",NORMAL
       00:0686: 43 48 41 52 
       00:068A: 2D 
   608                        CHAR_MINUS:
   609 00:068B: C6 01                        dec     <1
   610 00:068D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0691: 00 00 
   611                        
   612                        ; CHARS ( n1 -- n2 )
   613                        ;
   614                        ; n2 is the size in address units of n1 characters.
   615                        
   616 00:0693: 85 06 00 05                  HEADER  5,"CHARS",NORMAL
       00:0697: 43 48 41 52 
       00:069B: 53 
   617                        CHARS:
   618 00:069C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06A0: 00 00 
   619                        
   620                        ;===============================================================================
   621                        ; Stack Operations
   622                        ;-------------------------------------------------------------------------------
   623                        
   624                        ; 2DROP ( x1 x2 -- )
   625                        ;
   626                        ; Drop cell pair x1 x2 from the stack.
   627                        
   628 00:06A2: 96 06 00 05                  HEADER  5,"2DROP",NORMAL
       00:06A6: 32 44 52 4F 
       00:06AA: 50 
   629                        TWO_DROP:
   630 00:06AB: 7B                           tdc                             ; Removed two words from stack
   631 00:06AC: 1A                           inc     a
   632 00:06AD: 1A                           inc     a
   633 00:06AE: 1A                           inc     a
   634 00:06AF: 1A                           inc     a
  Tue Aug 22 2017 23:21                                                                                                    Page 15


   635 00:06B0: 5B                           tcd
   636 00:06B1: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06B5: 00 00 
   637                        
   638                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   639                        ;
   640                        ; Duplicate cell pair x1 x2.
   641                        
   642 00:06B7: A5 06 00 04                  HEADER  4,"2DUP",NORMAL
       00:06BB: 32 44 55 50 
   643                        TWO_DUP:
   644 00:06BF: 7B                           tdc                             ; Make space for new value
   645 00:06C0: 3A                           dec     a
   646 00:06C1: 3A                           dec     a
   647 00:06C2: 3A                           dec     a
   648 00:06C3: 3A                           dec     a
   649 00:06C4: 5B                           tcd
   650 00:06C5: A5 05                        lda     <5                      ; Copy top two values
   651 00:06C7: 85 01                        sta     <1
   652 00:06C9: A5 07                        lda     <7
   653 00:06CB: 85 03                        sta     <3
   654 00:06CD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06D1: 00 00 
   655                        
   656                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   657                        ;
   658                        ; Copy cell pair x1 x2 to the top of the stack.
   659                        
   660 00:06D3: BA 06 00 05                  HEADER  5,"2OVER",NORMAL
       00:06D7: 32 4F 56 45 
       00:06DB: 52 
   661                        TWO_OVER:
   662 00:06DC: 7B                           tdc                             ; Make space for new value
   663 00:06DD: 3A                           dec     a
   664 00:06DE: 3A                           dec     a
   665 00:06DF: 3A                           dec     a
   666 00:06E0: 3A                           dec     a
   667 00:06E1: 5B                           tcd
   668 00:06E2: A5 09                        lda     <9                      ; Ciopy top two values
   669 00:06E4: 85 01                        sta     <1
   670 00:06E6: A5 0B                        lda     <11
   671 00:06E8: 85 03                        sta     <3
   672 00:06EA: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06EE: 00 00 
   673                        
   674                        ; 2ROT ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
   675                        ;
   676                        ; Rotate the top three cell pairs on the stack bringing cell pair x1 x2 to
   677                        ; the top of the stack.
   678                        
   679 00:06F0: D6 06 00 04                  HEADER  4,"2ROT",NORMAL
       00:06F4: 32 52 4F 54 
   680                        TWO_ROT:
   681 00:06F8: A5 0B                        lda     <11                     ; Save x1
   682 00:06FA: 48                           pha
   683 00:06FB: A5 09                        lda     <9                      ; Save x2
   684 00:06FD: 48                           pha
   685 00:06FE: A5 07                        lda     <7                      ; Move x3
  Tue Aug 22 2017 23:21                                                                                                    Page 16


   686 00:0700: 85 0B                        sta     <11
   687 00:0702: A5 05                        lda     <5                      ; Move x4
   688 00:0704: 85 09                        sta     <9
   689 00:0706: A5 03                        lda     <3                      ; Move x5
   690 00:0708: 85 07                        sta     <7
   691 00:070A: A5 01                        lda     <1                      ; Move x6
   692 00:070C: 85 05                        sta     <5
   693 00:070E: 68                           pla                             ; Restore x2
   694 00:070F: 85 01                        sta     <1
   695 00:0711: 68                           pla                             ; Restore x1
   696 00:0712: 85 03                        sta     <3
   697 00:0714: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0718: 00 00 
   698                        
   699                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   700                        ;
   701                        ; Exchange the top two cell pairs.
   702                        
   703 00:071A: F3 06 00 05                  HEADER  5,"2SWAP",NORMAL
       00:071E: 32 53 57 41 
       00:0722: 50 
   704                        TWO_SWAP:
   705 00:0723: A5 03                        lda     <3                      ; Save x3
   706 00:0725: 48                           pha
   707 00:0726: A5 01                        lda     <1                      ; Save x4
   708 00:0728: 48                           pha
   709 00:0729: A5 07                        lda     <7                      ; Move x1
   710 00:072B: 85 03                        sta     <3
   711 00:072D: A5 05                        lda     <5                      ; Move x2
   712 00:072F: 85 01                        sta     <1
   713 00:0731: 68                           pla                             ; Move x4
   714 00:0732: 85 05                        sta     <5
   715 00:0734: 68                           pla                             ; Move x3
   716 00:0735: 85 07                        sta     <7
   717 00:0737: BB C8 C8 7C                  CONTINUE                        ; Done
       00:073B: 00 00 
   718                        
   719                        ; ?DUP ( x -- 0 | x x )
   720                        ;
   721                        ; Duplicate x if it is non-zero.
   722                        
   723 00:073D: 1D 07 00 04                  HEADER  4,"?DUP",NORMAL
       00:0741: 3F 44 55 50 
   724                        QUERY_DUP:
   725 00:0745: A5 01                        lda     <1                      ; Fetch top value
   726 00:0747: D0 39                        bne     DUP                     ; Non-zero value?
   727 00:0749: BB C8 C8 7C                  CONTINUE                        ; Done
       00:074D: 00 00 
   728                        
   729                        ; DEPTH ( -- +n )
   730                        ;
   731                        ; +n is the number of single-cell values contained in the data stack before +n
   732                        ; was placed on the stack.
   733                        
   734 00:074F: 40 07 00 05                  HEADER  5,"DEPTH",NORMAL
       00:0753: 44 45 50 54 
       00:0757: 48 
   735 00:0758: 20 BE 14     DEPTH:          jsr     DO_COLON
  Tue Aug 22 2017 23:21                                                                                                    Page 17


   736 00:075B: DB 1A                        dw      AT_DP
   737 00:075D: C4 16 7F 01                  dw      DO_LITERAL,DSTACK_END-1
   738 00:0761: 09 08                        dw      SWAP
   739 00:0763: 2B 09                        dw      MINUS
   740 00:0765: 97 09                        dw      TWO_SLASH
   741 00:0767: E3 0E                        dw      EXIT
   742                        
   743                        ; DROP ( x -- )
   744                        ;
   745                        ; Remove x from the stack.
   746                        
   747 00:0769: 52 07 00 04                  HEADER  4,"DROP",NORMAL
       00:076D: 44 52 4F 50 
   748                        DROP:
   749 00:0771: 7B                           tdc                             ; Drop the top value
   750 00:0772: 1A                           inc     a
   751 00:0773: 1A                           inc     a
   752 00:0774: 5B                           tcd
   753 00:0775: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0779: 00 00 
   754                        
   755                        ; DUP ( x -- x x )
   756                        ;
   757                        ; Duplicate x.
   758                        
   759 00:077B: 6C 07 00 03                  HEADER  3,"DUP",NORMAL
       00:077F: 44 55 50 
   760                        DUP:
   761 00:0782: 7B                           tdc
   762 00:0783: 3A                           dec     a
   763 00:0784: 3A                           dec     a
   764 00:0785: 5B                           tcd
   765 00:0786: A5 03                        lda     <3                      ; Fetch top value
   766 00:0788: 85 01                        sta     <1                      ; And make a copy
   767 00:078A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:078E: 00 00 
   768                        
   769                        ; NIP ( x1 x2 -- x2 )
   770                        ;
   771                        ; Drop the first item below the top of stack.
   772                        
   773 00:0790: 7E 07 00 03                  HEADER  3,"NIP",NORMAL
       00:0794: 4E 49 50 
   774                        NIP:
   775 00:0797: A5 01                        lda     <1                      ; Copy x2 over x1
   776 00:0799: 85 03                        sta     <3
   777 00:079B: 80 D4                        bra     DROP
   778                        
   779                        ; OVER ( x1 x2 -- x1 x2 x1 )
   780                        ;
   781                        ; Place a copy of x1 on top of the stack.
   782                        
   783 00:079D: 93 07 00 04                  HEADER  4,"OVER",NORMAL
       00:07A1: 4F 56 45 52 
   784                        OVER:
   785 00:07A5: 7B                           tdc
   786 00:07A6: 3A                           dec     a
   787 00:07A7: 3A                           dec     a
  Tue Aug 22 2017 23:21                                                                                                    Page 18


   788 00:07A8: 5B                           tcd
   789 00:07A9: A5 05                        lda     <5                      ; Fetch second value
   790 00:07AB: 85 01                        sta     <1                      ; And make a copy
   791 00:07AD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07B1: 00 00 
   792                        
   793                        ; PICK ( xu ... x1 x0 u -- xu ... x1 x0 xu )
   794                        ;
   795                        ; Remove u. Copy the xu to the top of the stack. An ambiguous condition exists
   796                        ; if there are less than u+2 items on the stack before PICK is executed.
   797                        
   798 00:07B3: A0 07 00 04                  HEADER  4,"PICK",NORMAL
       00:07B7: 50 49 43 4B 
   799                        PICK:
   800 00:07BB: A5 01                        lda     <1                      ; Fetch the index
   801 00:07BD: 0A                           asl     a
   802 00:07BE: AA                           tax
   803 00:07BF: B5 03                        lda     <3,x                    ; Load the target value
   804 00:07C1: 85 01                        sta     <1                      ; .. and save
   805 00:07C3: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07C7: 00 00 
   806                        
   807                        ; ROLL ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
   808                        ;
   809                        ; Remove u. Rotate u+1 items on the top of the stack. An ambiguous condition
   810                        ; exists if there are less than u+2 items on the stack before ROLL is executed.
   811                        
   812 00:07C9: B6 07 00 04                  HEADER  4,"ROLL",NORMAL
       00:07CD: 52 4F 4C 4C 
   813                        ROLL:
   814 00:07D1: 06 01                        asl     <1                      ; Convert count to index
   815 00:07D3: A6 01                        ldx     <1
   816 00:07D5: F0 0E                        beq     ROLL_2                  ; Zero? Nothing to do
   817 00:07D7: B5 03                        lda     <3,x                    ; Save the final value
   818 00:07D9: 48                           pha
   819 00:07DA: B5 01        ROLL_1:         lda     <1,x                    ; Move x-1 to x
   820 00:07DC: 95 03                        sta     <3,x
   821 00:07DE: CA                           dex                             ; And repeat
   822 00:07DF: CA                           dex
   823 00:07E0: D0 F8                        bne     ROLL_1
   824 00:07E2: 68                           pla                             ; Recover the new top value
   825 00:07E3: 85 03                        sta     <3
   826 00:07E5: 4C 71 07     ROLL_2:         jmp     DROP                    ; Drop the count
   827                        
   828                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   829                        ;
   830                        ; Rotate the top three stack entries.
   831                        
   832 00:07E8: CC 07 00 03                  HEADER  3,"ROT",NORMAL
       00:07EC: 52 4F 54 
   833                        ROT:
   834 00:07EF: A6 05                        ldx     <5                      ; Save x1
   835 00:07F1: A5 03                        lda     <3                      ; Move x2
   836 00:07F3: 85 05                        sta     <5
   837 00:07F5: A5 01                        lda     <1                      ; Move x3
   838 00:07F7: 85 03                        sta     <3
   839 00:07F9: 86 01                        stx     <1                      ; Restore x1
   840 00:07FB: BB C8 C8 7C                  CONTINUE
  Tue Aug 22 2017 23:21                                                                                                    Page 19


       00:07FF: 00 00 
   841                        
   842                        ; SWAP ( x1 x2 -- x2 x1 )
   843                        ;
   844                        ; Exchange the top two stack items.
   845                        
   846 00:0801: EB 07 00 04                  HEADER  4,"SWAP",NORMAL
       00:0805: 53 57 41 50 
   847                        SWAP:
   848 00:0809: A5 01                        lda     <1                      ; Switch top two words
   849 00:080B: A6 03                        ldx     <3
   850 00:080D: 85 03                        sta     <3
   851 00:080F: 86 01                        stx     <1
   852 00:0811: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0815: 00 00 
   853                        
   854                        ; TUCK ( x1 x2 -- x2 x1 x2 )
   855                        ;
   856                        ; Copy the first (top) stack item below the second stack item.
   857                        
   858 00:0817: 04 08 00 04                  HEADER  4,"TUCK",NORMAL
       00:081B: 54 55 43 4B 
   859 00:081F: 20 BE 14     TUCK:           jsr     DO_COLON
   860 00:0822: 09 08                        dw      SWAP
   861 00:0824: A5 07                        dw      OVER
   862 00:0826: E3 0E                        dw      EXIT
   863                        
   864                        ;===============================================================================
   865                        ; Return Stack Operations
   866                        ;-------------------------------------------------------------------------------
   867                        
   868                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   869                        ;
   870                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   871                        ; SWAP >R >R.
   872                        
   873 00:0828: 1A 08 00 03                  HEADER  3,"2>R",NORMAL
       00:082C: 32 3E 52 
   874                        TWO_TO_R:
   875 00:082F: A5 03                        lda     <3                      ; Transfer x1
   876 00:0831: 48                           pha
   877 00:0832: A5 01                        lda     <1                      ; Transfer x2
   878 00:0834: 48                           pha
   879 00:0835: 7B                           tdc
   880 00:0836: 1A                           inc     a                       ; Clean up data stack
   881 00:0837: 1A                           inc     a
   882 00:0838: 1A                           inc     a
   883 00:0839: 1A                           inc     a
   884 00:083A: 5B                           tcd
   885 00:083B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:083F: 00 00 
   886                        
   887                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   888                        ;
   889                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   890                        ; R> SWAP.
   891                        
   892 00:0841: 2B 08 00 03                  HEADER  3,"2R>",NORMAL
  Tue Aug 22 2017 23:21                                                                                                    Page 20


       00:0845: 32 52 3E 
   893                        TWO_R_FROM:
   894 00:0848: 7B                           tdc
   895 00:0849: 3A                           dec     a                       ; Make space for values
   896 00:084A: 3A                           dec     a
   897 00:084B: 3A                           dec     a
   898 00:084C: 3A                           dec     a
   899 00:084D: 5B                           tcd
   900 00:084E: 68                           pla                             ; Transfer x2
   901 00:084F: 85 01                        sta     <1
   902 00:0851: 68                           pla                             ; Transfer x1
   903 00:0852: 85 03                        sta     <3
   904 00:0854: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0858: 00 00 
   905                        
   906                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
   907                        ;
   908                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   909                        ; 2DUP >R >R SWAP.
   910                        
   911 00:085A: 44 08 00 03                  HEADER  3,"2R@",NORMAL
       00:085E: 32 52 40 
   912                        TWO_R_FETCH:
   913 00:0861: 7B                           tdc
   914 00:0862: 3A                           dec     a                       ; Make space for values
   915 00:0863: 3A                           dec     a
   916 00:0864: 3A                           dec     a
   917 00:0865: 3A                           dec     a
   918 00:0866: 5B                           tcd
   919 00:0867: A3 01                        lda     1,s                     ; Transfer x2
   920 00:0869: 85 01                        sta     <1
   921 00:086B: A3 03                        lda     3,s                     ; Transfer x1
   922 00:086D: 85 03                        sta     <3
   923 00:086F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0873: 00 00 
   924                        
   925                        ; >R ( x -- ) ( R: -- x )
   926                        ;
   927                        ; Move x to the return stack.
   928                        
   929 00:0875: 5D 08 00 02                  HEADER  2,">R",NORMAL
       00:0879: 3E 52 
   930                        TO_R:
   931 00:087B: A5 01                        lda     <1                      ; Transfer top value
   932 00:087D: 48                           pha                             ; .. to return stack
   933 00:087E: 7B                           tdc
   934 00:087F: 1A                           inc     a
   935 00:0880: 1A                           inc     a
   936 00:0881: 5B                           tcd
   937 00:0882: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0886: 00 00 
   938                        
   939                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   940                        ;
   941                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   942                        ; exists if the loop control parameters are unavailable.
   943                        
   944 00:0888: 78 08 00 01                  HEADER  1,"I",NORMAL
  Tue Aug 22 2017 23:21                                                                                                    Page 21


       00:088C: 49 
   945                        I:
   946 00:088D: 7B                           tdc
   947 00:088E: 3A                           dec     a
   948 00:088F: 3A                           dec     a
   949 00:0890: 5B                           tcd
   950 00:0891: A3 01                        lda     1,s
   951 00:0893: 85 01                        sta     <1
   952 00:0895: BB C8 C8 7C                  CONTINUE
       00:0899: 00 00 
   953                        
   954                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   955                        ;
   956                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   957                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   958                        ; unavailable.
   959                        
   960 00:089B: 8B 08 00 01                  HEADER  1,"J",NORMAL
       00:089F: 4A 
   961                        J:
   962 00:08A0: 7B                           tdc
   963 00:08A1: 3A                           dec     a
   964 00:08A2: 3A                           dec     a
   965 00:08A3: 5B                           tcd
   966 00:08A4: A3 05                        lda     5,s
   967 00:08A6: 85 01                        sta     <1
   968 00:08A8: BB C8 C8 7C                  CONTINUE
       00:08AC: 00 00 
   969                        
   970                        ; R> ( -- x ) ( R: x -- )
   971                        ;
   972                        ; Move x from the return stack to the data stack.
   973                        
   974 00:08AE: 9E 08 00 02                  HEADER  2,"R>",NORMAL
       00:08B2: 52 3E 
   975                        R_FROM:
   976 00:08B4: 7B                           tdc
   977 00:08B5: 3A                           dec     a
   978 00:08B6: 3A                           dec     a
   979 00:08B7: 5B                           tcd
   980 00:08B8: 68                           pla                             ; Fetch return stack value
   981 00:08B9: 85 01                        sta     <1
   982 00:08BB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08BF: 00 00 
   983                        
   984                        ; R@ ( -- x ) ( R: x -- x )
   985                        ;
   986                        ; Copy x from the return stack to the data stack.
   987                        
   988 00:08C1: B1 08 00 02                  HEADER  2,"R@",NORMAL
       00:08C5: 52 40 
   989                        R_FETCH:
   990 00:08C7: 7B                           tdc
   991 00:08C8: 3A                           dec     a
   992 00:08C9: 3A                           dec     a
   993 00:08CA: 5B                           tcd
   994 00:08CB: A3 01                        lda     1,s
   995 00:08CD: 85 01                        sta     <1
  Tue Aug 22 2017 23:21                                                                                                    Page 22


   996 00:08CF: BB C8 C8 7C                  CONTINUE
       00:08D3: 00 00 
   997                        
   998                        ;===============================================================================
   999                        ; Single Precision Arithmetic
  1000                        ;-------------------------------------------------------------------------------
  1001                        
  1002                        ; * ( n1|u1 n2|u2 -- n3|u3 )
  1003                        ;
  1004                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
  1005                        ;
  1006                        ; In this implementation it is defined as:
  1007                        ;
  1008                        ;   M* DROP
  1009                        
  1010 00:08D5: C4 08 00 01                  HEADER  1,"*",NORMAL
       00:08D9: 2A 
  1011 00:08DA: 20 BE 14     STAR:           jsr     DO_COLON
  1012 00:08DD: D8 0B                        dw      M_STAR
  1013 00:08DF: 71 07                        dw      DROP
  1014 00:08E1: E3 0E                        dw      EXIT
  1015                        
  1016                        ; */ ( n1 n2 n3 -- n4 )
  1017                        ;
  1018                        ; Multiply n1 by n2 producing the intermediate double-cell result d. Divide d
  1019                        ; by n3 giving the single-cell quotient n4. An ambiguous condition exists if
  1020                        ; n3 is zero or if the quotient n4 lies outside the range of a signed number.
  1021                        ; If d and n3 differ in sign, the implementation-defined result returned will
  1022                        ; be the same as that returned by either the phrase >R M* R> FM/MOD SWAP DROP
  1023                        ; or the phrase >R M* R> SM/REM SWAP DROP.
  1024                        ;
  1025                        ; In this implementation it is defined as:
  1026                        ;
  1027                        ;   >R M* R> FM/MOD SWAP DROP
  1028                        
  1029 00:08E3: D8 08 00 02                  HEADER  2,"*/",NORMAL
       00:08E7: 2A 2F 
  1030 00:08E9: 20 BE 14     STAR_SLASH:     jsr     DO_COLON
  1031 00:08EC: 7B 08                        dw      TO_R
  1032 00:08EE: D8 0B                        dw      M_STAR
  1033 00:08F0: B4 08                        dw      R_FROM
  1034 00:08F2: CD 09                        dw      FM_SLASH_MOD
  1035 00:08F4: 09 08                        dw      SWAP
  1036 00:08F6: 71 07                        dw      DROP
  1037 00:08F8: E3 0E                        dw      EXIT
  1038                        
  1039                        ; */MOD ( n1 n2 n3 -- n4 n5 )
  1040                        ;
  1041                        ; Multiply n1 by n2 producing the intermediate double-cell result d. Divide d
  1042                        ; by n3 producing the single-cell remainder n4 and the single-cell quotient n5.
  1043                        ; An ambiguous condition exists if n3 is zero, or if the quotient n5 lies
  1044                        ; outside the range of a single-cell signed integer. If d and n3 differ in
  1045                        ; sign, the implementation-defined result returned will be the same as that
  1046                        ; returned by either the phrase >R M* R> FM/MOD or the phrase >R M* R> SM/REM.
  1047                        ;
  1048                        ; In this implementation it is defined as:
  1049                        ;
  1050                        ;   >R M* R> FM/MOD
  Tue Aug 22 2017 23:21                                                                                                    Page 23


  1051                        
  1052 00:08FA: E6 08 00 05                  HEADER  5,"*/MOD",NORMAL
       00:08FE: 2A 2F 4D 4F 
       00:0902: 44 
  1053 00:0903: 20 BE 14     STAR_SLASH_MOD: jsr     DO_COLON
  1054 00:0906: 7B 08                        dw      TO_R
  1055 00:0908: D8 0B                        dw      M_STAR
  1056 00:090A: B4 08                        dw      R_FROM
  1057 00:090C: CD 09                        dw      FM_SLASH_MOD
  1058 00:090E: E3 0E                        dw      EXIT
  1059                        
  1060                        ; + ( n1|u1 n2|u2 -- n3|u3 )
  1061                        ;
  1062                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
  1063                        
  1064 00:0910: FD 08 00 01                  HEADER  1,"+",NORMAL
       00:0914: 2B 
  1065                        PLUS:
  1066 00:0915: 18                           clc                             ; Add top two values
  1067 00:0916: A5 03                        lda     <3
  1068 00:0918: 65 01                        adc     <1
  1069 00:091A: 85 03                        sta     <3                      ; Save result
  1070 00:091C: 7B                           tdc
  1071 00:091D: 1A                           inc     a                       ; Clean up data stack
  1072 00:091E: 1A                           inc     a
  1073 00:091F: 5B                           tcd
  1074 00:0920: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0924: 00 00 
  1075                        
  1076                        ; - ( n1|u1 n2|u2 -- n3|u3 )
  1077                        ;
  1078                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
  1079                        
  1080 00:0926: 13 09 00 01                  HEADER  1,"-",NORMAL
       00:092A: 2D 
  1081                        MINUS:
  1082 00:092B: 38                           sec                             ; Subtract top two values
  1083 00:092C: A5 03                        lda     <3
  1084 00:092E: E5 01                        sbc     <1
  1085 00:0930: 85 03                        sta     <3                      ; Save result
  1086 00:0932: 7B                           tdc
  1087 00:0933: 1A                           inc     a                       ; Clean up data stack
  1088 00:0934: 1A                           inc     a
  1089 00:0935: 5B                           tcd
  1090 00:0936: BB C8 C8 7C                  CONTINUE                        ; Done
       00:093A: 00 00 
  1091                        
  1092                        ; / ( n1 n2 -- n3 )
  1093                        ;
  1094                        ; Divide n1 by n2, giving the single-cell quotient n3. An ambiguous condition
  1095                        ; exists if n2 is zero. If n1 and n2 differ in sign, the implementation-defined
  1096                        ; result returned will be the same as that returned by either the phrase >R S>D
  1097                        ; R> FM/MOD SWAP DROP or the phrase >R S>D R> SM/REM SWAP DROP.
  1098                        ;
  1099                        ; In this implementatio it is defined as:
  1100                        ;
  1101                        ;   >R S>D R> FM/MOD SWAP DROP
  1102                        
  Tue Aug 22 2017 23:21                                                                                                    Page 24


  1103 00:093C: 29 09 00 01                  HEADER  1,"/",NORMAL
       00:0940: 2F 
  1104 00:0941: 20 BE 14     SLASH:          jsr     DO_COLON
  1105 00:0944: 7B 08                        dw      TO_R
  1106 00:0946: 13 0C                        dw      S_TO_D
  1107 00:0948: B4 08                        dw      R_FROM
  1108 00:094A: CD 09                        dw      FM_SLASH_MOD
  1109 00:094C: 09 08                        dw      SWAP
  1110 00:094E: 71 07                        dw      DROP
  1111 00:0950: E3 0E                        dw      EXIT
  1112                        
  1113                        ; /MOD ( n1 n2 -- n3 n4 )
  1114                        ;
  1115                        ; Divide n1 by n2, giving the single-cell remainder n3 and the single-cell
  1116                        ; quotient n4. An ambiguous condition exists if n2 is zero. If n1 and n2 differ
  1117                        ; in sign, the implementation-defined result returned will be the same as that
  1118                        ; returned by either the phrase >R S>D R> FM/MOD or the phrase >R S>D R> SM/REM.
  1119                        ;
  1120                        ; In this implementation it is defined as:
  1121                        ;
  1122                        ;   >R S>D R> FM/MOD
  1123                        
  1124 00:0952: 3F 09 00 04                  HEADER  4,"/MOD",NORMAL
       00:0956: 2F 4D 4F 44 
  1125 00:095A: 20 BE 14     SLASH_MOD:      jsr     DO_COLON
  1126 00:095D: 7B 08                        dw      TO_R
  1127 00:095F: 13 0C                        dw      S_TO_D
  1128 00:0961: B4 08                        dw      R_FROM
  1129 00:0963: CD 09                        dw      FM_SLASH_MOD
  1130 00:0965: E3 0E                        dw      EXIT
  1131                        
  1132                        ; 1+ ( n1|u1 -- n2|u2 )
  1133                        ;
  1134                        ; Add one (1) to n1|u1 giving the sum n2|u2.
  1135                        
  1136 00:0967: 55 09 00 02                  HEADER  2,"1+",NORMAL
       00:096B: 31 2B 
  1137                        ONE_PLUS:
  1138 00:096D: E6 01                        inc     <1                      ; Increment top of stack
  1139 00:096F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0973: 00 00 
  1140                        
  1141                        ; 1- ( n1|u1 -- n2|u2 )
  1142                        ;
  1143                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
  1144                        
  1145 00:0975: 6A 09 00 02                  HEADER  2,"1-",NORMAL
       00:0979: 31 2D 
  1146                        ONE_MINUS:
  1147 00:097B: C6 01                        dec     <1                      ; Decrement top of stack
  1148 00:097D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0981: 00 00 
  1149                        
  1150                        ; 2* ( x1 -- x2 )
  1151                        ;
  1152                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
  1153                        ; filling the vacated least-significant bit with zero.
  1154                        
  Tue Aug 22 2017 23:21                                                                                                    Page 25


  1155 00:0983: 78 09 00 02                  HEADER  2,"2*",NORMAL
       00:0987: 32 2A 
  1156                        TWO_STAR:
  1157 00:0989: 06 01                        asl     <1                      ; Multiply top value by two
  1158 00:098B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:098F: 00 00 
  1159                        
  1160                        ; 2/ ( x1 -- x2 )
  1161                        ;
  1162                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
  1163                        ; leaving the most-significant bit unchanged.
  1164                        
  1165 00:0991: 86 09 00 02                  HEADER  2,"2/",NORMAL
       00:0995: 32 2F 
  1166                        TWO_SLASH:
  1167 00:0997: A5 01                        lda     <1                      ; Load the top value
  1168 00:0999: 2A                           rol     a                       ; Extract the top bit
  1169 00:099A: 66 01                        ror     <1                      ; And shift back into value
  1170 00:099C: BB C8 C8 7C                  CONTINUE
       00:09A0: 00 00 
  1171                        
  1172                        ; ?NEGATE ( x sign -- x/-x)
  1173                        ;
  1174                        ; If the sign value is negative then negate the value of x to match.
  1175                        ;
  1176                        ; In this implementation it is defined as:
  1177                        ;
  1178                        ;   0< IF NEGATE THEN
  1179                        
  1180 00:09A2: 20 BE 14     QUERY_NEGATE:   jsr     DO_COLON
  1181 00:09A5: DA 0C                        dw      ZERO_LESS
  1182 00:09A7: 7D 16 AD 09                  dw      QUERY_BRANCH,QUERY_NEGATE_1
  1183 00:09AB: 5C 0A                        dw      NEGATE
  1184 00:09AD: E3 0E        QUERY_NEGATE_1: dw      EXIT
  1185                        
  1186                        ; ABS ( n -- u )
  1187                        ;
  1188                        ; u is the absolute value of n.
  1189                        
  1190 00:09AF: 94 09 00 03                  HEADER  3,"ABS",NORMAL
       00:09B3: 41 42 53 
  1191                        ABS:
  1192 00:09B6: A5 01                        lda     <1
  1193 00:09B8: 10 03                        bpl     ABS_1
  1194 00:09BA: 4C 5C 0A                     jmp     NEGATE
  1195 00:09BD: BB C8 C8 7C  ABS_1:          CONTINUE                        ; Done
       00:09C1: 00 00 
  1196                        
  1197                        ; FM/MOD ( n1 n2 -- n3 n4 )
  1198                        ;
  1199                        ; Divide n1 by n2, giving the single-cell remainder n3 and the single-cell
  1200                        ; quotient n4. An ambiguous condition exists if n2 is zero. If n1 and n2 differ
  1201                        ; in sign, the implementation-defined result returned will be the same as that
  1202                        ; returned by either the phrase >R S>D R> FM/MOD or the phrase >R S>D R> SM/REM.
  1203                        ;
  1204                        ; In this implementation it is defined as:
  1205                        ;
  1206                        ;   DUP >R                      divisor
  Tue Aug 22 2017 23:21                                                                                                    Page 26


  1207                        ;   2DUP XOR >R                 sign of quotient
  1208                        ;   >R                          divisor
  1209                        ;   DABS R@ ABS UM/MOD
  1210                        ;   SWAP R> ?NEGATE SWAP        apply sign to remainder
  1211                        ;   R> 0< IF                    if quotient negative,
  1212                        ;       NEGATE
  1213                        ;       OVER IF                 if remainder nonzero,
  1214                        ;       R@ ROT - SWAP 1-        adjust rem,quot
  1215                        ;       THEN
  1216                        ;   THEN  R> DROP ;
  1217                        
  1218 00:09C3: B2 09 00 06                  HEADER  6,"FM/MOD",NORMAL
       00:09C7: 46 4D 2F 4D 
       00:09CB: 4F 44 
  1219 00:09CD: 20 BE 14     FM_SLASH_MOD:   jsr     DO_COLON
  1220 00:09D0: 82 07                        dw      DUP
  1221 00:09D2: 7B 08                        dw      TO_R
  1222 00:09D4: BF 06                        dw      TWO_DUP
  1223 00:09D6: 56 0E                        dw      XOR
  1224 00:09D8: 7B 08                        dw      TO_R
  1225 00:09DA: 7B 08                        dw      TO_R
  1226 00:09DC: 5C 0B                        dw      DABS
  1227 00:09DE: C7 08                        dw      R_FETCH
  1228 00:09E0: B6 09                        dw      ABS
  1229 00:09E2: A5 0C                        dw      UM_SLASH_MOD
  1230 00:09E4: 09 08                        dw      SWAP
  1231 00:09E6: B4 08                        dw      R_FROM
  1232 00:09E8: A2 09                        dw      QUERY_NEGATE
  1233 00:09EA: 09 08                        dw      SWAP
  1234 00:09EC: B4 08                        dw      R_FROM
  1235 00:09EE: DA 0C                        dw      ZERO_LESS
  1236 00:09F0: 7D 16 06 0A                  dw      QUERY_BRANCH,FM_SLASH_MOD_1
  1237 00:09F4: 5C 0A                        dw      NEGATE
  1238 00:09F6: A5 07                        dw      OVER
  1239 00:09F8: 7D 16 06 0A                  dw      QUERY_BRANCH,FM_SLASH_MOD_1
  1240 00:09FC: C7 08                        dw      R_FETCH
  1241 00:09FE: EF 07                        dw      ROT
  1242 00:0A00: 2B 09                        dw      MINUS
  1243 00:0A02: 09 08                        dw      SWAP
  1244 00:0A04: 7B 09                        dw      ONE_MINUS
  1245 00:0A06: B4 08        FM_SLASH_MOD_1: dw      R_FROM
  1246 00:0A08: 71 07                        dw      DROP
  1247 00:0A0A: E3 0E                        dw      EXIT
  1248                        
  1249                        ; MAX ( n1 n2 -- n3 )
  1250                        ;
  1251                        ; n3 is the greater of n1 and n2.
  1252                        
  1253 00:0A0C: C6 09 00 03                  HEADER  3,"MAX",NORMAL
       00:0A10: 4D 41 58 
  1254 00:0A13: 20 BE 14     MAX:            jsr     DO_COLON
  1255 00:0A16: BF 06                        dw      TWO_DUP
  1256 00:0A18: 2C 0D                        dw      LESS
  1257 00:0A1A: 7D 16 20 0A                  dw      QUERY_BRANCH,MAX_1
  1258 00:0A1E: 09 08                        dw      SWAP
  1259 00:0A20: 71 07        MAX_1:          dw      DROP
  1260 00:0A22: E3 0E                        dw      EXIT
  1261                        
  Tue Aug 22 2017 23:21                                                                                                    Page 27


  1262                        ; MIN ( n1 n2 -- n3 )
  1263                        ;
  1264                        ; n3 is the lesser of n1 and n2.
  1265                        
  1266 00:0A24: 0F 0A 00 03                  HEADER  3,"MIN",NORMAL
       00:0A28: 4D 49 4E 
  1267 00:0A2B: 20 BE 14     MIN:            jsr     DO_COLON
  1268 00:0A2E: BF 06                        dw      TWO_DUP
  1269 00:0A30: 6D 0D                        dw      GREATER
  1270 00:0A32: 7D 16 38 0A                  dw      QUERY_BRANCH,MIN_1
  1271 00:0A36: 09 08                        dw      SWAP
  1272 00:0A38: 71 07        MIN_1:          dw      DROP
  1273 00:0A3A: E3 0E                        dw      EXIT
  1274                        
  1275                        ; MOD ( n1 n2 -- n3 )
  1276                        ;
  1277                        ; Divide n1 by n2, giving the single-cell remainder n3. An ambiguous condition
  1278                        ; exists if n2 is zero. If n1 and n2 differ in sign, the implementation-defined
  1279                        ; result returned will be the same as that returned by either the phrase >R S>D
  1280                        ; R> FM/MOD DROP or the phrase >R S>D R> SM/REM DROP.
  1281                        ;
  1282                        ; In this implementation it is defined as:
  1283                        ;
  1284                        ;   >R S>D R> FM/MOD DROP
  1285                        
  1286 00:0A3C: 27 0A 00 03                  HEADER  3,"MOD",NORMAL
       00:0A40: 4D 4F 44 
  1287 00:0A43: 20 BE 14     MOD:            jsr     DO_COLON
  1288 00:0A46: 7B 08                        dw      TO_R
  1289 00:0A48: 13 0C                        dw      S_TO_D
  1290 00:0A4A: B4 08                        dw      R_FROM
  1291 00:0A4C: CD 09                        dw      FM_SLASH_MOD
  1292 00:0A4E: 71 07                        dw      DROP
  1293 00:0A50: E3 0E                        dw      EXIT
  1294                        
  1295                        ; NEGATE ( n1 -- n2 )
  1296                        ;
  1297                        ; Negate n1, giving its arithmetic inverse n2.
  1298                        
  1299 00:0A52: 3F 0A 00 06                  HEADER  6,"NEGATE",NORMAL
       00:0A56: 4E 45 47 41 
       00:0A5A: 54 45 
  1300                        NEGATE:
  1301 00:0A5C: 38                           sec                             ; Negate the top of stack
  1302 00:0A5D: A9 00 00                     lda     #0
  1303 00:0A60: E5 01                        sbc     <1
  1304 00:0A62: 85 01                        sta     <1
  1305 00:0A64: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A68: 00 00 
  1306                        
  1307                        ; UMAX ( x1 x2 -- x3 )
  1308                        ;
  1309                        ; x3 is the greater of x1 and x2.
  1310                        
  1311 00:0A6A: 55 0A 00 04                  HEADER  4,"UMAX",NORMAL
       00:0A6E: 55 4D 41 58 
  1312                        UMAX:
  1313 00:0A72: A5 01                        lda     <1                      ; Compare the top values
  Tue Aug 22 2017 23:21                                                                                                    Page 28


  1314 00:0A74: C5 03                        cmp     <3
  1315 00:0A76: B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
  1316 00:0A78: 4C 71 07                     jmp     DROP                    ; No, x1 is
  1317 00:0A7B: 4C 97 07     UMAX_EXIT:      jmp     NIP
  1318                        
  1319                        ; UMIN ( x1 x2 -- x3 )
  1320                        ;
  1321                        ; x3 is the lesser of x1 and x2.
  1322                        
  1323 00:0A7E: 6D 0A 00 04                  HEADER  4,"UMIN",NORMAL
       00:0A82: 55 4D 49 4E 
  1324                        UMIN:
  1325 00:0A86: A5 01                        lda     <1                      ; Compare the top values
  1326 00:0A88: C5 03                        cmp     <3
  1327 00:0A8A: 90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
  1328 00:0A8C: 4C 71 07                     jmp     DROP                    ; No, x1 is
  1329 00:0A8F: 4C 97 07     UMIN_EXIT:      jmp     NIP
  1330                        
  1331                        ;===============================================================================
  1332                        ; Double Precision Arithmetic
  1333                        ;-------------------------------------------------------------------------------
  1334                        
  1335                        ; ?DNEGATE ( d1 sign -- d1/-d1 )
  1336                        ;
  1337                        ; If sign is less than zero than negate d1 otherwise leave it unchanged.
  1338                        
  1339 00:0A92: 20 BE 14     QUERY_DNEGATE:  jsr     DO_COLON
  1340 00:0A95: DA 0C                        dw      ZERO_LESS
  1341 00:0A97: 7D 16 9D 0A                  dw      QUERY_BRANCH,QUERY_DNEG_1
  1342 00:0A9B: AC 0B                        dw      DNEGATE
  1343 00:0A9D: E3 0E        QUERY_DNEG_1:   dw      EXIT
  1344                        
  1345                        ; D+ ( d1|ud1 d2|ud2 -- d3|ud3 )
  1346                        ;
  1347                        ; Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
  1348                        
  1349 00:0A9F: 81 0A 00 02                  HEADER  2,"D+",NORMAL
       00:0AA3: 44 2B 
  1350                        D_PLUS:
  1351 00:0AA5: 18                           clc
  1352 00:0AA6: A5 07                        lda     <7                      ; Add low words
  1353 00:0AA8: 65 03                        adc     <3
  1354 00:0AAA: 85 07                        sta     <7
  1355 00:0AAC: A5 05                        lda     <5                      ; Then the high words
  1356 00:0AAE: 65 01                        adc     <1
  1357 00:0AB0: 85 05                        sta     <5
  1358 00:0AB2: 7B                           tdc                             ; Drop top double
  1359 00:0AB3: 1A                           inc     a
  1360 00:0AB4: 1A                           inc     a
  1361 00:0AB5: 1A                           inc     a
  1362 00:0AB6: 1A                           inc     a
  1363 00:0AB7: 5B                           tcd
  1364 00:0AB8: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0ABC: 00 00 
  1365                        
  1366                        ; D- ( d1|ud1 d2|ud2 -- d3|ud3 )
  1367                        ;
  1368                        ; Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
  Tue Aug 22 2017 23:21                                                                                                    Page 29


  1369                        
  1370 00:0ABE: A2 0A 00 02                  HEADER  2,"D-",NORMAL
       00:0AC2: 44 2D 
  1371                        D_MINUS:
  1372 00:0AC4: 38                           sec
  1373 00:0AC5: A5 07                        lda     <7                      ; Subtract low words
  1374 00:0AC7: E5 03                        sbc     <3
  1375 00:0AC9: 85 07                        sta     <7
  1376 00:0ACB: A5 05                        lda     <5                      ; Then the high words
  1377 00:0ACD: E5 01                        sbc     <1
  1378 00:0ACF: 85 05                        sta     <5
  1379 00:0AD1: 7B                           tdc                             ; Drop top double
  1380 00:0AD2: 1A                           inc     a
  1381 00:0AD3: 1A                           inc     a
  1382 00:0AD4: 1A                           inc     a
  1383 00:0AD5: 1A                           inc     a
  1384 00:0AD6: 5B                           tcd
  1385 00:0AD7: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0ADB: 00 00 
  1386                        
  1387                        ; D0< ( d -- flag )
  1388                        ;
  1389                        ; flag is true if and only if d is less than zero.
  1390                        
  1391 00:0ADD: C1 0A 00 03                  HEADER  3,"D0<",NORMAL
       00:0AE1: 44 30 3C 
  1392                        D_ZERO_LESS:
  1393 00:0AE4: A6 01                        ldx     <1                      ; Fetch sign
  1394 00:0AE6: 7B                           tdc                             ; Drop a word
  1395 00:0AE7: 1A                           inc     a
  1396 00:0AE8: 1A                           inc     a
  1397 00:0AE9: 5B                           tcd
  1398 00:0AEA: 64 01                        stz     <1                      ; Assume false
  1399 00:0AEC: 8A                           txa
  1400 00:0AED: 10 02                        bpl     D_ZERO_LESS_1
  1401 00:0AEF: C6 01                        dec     <1
  1402 00:0AF1: BB C8 C8 7C  D_ZERO_LESS_1:  CONTINUE
       00:0AF5: 00 00 
  1403                        
  1404                        ; D0= ( d -- flag )
  1405                        ;
  1406                        ; flag is true if and only if d is equal to zero.
  1407                        
  1408 00:0AF7: E0 0A 00 03                  HEADER  3,"D0=",NORMAL
       00:0AFB: 44 30 3D 
  1409                        D_ZERO_EQUAL:
  1410 00:0AFE: A6 01                        ldx     <1                      ; Fetch sign
  1411 00:0B00: 7B                           tdc                             ; Drop a word
  1412 00:0B01: 1A                           inc     a
  1413 00:0B02: 1A                           inc     a
  1414 00:0B03: 5B                           tcd
  1415 00:0B04: 64 01                        stz     <1                      ; Assume false
  1416 00:0B06: 8A                           txa
  1417 00:0B07: D0 02                        bne     D_ZERO_EQUAL_1
  1418 00:0B09: C6 01                        dec     <1
  1419 00:0B0B: BB C8 C8 7C  D_ZERO_EQUAL_1: CONTINUE
       00:0B0F: 00 00 
  1420                        
  Tue Aug 22 2017 23:21                                                                                                    Page 30


  1421                        ; D2* ( xd1 -- xd2 )
  1422                        ;
  1423                        ; xd2 is the result of shifting xd1 one bit toward the most-significant bit,
  1424                        ; filling the vacated least-significant bit with zero.
  1425                        
  1426 00:0B11: FA 0A 00 03                  HEADER  3,"D2*",NORMAL
       00:0B15: 44 32 2A 
  1427                        D_TWO_STAR:
  1428 00:0B18: 06 03                        asl     <3
  1429 00:0B1A: 26 01                        rol     <1
  1430 00:0B1C: BB C8 C8 7C                  CONTINUE
       00:0B20: 00 00 
  1431                        
  1432                        ; D2/ ( xd1 -- xd2 )
  1433                        ;
  1434                        ; xd2 is the result of shifting xd1 one bit toward the least-significant bit,
  1435                        ; leaving the most-significant bit unchanged.
  1436                        
  1437 00:0B22: 14 0B 00 03                  HEADER  3,"D2/",NORMAL
       00:0B26: 44 32 2F 
  1438                        D_TWO_SLASH:
  1439 00:0B29: A5 01                        lda     <1
  1440 00:0B2B: 2A                           rol     a
  1441 00:0B2C: 66 01                        ror     <1
  1442 00:0B2E: 66 03                        ror     <3
  1443 00:0B30: BB C8 C8 7C                  CONTINUE
       00:0B34: 00 00 
  1444                        
  1445                        ; D< ( d1 d2 -- flag )
  1446                        ;
  1447                        ; flag is true if and only if d1 is less than d2.
  1448                        
  1449 00:0B36: 25 0B 00 02                  HEADER  2,"D<",NORMAL
       00:0B3A: 44 3C 
  1450 00:0B3C: 20 BE 14     D_LESS:         jsr     DO_COLON
  1451 00:0B3F: C4 0A                        dw      D_MINUS
  1452 00:0B41: E4 0A                        dw      D_ZERO_LESS
  1453 00:0B43: E3 0E                        dw      EXIT
  1454                        
  1455                        ; D= ( d1 d2 -- flag )
  1456                        ;
  1457                        ; flag is true if and only if d1 is bit-for-bit the same as d2.
  1458                        
  1459 00:0B45: 39 0B 00 02                  HEADER  2,"D=",NORMAL
       00:0B49: 44 3D 
  1460 00:0B4B: 20 BE 14     D_EQUAL:        jsr     DO_COLON
  1461 00:0B4E: C4 0A                        dw      D_MINUS
  1462 00:0B50: FE 0A                        dw      D_ZERO_EQUAL
  1463 00:0B52: E3 0E                        dw      EXIT
  1464                        
  1465                        ; DABS ( d -- ud )
  1466                        ;
  1467                        ; ud is the absolute value of d.
  1468                        
  1469 00:0B54: 48 0B 00 04                  HEADER  4,"DABS",NORMAL
       00:0B58: 44 41 42 53 
  1470                        DABS:
  1471 00:0B5C: A5 01                        lda     <1
  Tue Aug 22 2017 23:21                                                                                                    Page 31


  1472 00:0B5E: 10 03                        bpl     DABS_1
  1473 00:0B60: 4C AC 0B                     jmp     DNEGATE
  1474 00:0B63: BB C8 C8 7C  DABS_1:         CONTINUE
       00:0B67: 00 00 
  1475                        
  1476                        ; DMAX ( d1 d2 -- d3 )
  1477                        ;
  1478                        ; d3 is the greater of d1 and d2.
  1479                        
  1480 00:0B69: 57 0B 00 04                  HEADER  4,"DMAX",NORMAL
       00:0B6D: 44 4D 41 58 
  1481 00:0B71: 20 BE 14     DMAX:           jsr     DO_COLON
  1482 00:0B74: DC 06                        dw      TWO_OVER
  1483 00:0B76: DC 06                        dw      TWO_OVER
  1484 00:0B78: 3C 0B                        dw      D_LESS
  1485 00:0B7A: 7D 16 80 0B                  dw      QUERY_BRANCH,DMAX_1
  1486 00:0B7E: 23 07                        dw      TWO_SWAP
  1487 00:0B80: AB 06        DMAX_1:         dw      TWO_DROP
  1488 00:0B82: E3 0E                        dw      EXIT
  1489                        
  1490                        ; DMIN ( d1 d2 -- d3 )
  1491                        ;
  1492                        ; d3 is the lesser of d1 and d2.
  1493                        
  1494 00:0B84: 6C 0B 00 04                  HEADER  4,"DMIN",NORMAL
       00:0B88: 44 4D 49 4E 
  1495 00:0B8C: 20 BE 14     DMIN:           jsr     DO_COLON
  1496 00:0B8F: DC 06                        dw      TWO_OVER
  1497 00:0B91: DC 06                        dw      TWO_OVER
  1498 00:0B93: 3C 0B                        dw      D_LESS
  1499 00:0B95: D4 0D                        dw      INVERT
  1500 00:0B97: 7D 16 9D 0B                  dw      QUERY_BRANCH,DMIN_1
  1501 00:0B9B: 23 07                        dw      TWO_SWAP
  1502 00:0B9D: AB 06        DMIN_1:         dw      TWO_DROP
  1503 00:0B9F: E3 0E                        dw      EXIT
  1504                        
  1505                        ; DNEGATE ( d1 -- d2 )
  1506                        ;
  1507                        ; d2 is the negation of d1.
  1508                        
  1509 00:0BA1: 87 0B 00 07                  HEADER  7,"DNEGATE",NORMAL
       00:0BA5: 44 4E 45 47 
       00:0BA9: 41 54 45 
  1510                        DNEGATE:
  1511 00:0BAC: 38                           sec
  1512 00:0BAD: A9 00 00                     lda     #0                      ; Subtract low word from zero
  1513 00:0BB0: E5 03                        sbc     <3
  1514 00:0BB2: 85 03                        sta     <3
  1515 00:0BB4: A9 00 00                     lda     #0                      ; Then the high word
  1516 00:0BB7: E5 01                        sbc     <1
  1517 00:0BB9: 85 01                        sta     <1
  1518 00:0BBB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0BBF: 00 00 
  1519                        
  1520                        ;===============================================================================
  1521                        ; Mixed Arithmetic
  1522                        ;-------------------------------------------------------------------------------
  1523                        
  Tue Aug 22 2017 23:21                                                                                                    Page 32


  1524                        ; D>S ( d -- n )
  1525                        ;
  1526                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1527                        ; range of a signed single-cell number.
  1528                        
  1529 00:0BC1: A4 0B 00 03                  HEADER  3,"D>S",NORMAL
       00:0BC5: 44 3E 53 
  1530                        D_TO_S:
  1531 00:0BC8: 7B                           tdc
  1532 00:0BC9: 1A                           inc     a                       ; Drop the high word
  1533 00:0BCA: 1A                           inc     a
  1534 00:0BCB: 5B                           tcd
  1535 00:0BCC: BB C8 C8 7C                  CONTINUE
       00:0BD0: 00 00 
  1536                        
  1537                        ; M* ( n1 n2 -- d )
  1538                        ;
  1539                        ; d is the signed product of n1 times n2.
  1540                        ;
  1541                        ; In this implementation it is defined as:
  1542                        ;
  1543                        ;   2DUP XOR >R                 carries sign of the result
  1544                        ;   SWAP ABS SWAP ABS UM*
  1545                        ;   R> ?DNEGATE
  1546                        
  1547 00:0BD2: C4 0B 00 02                  HEADER  2,"M*",NORMAL
       00:0BD6: 4D 2A 
  1548 00:0BD8: 20 BE 14     M_STAR:         jsr     DO_COLON
  1549 00:0BDB: BF 06                        dw      TWO_DUP
  1550 00:0BDD: 56 0E                        dw      XOR
  1551 00:0BDF: 7B 08                        dw      TO_R
  1552 00:0BE1: 09 08                        dw      SWAP
  1553 00:0BE3: B6 09                        dw      ABS
  1554 00:0BE5: 09 08                        dw      SWAP
  1555 00:0BE7: B6 09                        dw      ABS
  1556 00:0BE9: 79 0C                        dw      UM_STAR
  1557 00:0BEB: B4 08                        dw      R_FROM
  1558 00:0BED: 92 0A                        dw      QUERY_DNEGATE
  1559 00:0BEF: E3 0E                        dw      EXIT
  1560                        
  1561                        ; M*/ ( d1 n1 +n2 -- d2 )
  1562                        ;
  1563                        ; Multiply d1 by n1 producing the triple-cell intermediate result t. Divide t
  1564                        ; by +n2 giving the double-cell quotient d2. An ambiguous condition exists if
  1565                        ; +n2 is zero or negative, or the quotient lies outside of the range of a
  1566                        ; double-precision signed integer.
  1567                        
  1568                        
  1569                        
  1570                        ; M+ ( d1|ud1 n -- d2|ud2 )
  1571                        ;
  1572                        ; Add n to d1|ud1, giving the sum d2|ud2.
  1573                        
  1574 00:0BF1: D5 0B 00 02                  HEADER  2,"M+",NORMAL
       00:0BF5: 4D 2B 
  1575                        M_PLUS:
  1576 00:0BF7: 18                           clc
  1577 00:0BF8: A5 01                        lda     <1
  Tue Aug 22 2017 23:21                                                                                                    Page 33


  1578 00:0BFA: 65 05                        adc     <5
  1579 00:0BFC: 85 05                        sta     <5
  1580 00:0BFE: 90 02                        bcc     $+4
  1581 00:0C00: E6 03                        inc     <3
  1582 00:0C02: 7B                           tdc
  1583 00:0C03: 1A                           inc     a
  1584 00:0C04: 1A                           inc     a
  1585 00:0C05: 5B                           tcd
  1586 00:0C06: BB C8 C8 7C                  CONTINUE
       00:0C0A: 00 00 
  1587                        
  1588                        ; S>D ( n -- d )
  1589                        ;
  1590                        ; Convert the number n to the double-cell number d with the same numerical
  1591                        ; value.
  1592                        
  1593 00:0C0C: F4 0B 00 03                  HEADER  3,"S>D",NORMAL
       00:0C10: 53 3E 44 
  1594                        S_TO_D:
  1595 00:0C13: 7B                           tdc
  1596 00:0C14: 3A                           dec     a                       ; Assume n is positive
  1597 00:0C15: 3A                           dec     a
  1598 00:0C16: 5B                           tcd
  1599 00:0C17: 64 01                        stz     <1                      ; .. push a zero value
  1600 00:0C19: A5 03                        lda     <3                      ; Test the number
  1601 00:0C1B: 10 02                        bpl     S_TO_D_1
  1602 00:0C1D: C6 01                        dec     <1                      ; Make top -1 if negative
  1603 00:0C1F: BB C8 C8 7C  S_TO_D_1        CONTINUE                        ; Done
       00:0C23: 00 00 
  1604                        
  1605                        ; SM/REM ( d1 n1 -- n2 n3 )
  1606                        ;
  1607                        ; Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2.
  1608                        ; Input and output stack arguments are signed. An ambiguous condition exists if
  1609                        ; n1 is zero or if the quotient lies outside the range of a single-cell signed
  1610                        ; integer.
  1611                        ;
  1612                        ; In this implementation it is defined as:
  1613                        ;
  1614                        ;   2DUP XOR >R                 sign of quotient
  1615                        ;   OVER >R                     sign of remainder
  1616                        ;   ABS >R DABS R> UM/MOD
  1617                        ;   SWAP R> ?NEGATE
  1618                        ;   SWAP R> ?NEGATE ;
  1619                        
  1620 00:0C25: 0F 0C 00 06                  HEADER  6,"SM/REM",NORMAL
       00:0C29: 53 4D 2F 52 
       00:0C2D: 45 4D 
  1621 00:0C2F: 20 BE 14     SM_SLASH_REM:   jsr     DO_COLON
  1622 00:0C32: BF 06                        dw      TWO_DUP
  1623 00:0C34: 56 0E                        dw      XOR
  1624 00:0C36: 7B 08                        dw      TO_R
  1625 00:0C38: A5 07                        dw      OVER
  1626 00:0C3A: 7B 08                        dw      TO_R
  1627 00:0C3C: B6 09                        dw      ABS
  1628 00:0C3E: 7B 08                        dw      TO_R
  1629 00:0C40: 5C 0B                        dw      DABS
  1630 00:0C42: B4 08                        dw      R_FROM
  Tue Aug 22 2017 23:21                                                                                                    Page 34


  1631 00:0C44: A5 0C                        dw      UM_SLASH_MOD
  1632 00:0C46: 09 08                        dw      SWAP
  1633 00:0C48: B4 08                        dw      R_FROM
  1634 00:0C4A: A2 09                        dw      QUERY_NEGATE
  1635 00:0C4C: 09 08                        dw      SWAP
  1636 00:0C4E: B4 08                        dw      R_FROM
  1637 00:0C50: A2 09                        dw      QUERY_NEGATE
  1638 00:0C52: E3 0E                        dw      EXIT
  1639                        
  1640                        ; UD* ( ud1 d2 -- ud3)
  1641                        ;
  1642                        ; 32*16->32 multiply
  1643                        ;
  1644                        ;   DUP >R UM* DROP  SWAP R> UM* ROT + ;
  1645                        
  1646 00:0C54: 28 0C 00 03                  HEADER  3,"UD*",NORMAL
       00:0C58: 55 44 2A 
  1647 00:0C5B: 20 BE 14     UD_STAR:        jsr     DO_COLON
  1648 00:0C5E: 82 07                        dw      DUP
  1649 00:0C60: 7B 08                        dw      TO_R
  1650 00:0C62: 79 0C                        dw      UM_STAR
  1651 00:0C64: 71 07                        dw      DROP
  1652 00:0C66: 09 08                        dw      SWAP
  1653 00:0C68: B4 08                        dw      R_FROM
  1654 00:0C6A: 79 0C                        dw      UM_STAR
  1655 00:0C6C: EF 07                        dw      ROT
  1656 00:0C6E: 15 09                        dw      PLUS
  1657 00:0C70: E3 0E                        dw      EXIT
  1658                        
  1659                        ; UM* ( u1 u2 -- ud )
  1660                        ;
  1661                        ; Multiply u1 by u2, giving the unsigned double-cell product ud. All values and
  1662                        ; arithmetic are unsigned.
  1663                        
  1664 00:0C72: 57 0C 00 03                  HEADER  3,"UM*",NORMAL
       00:0C76: 55 4D 2A 
  1665                        UM_STAR:
  1666 00:0C79: A5 01                        lda     <1                      ; Fetch multiplier
  1667 00:0C7B: 48                           pha
  1668 00:0C7C: 64 01                        stz     <1                      ; Clear the result
  1669 00:0C7E: A2 10 00                     ldx     #16
  1670 00:0C81: A5 03        UM_STAR_1:      lda     <3                      ; Shift multiplier one bit
  1671 00:0C83: 4A                           lsr     a
  1672 00:0C84: 90 07                        bcc     UM_STAR_2               ; Not set, no add
  1673 00:0C86: A3 01                        lda     1,s                     ; Fetch multiplicand
  1674 00:0C88: 18                           clc
  1675 00:0C89: 65 01                        adc     <1
  1676 00:0C8B: 85 01                        sta     <1
  1677 00:0C8D: 66 01        UM_STAR_2:      ror     <1                      ; Rotate high word down
  1678 00:0C8F: 66 03                        ror     <3
  1679 00:0C91: CA                           dex
  1680 00:0C92: D0 ED                        bne     UM_STAR_1
  1681 00:0C94: 68                           pla
  1682 00:0C95: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0C99: 00 00 
  1683                        
  1684                        ; UM/MOD ( ud u1 -- u2 u3 )
  1685                        ;
  Tue Aug 22 2017 23:21                                                                                                    Page 35


  1686                        ; Divide ud by u1, giving the quotient u3 and the remainder u2. All values and
  1687                        ; arithmetic are unsigned. An ambiguous condition exists if u1 is zero or if the
  1688                        ; quotient lies outside the range of a single-cell unsigned integer.
  1689                        
  1690 00:0C9B: 75 0C 00 06                  HEADER  6,"UM/MOD",NORMAL
       00:0C9F: 55 4D 2F 4D 
       00:0CA3: 4F 44 
  1691                        UM_SLASH_MOD:
  1692 00:0CA5: 38                           sec                             ; Check for overflow
  1693 00:0CA6: A5 03                        lda     <3
  1694 00:0CA8: E5 01                        sbc     <1
  1695 00:0CAA: B0 1A                        bcs     UM_SLASH_MOD_3
  1696                        
  1697 00:0CAC: A2 11 00                     ldx     #17
  1698 00:0CAF: 26 05        UM_SLASH_MOD_1: rol     <5                      ; Rotate dividend lo
  1699 00:0CB1: CA                           dex
  1700 00:0CB2: F0 19                        beq     UM_SLASH_MOD_4
  1701 00:0CB4: 26 03                        rol     <3
  1702 00:0CB6: B0 06                        bcs     UM_SLASH_MOD_2          ; Carry set dividend > divisor
  1703                        
  1704 00:0CB8: A5 03                        lda     <3                      ; Is dividend < divisor?
  1705 00:0CBA: C5 01                        cmp     <1
  1706 00:0CBC: 90 F1                        bcc     UM_SLASH_MOD_1          ; Yes, shift in 0
  1707                        
  1708 00:0CBE: A5 03        UM_SLASH_MOD_2: lda     <3                      ; Reduce dividend
  1709 00:0CC0: E5 01                        sbc     <1
  1710 00:0CC2: 85 03                        sta     <3
  1711 00:0CC4: 80 E9                        bra     UM_SLASH_MOD_1          ; Shift in 1
  1712                        
  1713 00:0CC6: A9 FF FF     UM_SLASH_MOD_3: lda     #$ffff                  ; Overflowed set results
  1714 00:0CC9: 85 03                        sta     <3
  1715 00:0CCB: 85 05                        sta     <5
  1716 00:0CCD: 7B           UM_SLASH_MOD_4: tdc                             ; Drop top word
  1717 00:0CCE: 1A                           inc     a
  1718 00:0CCF: 1A                           inc     a
  1719 00:0CD0: 5B                           tcd
  1720 00:0CD1: 4C 09 08                     jmp     SWAP                    ; Swap quotient and remainder
  1721                        
  1722                        ;===============================================================================
  1723                        ; Comparisons
  1724                        ;-------------------------------------------------------------------------------
  1725                        
  1726                        ; 0< ( n -- flag )
  1727                        ;
  1728                        ; flag is true if and only if n is less than zero.
  1729                        
  1730 00:0CD4: 9E 0C 00 02                  HEADER  2,"0<",NORMAL
       00:0CD8: 30 3C 
  1731                        ZERO_LESS:
  1732 00:0CDA: A5 01                        lda     <1                      ; Test top of stack
  1733 00:0CDC: 64 01                        stz     <1                      ; Assume false result
  1734 00:0CDE: 10 02                        bpl     ZERO_LT_1               ; Was the value negative?
  1735 00:0CE0: C6 01                        dec     <1                      ; Yes, make true result
  1736 00:0CE2: BB C8 C8 7C  ZERO_LT_1:      CONTINUE                        ; Done
       00:0CE6: 00 00 
  1737                        
  1738                        ; 0<> ( x -- flag )
  1739                        ;
  Tue Aug 22 2017 23:21                                                                                                    Page 36


  1740                        ; flag is true if and only if x is not equal to zero.
  1741                        
  1742 00:0CE8: D7 0C 00 03                  HEADER  3,"0<>",NORMAL
       00:0CEC: 30 3C 3E 
  1743                        ZERO_NOT_EQUAL:
  1744 00:0CEF: A5 01                        lda     <1                      ; Test top of stack
  1745 00:0CF1: 64 01                        stz     <1                      ; Assume false result
  1746 00:0CF3: F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
  1747 00:0CF5: C6 01                        dec     <1                      ; Yes, make true result
  1748 00:0CF7: BB C8 C8 7C  ZERO_NE_1:      CONTINUE                        ; Done
       00:0CFB: 00 00 
  1749                        
  1750                        ; 0= ( x -- flag )
  1751                        ;
  1752                        ; flag is true if and only if x is equal to zero.
  1753                        
  1754 00:0CFD: EB 0C 00 02                  HEADER  2,"0=",NORMAL
       00:0D01: 30 3D 
  1755                        ZERO_EQUAL:
  1756 00:0D03: A5 01                        lda     <1                      ; Test top of stack
  1757 00:0D05: 64 01                        stz     <1                      ; Assume false result
  1758 00:0D07: D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
  1759 00:0D09: C6 01                        dec     <1                      ; Yes, make true result
  1760 00:0D0B: BB C8 C8 7C  ZERO_EQ_1:      CONTINUE                        ; Done
       00:0D0F: 00 00 
  1761                        
  1762                        ; 0> ( n -- flag )
  1763                        ;
  1764                        ; flag is true if and only if n is greater than zero.
  1765                        
  1766 00:0D11: 00 0D 00 02                  HEADER  2,"0>",NORMAL
       00:0D15: 30 3E 
  1767                        ZERO_GREATER:
  1768 00:0D17: A5 01                        lda     <1                      ; Test top of stack
  1769 00:0D19: 64 01                        stz     <1                      ; Assume false result
  1770 00:0D1B: 30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
  1771 00:0D1D: F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
  1772 00:0D1F: C6 01                        dec     <1                      ; Yes, make true result
  1773 00:0D21: BB C8 C8 7C  ZERO_GT_EXIT:   CONTINUE                        ; Done
       00:0D25: 00 00 
  1774                        
  1775                        ; < ( n1 n2 -- flag )
  1776                        ;
  1777                        ; flag is true if and only if n1 is less than n2.
  1778                        
  1779 00:0D27: 14 0D 00 01                  HEADER  1,"<",NORMAL
       00:0D2B: 3C 
  1780 00:0D2C: 20 BE 14     LESS:           jsr     DO_COLON
  1781 00:0D2F: 09 08                        dw      SWAP
  1782 00:0D31: 6D 0D                        dw      GREATER
  1783 00:0D33: E3 0E                        dw      EXIT
  1784                        
  1785                        ; <> ( x1 x2 -- flag )
  1786                        ;
  1787                        ; flag is true if and only if x1 is not bit-for-bit the same as x2.
  1788                        
  1789 00:0D35: 2A 0D 00 02                  HEADER  2,"<>",NORMAL
       00:0D39: 3C 3E 
  Tue Aug 22 2017 23:21                                                                                                    Page 37


  1790                        NOT_EQUAL:
  1791 00:0D3B: A6 01                        ldx     <1                      ; Pull x2 from stack
  1792 00:0D3D: 7B                           tdc
  1793 00:0D3E: 1A                           inc     a
  1794 00:0D3F: 1A                           inc     a
  1795 00:0D40: 5B                           tcd
  1796 00:0D41: E4 01                        cpx     <1                      ; Compare with x1
  1797 00:0D43: 64 01                        stz     <1                      ; Assume equal
  1798 00:0D45: F0 02                        beq     NE_EXIT                 ; Test flags
  1799 00:0D47: C6 01                        dec     <1                      ; Make result true
  1800 00:0D49: BB C8 C8 7C  NE_EXIT:        CONTINUE                        ; Done
       00:0D4D: 00 00 
  1801                        
  1802                        ; = ( x1 x2 -- flag )
  1803                        ;
  1804                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  1805                        
  1806 00:0D4F: 38 0D 00 01                  HEADER  1,"=",NORMAL
       00:0D53: 3D 
  1807                        EQUAL:
  1808 00:0D54: A6 01                        ldx     <1                      ; Pull x2 from stack
  1809 00:0D56: 7B                           tdc
  1810 00:0D57: 1A                           inc     a
  1811 00:0D58: 1A                           inc     a
  1812 00:0D59: 5B                           tcd
  1813 00:0D5A: E4 01                        cpx     <1                      ; Compare with x1
  1814 00:0D5C: 64 01                        stz     <1                      ; Assume not equal
  1815 00:0D5E: D0 02                        bne     EQ_EXIT                 ; Test the flags
  1816 00:0D60: C6 01                        dec     <1                      ; Make result true
  1817 00:0D62: BB C8 C8 7C  EQ_EXIT:        CONTINUE                        ; Done
       00:0D66: 00 00 
  1818                        
  1819                        ; > ( n1 n2 -- flag )
  1820                        ;
  1821                        ; flag is true if and only if n1 is greater than n2.
  1822                        
  1823 00:0D68: 52 0D 00 01                  HEADER  1,">",NORMAL
       00:0D6C: 3E 
  1824                        GREATER:
  1825 00:0D6D: A6 01                        ldx     <1                      ; Pull x2 from stack
  1826 00:0D6F: 7B                           tdc
  1827 00:0D70: 1A                           inc     a
  1828 00:0D71: 1A                           inc     a
  1829 00:0D72: 5B                           tcd
  1830 00:0D73: 8A                           txa
  1831 00:0D74: 38                           sec                             ; Compare with x1
  1832 00:0D75: E5 01                        sbc     <1
  1833 00:0D77: 64 01                        stz     <1                      ; Assume false result
  1834 00:0D79: 50 03                        bvc     GREATER_1
  1835 00:0D7B: 49 00 80                     eor     #$8000
  1836 00:0D7E: 10 02        GREATER_1:      bpl     GREATER_2               ; V == 1 && N == 1
  1837 00:0D80: C6 01                        dec     <1
  1838 00:0D82: BB C8 C8 7C  GREATER_2:      CONTINUE
       00:0D86: 00 00 
  1839                        
  1840                        ; U< ( u1 u2 -- flag )
  1841                        ;
  1842                        ; flag is true if and only if u1 is less than u2.
  Tue Aug 22 2017 23:21                                                                                                    Page 38


  1843                        
  1844 00:0D88: 6B 0D 00 02                  HEADER  2,"U<",NORMAL
       00:0D8C: 55 3C 
  1845                        U_LESS:
  1846 00:0D8E: A6 01                        ldx     <1                      ; Pull x2
  1847 00:0D90: 7B                           tdc                             ; Drop from stack
  1848 00:0D91: 1A                           inc     a
  1849 00:0D92: 1A                           inc     a
  1850 00:0D93: 5B                           tcd
  1851 00:0D94: E4 01                        cpx     <1                      ; Compare with x1
  1852 00:0D96: 64 01                        stz     <1                      ; Assume false
  1853 00:0D98: F0 04                        beq     U_LESS_1                ; Equal
  1854 00:0D9A: 90 02                        bcc     U_LESS_1                ; Less
  1855 00:0D9C: C6 01                        dec     <1
  1856 00:0D9E: BB C8 C8 7C  U_LESS_1:       CONTINUE
       00:0DA2: 00 00 
  1857                        
  1858                        ; U> ( u1 u2 -- flag )
  1859                        ;
  1860                        ; flag is true if and only if u1 is greater than u2.
  1861                        
  1862 00:0DA4: 8B 0D 00 02                  HEADER  2,"U>",NORMAL
       00:0DA8: 55 3E 
  1863 00:0DAA: 20 BE 14     U_GREATER:      jsr     DO_COLON
  1864 00:0DAD: 09 08                        dw      SWAP
  1865 00:0DAF: 8E 0D                        dw      U_LESS
  1866 00:0DB1: E3 0E                        dw      EXIT
  1867                        
  1868                        ;===============================================================================
  1869                        ; Logical Operations
  1870                        ;-------------------------------------------------------------------------------
  1871                        
  1872                        ; AND ( x1 x2 -- x3 )
  1873                        ;
  1874                        ; x3 is the bit-by-bit logical and of x1 with x2.
  1875                        
  1876 00:0DB3: A7 0D 00 03                  HEADER  3,"AND",NORMAL
       00:0DB7: 41 4E 44 
  1877                        AND:
  1878 00:0DBA: A5 01                        lda     <1
  1879 00:0DBC: 25 03                        and     <3
  1880 00:0DBE: 85 03                        sta     <3
  1881 00:0DC0: 7B                           tdc
  1882 00:0DC1: 1A                           inc     a
  1883 00:0DC2: 1A                           inc     a
  1884 00:0DC3: 5B                           tcd
  1885 00:0DC4: BB C8 C8 7C                  CONTINUE
       00:0DC8: 00 00 
  1886                        
  1887                        ; INVERT ( x1 -- x2 )
  1888                        ;
  1889                        ; Invert all bits of x1, giving its logical inverse x2.
  1890                        
  1891 00:0DCA: B6 0D 00 06                  HEADER  6,"INVERT",NORMAL
       00:0DCE: 49 4E 56 45 
       00:0DD2: 52 54 
  1892                        INVERT:
  1893 00:0DD4: A5 01                        lda     <1                      ; Fetch top value
  Tue Aug 22 2017 23:21                                                                                                    Page 39


  1894 00:0DD6: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1895 00:0DD9: 85 01                        sta     <1                      ; .. and write back
  1896 00:0DDB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0DDF: 00 00 
  1897                        
  1898                        ; LSHIFT ( x1 u -- x2 )
  1899                        ;
  1900                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1901                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1902                        ; exists if u is greater than or equal to the number of bits in a cell.
  1903                        
  1904 00:0DE1: CD 0D 00 06                  HEADER  6,"LSHIFT",NORMAL
       00:0DE5: 4C 53 48 49 
       00:0DE9: 46 54 
  1905                        LSHIFT:
  1906 00:0DEB: A6 01                        ldx     <1                      ; Pull bit count
  1907 00:0DED: 08                           php
  1908 00:0DEE: 7B                           tdc
  1909 00:0DEF: 1A                           inc     a                       ; .. from the stack
  1910 00:0DF0: 1A                           inc     a
  1911 00:0DF1: 5B                           tcd
  1912 00:0DF2: 28                           plp
  1913 00:0DF3: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1914 00:0DF5: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1915 00:0DF8: B0 0B                        bcs     LSHIFT_2                ; Yes, result will be zero
  1916 00:0DFA: 06 01        LSHIFT_1        asl     <1                      ; Shift one bit left
  1917 00:0DFC: CA                           dex                             ; Update count
  1918 00:0DFD: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  1919 00:0DFF: BB C8 C8 7C  LSHIFT_0        CONTINUE                        ; Done
       00:0E03: 00 00 
  1920 00:0E05: 64 01        LSHIFT_2        stz     <1                      ; Clear top value
  1921 00:0E07: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0E0B: 00 00 
  1922                        
  1923                        ; OR ( x1 x2 -- x3 )
  1924                        ;
  1925                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1926                        
  1927 00:0E0D: E4 0D 00 02                  HEADER  2,"OR",NORMAL
       00:0E11: 4F 52 
  1928                        OR:
  1929 00:0E13: A5 01                        lda     <1
  1930 00:0E15: 05 03                        ora     <3
  1931 00:0E17: 85 03                        sta     <3
  1932 00:0E19: 7B                           tdc
  1933 00:0E1A: 1A                           inc     a
  1934 00:0E1B: 1A                           inc     a
  1935 00:0E1C: 5B                           tcd
  1936 00:0E1D: BB C8 C8 7C                  CONTINUE
       00:0E21: 00 00 
  1937                        
  1938                        ; RSHIFT ( x1 u -- x2 )
  1939                        ;
  1940                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1941                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1942                        ; exists if u is greater than or equal to the number of bits in a cell.
  1943                        
  1944 00:0E23: 10 0E 00 06                  HEADER  6,"RSHIFT",NORMAL
  Tue Aug 22 2017 23:21                                                                                                    Page 40


       00:0E27: 52 53 48 49 
       00:0E2B: 46 54 
  1945                        RSHIFT:
  1946 00:0E2D: A6 01                        ldx     <1                      ; Pull bit count
  1947 00:0E2F: 08                           php
  1948 00:0E30: 7B                           tdc
  1949 00:0E31: 1A                           inc     a                       ; .. from the stack
  1950 00:0E32: 1A                           inc     a
  1951 00:0E33: 5B                           tcd
  1952 00:0E34: 28                           plp
  1953 00:0E35: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1954 00:0E37: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1955 00:0E3A: B0 0B                        bcs     RSHIFT_2                ; Yes, result will be zero
  1956 00:0E3C: 46 01        RSHIFT_1        lsr     <1                      ; Shift one bit left
  1957 00:0E3E: CA                           dex                             ; Update count
  1958 00:0E3F: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1959 00:0E41: BB C8 C8 7C  RSHIFT_0        CONTINUE                        ; Done
       00:0E45: 00 00 
  1960 00:0E47: 64 01        RSHIFT_2        stz     <1                      ; Clear top value
  1961 00:0E49: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0E4D: 00 00 
  1962                        
  1963                        ; XOR ( x1 x2 -- x3 )
  1964                        ;
  1965                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1966                        
  1967 00:0E4F: 26 0E 00 03                  HEADER  3,"XOR",NORMAL
       00:0E53: 58 4F 52 
  1968                        XOR:
  1969 00:0E56: A5 01                        lda     <1
  1970 00:0E58: 45 03                        eor     <3
  1971 00:0E5A: 85 03                        sta     <3
  1972 00:0E5C: 7B                           tdc
  1973 00:0E5D: 1A                           inc     a
  1974 00:0E5E: 1A                           inc     a
  1975 00:0E5F: 5B                           tcd
  1976 00:0E60: BB C8 C8 7C                  CONTINUE
       00:0E64: 00 00 
  1977                        
  1978                        ;===============================================================================
  1979                        ; Control Words
  1980                        ;-------------------------------------------------------------------------------
  1981                        
  1982                        ; ?ABORT
  1983                        ;
  1984                        ;   ROT IF TYPE ABORT THEN 2DROP ;
  1985                        
  1986 00:0E66: 20 BE 14     QUERY_ABORT:    jsr     DO_COLON
  1987 00:0E69: EF 07                        dw      ROT
  1988 00:0E6B: 7D 16 73 0E                  dw      QUERY_BRANCH,QUERY_ABORT_1
  1989 00:0E6F: FC 18                        dw      TYPE
  1990 00:0E71: 80 0E                        dw      ABORT
  1991 00:0E73: AB 06        QUERY_ABORT_1:  dw      TWO_DROP
  1992 00:0E75: E3 0E                        dw      EXIT
  1993                        
  1994                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1995                        ;
  1996                        ; Empty the data stack and perform the function of QUIT, which includes
  Tue Aug 22 2017 23:21                                                                                                    Page 41


  1997                        ; emptying the return stack, without displaying a message.
  1998                        
  1999 00:0E77: 52 0E 00 05                  HEADER  5,"ABORT",NORMAL
       00:0E7B: 41 42 4F 52 
       00:0E7F: 54 
  2000 00:0E80: 20 BE 14     ABORT:          jsr     DO_COLON
  2001 00:0E83: 87 0E                        dw      DO_ABORT
  2002 00:0E85: F2 0E                        dw      QUIT
  2003                        
  2004                        DO_ABORT:
  2005 00:0E87: A9 7F 01                     lda     #DSTACK_END-1
  2006 00:0E8A: 5B                           tcd
  2007 00:0E8B: BB C8 C8 7C                  CONTINUE
       00:0E8F: 00 00 
  2008                        
  2009                        ; (BUILD) ( dtc-addr -- )
  2010                        ;
  2011                        ; Adds a jump the to exection function for the new word.
  2012                        
  2013                        ;               HEADER  7,"(BUILD)",NORMAL
  2014 00:0E91: 20 BE 14     BUILD:          jsr     DO_COLON
  2015 00:0E94: C4 16 20 00                  dw      DO_LITERAL,$20
  2016 00:0E98: F5 05                        dw      C_COMMA
  2017 00:0E9A: 79 05                        dw      COMMA
  2018 00:0E9C: E3 0E                        dw      EXIT
  2019                        
  2020                        ; CREATE ( -- )
  2021                        ;
  2022                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2023                        ; definition for name with the execution semantics defined below. If the data-
  2024                        ; space pointer is not aligned, reserve enough data space to align it. The new
  2025                        ; data-space pointer defines names data field. CREATE does not allocate data
  2026                        ; space in names data field.
  2027                        
  2028 00:0E9E: 7A 0E 00 06                  HEADER  6,"CREATE",NORMAL
       00:0EA2: 43 52 45 41 
       00:0EA6: 54 45 
  2029 00:0EA8: 20 BE 14     CREATE:         jsr     DO_COLON
  2030 00:0EAB: 94 04                        dw      LATEST
  2031 00:0EAD: B9 05                        dw      FETCH
  2032 00:0EAF: 79 05                        dw      COMMA
  2033 00:0EB1: CE 04                        dw      ZERO
  2034 00:0EB3: F5 05                        dw      C_COMMA
  2035 00:0EB5: 24 06                        dw      HERE
  2036 00:0EB7: 94 04                        dw      LATEST
  2037 00:0EB9: 4B 05                        dw      STORE
  2038 00:0EBB: E0 04                        dw      BL
  2039 00:0EBD: B1 12                        dw      WORD
  2040 00:0EBF: 0C 06                        dw      C_FETCH
  2041 00:0EC1: 6D 09                        dw      ONE_PLUS
  2042 00:0EC3: CC 05                        dw      ALLOT
  2043 00:0EC5: E3 0E                        dw      EXIT
  2044                        
  2045                        ; EXECUTE ( i*x xt -- j*x )
  2046                        ;
  2047                        ; Remove xt from the stack and perform the semantics identified by it. Other
  2048                        ; stack effects are due to the word EXECUTEd.
  2049                        
  Tue Aug 22 2017 23:21                                                                                                    Page 42


  2050 00:0EC7: A1 0E 00 07                  HEADER  7,"EXECUTE",NORMAL
       00:0ECB: 45 58 45 43 
       00:0ECF: 55 54 45 
  2051                        EXECUTE:
  2052 00:0ED2: A6 01                        ldx     <1
  2053 00:0ED4: 7B                           tdc
  2054 00:0ED5: 1A                           inc     a
  2055 00:0ED6: 1A                           inc     a
  2056 00:0ED7: 5B                           tcd
  2057 00:0ED8: CA                           dex
  2058 00:0ED9: DA                           phx
  2059 00:0EDA: 60                           rts
  2060                        
  2061                        ; EXIT ( -- ) ( R: nest-sys -- )
  2062                        ;
  2063                        ; Return control to the calling definition specified by nest-sys. Before
  2064                        ; executing EXIT within a do-loop, a program shall discard the loop-control
  2065                        ; parameters by executing UNLOOP.
  2066                        
  2067 00:0EDB: CA 0E 00 04                  HEADER  4,"EXIT",NORMAL
       00:0EDF: 45 58 49 54 
  2068                        EXIT:
  2069 00:0EE3: 7A                           ply
  2070 00:0EE4: BB C8 C8 7C                  CONTINUE
       00:0EE8: 00 00 
  2071                        
  2072                        ; QUIT ( -- ) ( R: i*x -- )
  2073                        ;
  2074                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  2075                        ; user input device the input source, and enter interpretation state. Do not
  2076                        ; display a message. Repeat the following:
  2077                        ;  Accept a line from the input source into the input buffer, set >IN to zero,
  2078                        ;   and interpret.
  2079                        ;  Display the implementation-defined system prompt if in interpretation state,
  2080                        ;   all processing has been completed, and no ambiguous condition exists.
  2081                        ;
  2082                        ; In this implementation it is defined as:
  2083                        ;
  2084                        ;   DO_QUIT 0 STATE !
  2085                        ;   0 (SOURCE-ID) !
  2086                        ;   BEGIN
  2087                        ;     REFILL
  2088                        ;     WHILE SOURCE EVALUATE
  2089                        ;     STATE @ 0= IF S" Ok" CR TYPE THEN
  2090                        ;   AGAIN ;
  2091                        
  2092 00:0EEA: DE 0E 00 04                  HEADER  4,"QUIT",NORMAL
       00:0EEE: 51 55 49 54 
  2093 00:0EF2: 20 BE 14     QUIT:           jsr     DO_COLON
  2094 00:0EF5: 22 0F                        dw      DO_QUIT
  2095 00:0EF7: CE 04                        dw      ZERO
  2096 00:0EF9: B8 04                        dw      STATE
  2097 00:0EFB: 4B 05                        dw      STORE
  2098 00:0EFD: CE 04                        dw      ZERO
  2099 00:0EFF: AA 04                        dw      SOURCEID
  2100 00:0F01: 4B 05                        dw      STORE
  2101 00:0F03: AC 11        QUIT_1:         dw      REFILL
  2102 00:0F05: 7D 16 0B 0F                  dw      QUERY_BRANCH,QUIT_2
  Tue Aug 22 2017 23:21                                                                                                    Page 43


  2103 00:0F09: E3 10                        dw      INTERPRET
  2104 00:0F0B: B8 04        QUIT_2:         dw      STATE
  2105 00:0F0D: B9 05                        dw      FETCH
  2106 00:0F0F: 03 0D                        dw      ZERO_EQUAL
  2107 00:0F11: 7D 16 1E 0F                  dw      QUERY_BRANCH,QUIT_3
  2108 00:0F15: 7F 17                        dw      DO_S_QUOTE
  2109 00:0F17: 02 4F 6B                     db      2,"Ok"
  2110 00:0F1A: FC 18                        dw      TYPE
  2111 00:0F1C: 7F 18                        dw      CR
  2112 00:0F1E: 5C 16 03 0F  QUIT_3:         dw      BRANCH,QUIT_1
  2113                        
  2114                        DO_QUIT:
  2115 00:0F22: A9 FF 01                     lda     #RSTACK_END-1           ; Reset the return stack
  2116 00:0F25: 1B                           tcs
  2117 00:0F26: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0F2A: 00 00 
  2118                        
  2119                        ;===============================================================================
  2120                        ; Parser & Interpreter
  2121                        ;-------------------------------------------------------------------------------
  2122                        
  2123                        ; ?NUMBER
  2124                        ;
  2125                        ;   DUP  0 0 ROT COUNT      -- ca ud adr n
  2126                        ;   ?SIGN >R  >NUMBER       -- ca ud adr' n'
  2127                        ;   IF   R> 2DROP 2DROP 0   -- ca 0   (error)
  2128                        ;   ELSE 2DROP NIP R>
  2129                        ;       IF NEGATE THEN  -1  -- n -1   (ok)
  2130                        ;   THEN ;
  2131                        
  2132 00:0F2C: ED 0E 00 07                  HEADER  7,"?NUMBER",NORMAL
       00:0F30: 3F 4E 55 4D 
       00:0F34: 42 45 52 
  2133 00:0F37: 20 BE 14     QUERY_NUMBER:   jsr     DO_COLON
  2134 00:0F3A: 82 07                        dw      DUP
  2135 00:0F3C: CE 04                        dw      ZERO
  2136 00:0F3E: CE 04                        dw      ZERO
  2137 00:0F40: EF 07                        dw      ROT
  2138 00:0F42: 0A 14                        dw      COUNT
  2139 00:0F44: 75 0F                        dw      QUERY_SIGN
  2140 00:0F46: 7B 08                        dw      TO_R
  2141 00:0F48: BC 0F                        dw      TO_NUMBER
  2142 00:0F4A: 7D 16 5A 0F                  dw      QUERY_BRANCH,QNUM_1
  2143 00:0F4E: B4 08                        dw      R_FROM
  2144 00:0F50: AB 06                        dw      TWO_DROP
  2145 00:0F52: AB 06                        dw      TWO_DROP
  2146 00:0F54: CE 04                        dw      ZERO
  2147 00:0F56: 5C 16 6A 0F                  dw      BRANCH,QNUM_3
  2148 00:0F5A: AB 06        QNUM_1:         dw      TWO_DROP
  2149 00:0F5C: 97 07                        dw      NIP
  2150 00:0F5E: B4 08                        dw      R_FROM
  2151 00:0F60: 7D 16 66 0F                  dw      QUERY_BRANCH,QNUM_2
  2152 00:0F64: 5C 0A                        dw      NEGATE
  2153 00:0F66: C4 16 FF FF  QNUM_2:         dw      DO_LITERAL,-1
  2154 00:0F6A: E3 0E        QNUM_3:         dw      EXIT
  2155                        
  2156                        ; ?SIGN ( c-addr n -- adr' n' f )
  2157                        ;
  Tue Aug 22 2017 23:21                                                                                                    Page 44


  2158                        ;   OVER C@                 -- adr n c
  2159                        ;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else 0
  2160                        ;   DUP IF 1+               -- +=0, -=+2
  2161                        ;       >R 1 /STRING R>     -- adr' n' f
  2162                        ;   THEN ;
  2163                        
  2164 00:0F6C: 2F 0F 00 05                  HEADER  5,"?SIGN",NORMAL
       00:0F70: 3F 53 49 47 
       00:0F74: 4E 
  2165 00:0F75: 20 BE 14     QUERY_SIGN:     jsr     DO_COLON
  2166 00:0F78: A5 07                        dw      OVER
  2167 00:0F7A: 0C 06                        dw      C_FETCH
  2168 00:0F7C: C4 16 2C 00                  dw      DO_LITERAL,','
  2169 00:0F80: 2B 09                        dw      MINUS
  2170 00:0F82: 82 07                        dw      DUP
  2171 00:0F84: B6 09                        dw      ABS
  2172 00:0F86: C4 16 01 00                  dw      DO_LITERAL,1
  2173 00:0F8A: 54 0D                        dw      EQUAL
  2174 00:0F8C: BA 0D                        dw      AND
  2175 00:0F8E: 82 07                        dw      DUP
  2176 00:0F90: 7D 16 A0 0F                  dw      QUERY_BRANCH,QSIGN_1
  2177 00:0F94: 6D 09                        dw      ONE_PLUS
  2178 00:0F96: 7B 08                        dw      TO_R
  2179 00:0F98: C4 16 01 00                  dw      DO_LITERAL,1
  2180 00:0F9C: 2D 13                        dw      SLASH_STRING
  2181 00:0F9E: B4 08                        dw      R_FROM
  2182 00:0FA0: E3 0E        QSIGN_1:        dw      EXIT
  2183                        
  2184                        ; >COUNTED ( c-addr n -- )
  2185                        ;
  2186                        ;   2DUP C! CHAR+ SWAP CMOVE
  2187                        
  2188 00:0FA2: 20 BE 14     TO_COUNTED:     jsr     DO_COLON
  2189 00:0FA5: BF 06                        dw      TWO_DUP
  2190 00:0FA7: DB 05                        dw      C_STORE
  2191 00:0FA9: 7A 06                        dw      CHAR_PLUS
  2192 00:0FAB: 09 08                        dw      SWAP
  2193 00:0FAD: 71 13                        dw      CMOVE
  2194 00:0FAF: E3 0E                        dw      EXIT
  2195                        
  2196                        ; >NUMBER ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
  2197                        ;
  2198                        ; ud2 is the unsigned result of converting the characters within the string
  2199                        ; specified by c-addr1 u1 into digits, using the number in BASE, and adding
  2200                        ; each into ud1 after multiplying ud1 by the number in BASE. Conversion
  2201                        ; continues left-to-right until a character that is not convertible, including
  2202                        ; any + or -, is encountered or the string is entirely converted. c-addr2
  2203                        ; is the location of the first unconverted character or the first character
  2204                        ; past the end of the string if the string was entirely converted. u2 is the
  2205                        ; number of unconverted characters in the string. An ambiguous condition exists
  2206                        ; if ud2 overflows during the conversion.
  2207                        ;
  2208                        ; In this implementation its is defined as:
  2209                        ;
  2210                        ;   BEGIN
  2211                        ;   DUP WHILE
  2212                        ;       OVER C@ DIGIT?
  2213                        ;       0= IF DROP EXIT THEN
  Tue Aug 22 2017 23:21                                                                                                    Page 45


  2214                        ;       >R 2SWAP BASE @ UD*
  2215                        ;       R> M+ 2SWAP
  2216                        ;       1 /STRING
  2217                        ;   REPEAT ;
  2218                        
  2219 00:0FB1: 6F 0F 00 07                  HEADER  7,">NUMBER",NORMAL
       00:0FB5: 3E 4E 55 4D 
       00:0FB9: 42 45 52 
  2220 00:0FBC: 20 BE 14     TO_NUMBER:      jsr     DO_COLON
  2221 00:0FBF: 82 07        TO_NUM_1:       dw      DUP
  2222 00:0FC1: 7D 16 EF 0F                  dw      QUERY_BRANCH,TO_NUM_3
  2223 00:0FC5: A5 07                        dw      OVER
  2224 00:0FC7: 0C 06                        dw      C_FETCH
  2225 00:0FC9: 6E 10                        dw      DIGIT_QUERY
  2226 00:0FCB: 03 0D                        dw      ZERO_EQUAL
  2227 00:0FCD: 7D 16 D5 0F                  dw      QUERY_BRANCH,TO_NUM_2
  2228 00:0FD1: 71 07                        dw      DROP
  2229 00:0FD3: E3 0E                        dw      EXIT
  2230 00:0FD5: 7B 08        TO_NUM_2:       dw      TO_R
  2231 00:0FD7: 23 07                        dw      TWO_SWAP
  2232 00:0FD9: 64 04                        dw      BASE
  2233 00:0FDB: B9 05                        dw      FETCH
  2234 00:0FDD: 5B 0C                        dw      UD_STAR
  2235 00:0FDF: B4 08                        dw      R_FROM
  2236 00:0FE1: F7 0B                        dw      M_PLUS
  2237 00:0FE3: 23 07                        dw      TWO_SWAP
  2238 00:0FE5: C4 16 01 00                  dw      DO_LITERAL,1
  2239 00:0FE9: 2D 13                        dw      SLASH_STRING
  2240 00:0FEB: 5C 16 BF 0F                  dw      BRANCH,TO_NUM_1
  2241 00:0FEF: E3 0E        TO_NUM_3:       dw      EXIT
  2242                        
  2243                        ; ACCEPT ( c-addr +n1 -- +n2 )
  2244                        ;
  2245                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  2246                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  2247                        ; received. A program that depends on the presence or absence of non-graphic
  2248                        ; characters in the string has an environmental dependency. The editing
  2249                        ; functions, if any, that the system performs in order to construct the string
  2250                        ; are implementation-defined.
  2251                        ;
  2252                        ; Input terminates when an implementation-defined line terminator is received.
  2253                        ; When input terminates, nothing is appended to the string, and the display is
  2254                        ; maintained in an implementation-defined way.
  2255                        ;
  2256                        ; +n2 is the length of the string stored at c-addr.
  2257                        ;
  2258                        ; In this implementation it is defined as:
  2259                        ;
  2260                        ;   OVER + 1- OVER      -- sa ea a
  2261                        ;   BEGIN KEY           -- sa ea a c
  2262                        ;   DUP 0D <> WHILE
  2263                        ;     DUP 8 = OVER 127 = OR IF
  2264                        ;       DROP 1-
  2265                        ;       >R OVER R> UMAX
  2266                        ;       8 EMIT SPACE 8 EMIT
  2267                        ;     ELSE
  2268                        ;       DUP EMIT        -- sa ea a c
  2269                        ;       OVER C! 1+ OVER UMIN
  Tue Aug 22 2017 23:21                                                                                                    Page 46


  2270                        ;     THEN              -- sa ea a
  2271                        ;   REPEAT              -- sa ea a c
  2272                        ;   DROP NIP SWAP - ;
  2273                        
  2274 00:0FF1: B4 0F 00 06                  HEADER  6,"ACCEPT",NORMAL
       00:0FF5: 41 43 43 45 
       00:0FF9: 50 54 
  2275 00:0FFB: 20 BE 14     ACCEPT:         jsr     DO_COLON
  2276 00:0FFE: A5 07                        dw      OVER
  2277 00:1000: 15 09                        dw      PLUS
  2278 00:1002: 7B 09                        dw      ONE_MINUS
  2279 00:1004: A5 07                        dw      OVER
  2280 00:1006: AE 18        ACCEPT_1:       dw      KEY
  2281 00:1008: 82 07                        dw      DUP
  2282 00:100A: C4 16 0D 00                  dw      DO_LITERAL,$0D
  2283 00:100E: 3B 0D                        dw      NOT_EQUAL
  2284 00:1010: 7D 16 5A 10                  dw      QUERY_BRANCH,ACCEPT_4
  2285 00:1014: 82 07                        dw      DUP
  2286 00:1016: C4 16 08 00                  dw      DO_LITERAL,$08
  2287 00:101A: 54 0D                        dw      EQUAL
  2288 00:101C: A5 07                        dw      OVER
  2289 00:101E: C4 16 7F 00                  dw      DO_LITERAL,$7f
  2290 00:1022: 54 0D                        dw      EQUAL
  2291 00:1024: 13 0E                        dw      OR
  2292 00:1026: 7D 16 48 10                  dw      QUERY_BRANCH,ACCEPT_2
  2293 00:102A: 71 07                        dw      DROP
  2294 00:102C: 7B 09                        dw      ONE_MINUS
  2295 00:102E: 7B 08                        dw      TO_R
  2296 00:1030: A5 07                        dw      OVER
  2297 00:1032: B4 08                        dw      R_FROM
  2298 00:1034: 72 0A                        dw      UMAX
  2299 00:1036: C4 16 08 00                  dw      DO_LITERAL,8
  2300 00:103A: 98 18                        dw      EMIT
  2301 00:103C: CA 18                        dw      SPACE
  2302 00:103E: C4 16 08 00                  dw      DO_LITERAL,8
  2303 00:1042: 98 18                        dw      EMIT
  2304 00:1044: 5C 16 56 10                  dw      BRANCH,ACCEPT_3
  2305 00:1048: 82 07        ACCEPT_2:       dw      DUP
  2306 00:104A: 98 18                        dw      EMIT
  2307 00:104C: A5 07                        dw      OVER
  2308 00:104E: DB 05                        dw      C_STORE
  2309 00:1050: 6D 09                        dw      ONE_PLUS
  2310 00:1052: A5 07                        dw      OVER
  2311 00:1054: 86 0A                        dw      UMIN
  2312 00:1056: 5C 16 06 10  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  2313 00:105A: 71 07        ACCEPT_4:       dw      DROP
  2314 00:105C: 97 07                        dw      NIP
  2315 00:105E: 09 08                        dw      SWAP
  2316 00:1060: 2B 09                        dw      MINUS
  2317 00:1062: E3 0E                        dw      EXIT
  2318                        
  2319                        ; DIGIT?
  2320                        ;
  2321                        ;   [ HEX ] DUP 39 > 100 AND +     silly looking
  2322                        ;   DUP 140 > 107 AND -   30 -     but it works!
  2323                        ;   DUP BASE @ U< ;
  2324                        
  2325 00:1064: F4 0F 00 06                  HEADER  6,"DIGIT?",NORMAL
  Tue Aug 22 2017 23:21                                                                                                    Page 47


       00:1068: 44 49 47 49 
       00:106C: 54 3F 
  2326 00:106E: 20 BE 14     DIGIT_QUERY:    jsr     DO_COLON
  2327 00:1071: 82 07                        dw      DUP
  2328 00:1073: C4 16 39 00                  dw      DO_LITERAL,'9'
  2329 00:1077: 6D 0D                        dw      GREATER
  2330 00:1079: C4 16 00 01                  dw      DO_LITERAL,$100
  2331 00:107D: BA 0D                        dw      AND
  2332 00:107F: 15 09                        dw      PLUS
  2333 00:1081: 82 07                        dw      DUP
  2334 00:1083: C4 16 40 01                  dw      DO_LITERAL,$140
  2335 00:1087: 6D 0D                        dw      GREATER
  2336 00:1089: C4 16 07 01                  dw      DO_LITERAL,$107
  2337 00:108D: BA 0D                        dw      AND
  2338 00:108F: 2B 09                        dw      MINUS
  2339 00:1091: C4 16 30 00                  dw      DO_LITERAL,'0'
  2340 00:1095: 2B 09                        dw      MINUS
  2341 00:1097: 82 07                        dw      DUP
  2342 00:1099: 64 04                        dw      BASE
  2343 00:109B: B9 05                        dw      FETCH
  2344 00:109D: 8E 0D                        dw      U_LESS
  2345 00:109F: E3 0E                        dw      EXIT
  2346                        
  2347                        ; EVALUATE ( i*x c-addr u -- j*x )
  2348                        ;
  2349                        ; Save the current input source specification. Store minus-one (-1) in
  2350                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  2351                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  2352                        ; parse area is empty, restore the prior input source specification. Other
  2353                        ; stack effects are due to the words EVALUATEd.
  2354                        ;
  2355                        ;   >R >R SAVE-INPUT
  2356                        ;   -1 (SOURCE-ID) !
  2357                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  2358                        ;   INTERPRET
  2359                        ;   RESTORE-INPUT DROP
  2360                        
  2361 00:10A1: 67 10 00 08                  HEADER  8,"EVALUATE",NORMAL
       00:10A5: 45 56 41 4C 
       00:10A9: 55 41 54 45 
  2362 00:10AD: 20 BE 14     EVALUATE:       jsr     DO_COLON
  2363 00:10B0: 7B 08                        dw      TO_R
  2364 00:10B2: 7B 08                        dw      TO_R
  2365 00:10B4: 39 12                        dw      SAVE_INPUT
  2366 00:10B6: B4 08                        dw      R_FROM
  2367 00:10B8: B4 08                        dw      R_FROM
  2368 00:10BA: 0C 05                        dw      TRUE
  2369 00:10BC: AA 04                        dw      SOURCEID
  2370 00:10BE: 4B 05                        dw      STORE
  2371 00:10C0: CE 04                        dw      ZERO
  2372 00:10C2: 57 04                        dw      TO_IN
  2373 00:10C4: 4B 05                        dw      STORE
  2374 00:10C6: 99 04                        dw      LENGTH
  2375 00:10C8: 4B 05                        dw      STORE
  2376 00:10CA: 75 04                        dw      BUFFER
  2377 00:10CC: 4B 05                        dw      STORE
  2378 00:10CE: E3 10                        dw      INTERPRET
  2379 00:10D0: EA 11                        dw      RESTORE_INPUT
  Tue Aug 22 2017 23:21                                                                                                    Page 48


  2380 00:10D2: 71 07                        dw      DROP
  2381 00:10D4: E3 0E                        dw      EXIT
  2382                        
  2383                        ; INTERPRET ( -- )
  2384                        ;
  2385                        ;
  2386                        ;   BEGIN
  2387                        ;   BL WORD DUP C@ WHILE        -- textadr
  2388                        ;       FIND                    -- a 0/1/-1
  2389                        ;       ?DUP IF                 -- xt 1/-1
  2390                        ;           1+ STATE @ 0= OR    immed or interp?
  2391                        ;           IF EXECUTE ELSE , THEN
  2392                        ;       ELSE                    -- textadr
  2393                        ;           ?NUMBER
  2394                        ;           IF STATE @
  2395                        ;               IF POSTPONE LITERAL THEN     converted ok
  2396                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  2397                        ;           THEN
  2398                        ;       THEN
  2399                        ;   REPEAT DROP ;
  2400                        
  2401 00:10D6: A4 10 00 09                  HEADER  9,"INTERPRET",NORMAL
       00:10DA: 49 4E 54 45 
       00:10DE: 52 50 52 45 
       00:10E2: 54 
  2402 00:10E3: 20 BE 14     INTERPRET:      jsr     DO_COLON
  2403 00:10E6: E0 04        INTERPRET_1:    dw      BL
  2404 00:10E8: B1 12                        dw      WORD
  2405 00:10EA: 82 07                        dw      DUP
  2406 00:10EC: 0C 06                        dw      C_FETCH
  2407 00:10EE: 7D 16 3A 11                  dw      QUERY_BRANCH,INTERPRET_7
  2408 00:10F2: 46 11                        dw      FIND
  2409 00:10F4: 45 07                        dw      QUERY_DUP
  2410 00:10F6: 7D 16 14 11                  dw      QUERY_BRANCH,INTERPRET_4
  2411 00:10FA: 6D 09                        dw      ONE_PLUS
  2412 00:10FC: B8 04                        dw      STATE
  2413 00:10FE: B9 05                        dw      FETCH
  2414 00:1100: 03 0D                        dw      ZERO_EQUAL
  2415 00:1102: 13 0E                        dw      OR
  2416 00:1104: 7D 16 0E 11                  dw      QUERY_BRANCH,INTERPRET_2
  2417 00:1108: D2 0E                        dw      EXECUTE
  2418 00:110A: 5C 16 10 11                  dw      BRANCH,INTERPRET_3
  2419 00:110E: 79 05        INTERPRET_2:    dw      COMMA
  2420 00:1110: 5C 16 36 11  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  2421 00:1114: 37 0F        INTERPRET_4:    dw      QUERY_NUMBER
  2422 00:1116: 7D 16 28 11                  dw      QUERY_BRANCH,INTERPRET_5
  2423 00:111A: B8 04                        dw      STATE
  2424 00:111C: B9 05                        dw      FETCH
  2425 00:111E: 7D 16 36 11                  dw      QUERY_BRANCH,INTERPRET_6
  2426 00:1122: B7 16                        dw      LITERAL
  2427 00:1124: 5C 16 36 11                  dw      BRANCH,INTERPRET_6
  2428 00:1128: 0A 14        INTERPRET_5:    dw      COUNT
  2429 00:112A: FC 18                        dw      TYPE
  2430 00:112C: C4 16 3F 00                  dw      DO_LITERAL,$3f
  2431 00:1130: 98 18                        dw      EMIT
  2432 00:1132: 7F 18                        dw      CR
  2433 00:1134: 80 0E                        dw      ABORT
  2434 00:1136: 5C 16 E6 10  INTERPRET_6     dw      BRANCH,INTERPRET_1
  Tue Aug 22 2017 23:21                                                                                                    Page 49


  2435 00:113A: 71 07        INTERPRET_7:    dw      DROP
  2436 00:113C: E3 0E                        dw      EXIT
  2437                        
  2438                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  2439                        ;
  2440                        ; Find the definition named in the counted string at c-addr. If the definition
  2441                        ; is not found, return c-addr and zero. If the definition is found, return its
  2442                        ; execution token xt. If the definition is immediate, also return one (1),
  2443                        ; otherwise also return minus-one (-1). For a given string, the values returned
  2444                        ; by FIND while compiling may differ from those returned while not compiling.
  2445                        ;
  2446                        ; In this implementation it is defined as:
  2447                        ;
  2448                        ;   LATEST @ BEGIN             -- a nfa
  2449                        ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
  2450                        ;       S=                     -- a nfa f
  2451                        ;       DUP IF
  2452                        ;           DROP
  2453                        ;           NFA>LFA @ DUP      -- a link link
  2454                        ;       THEN
  2455                        ;   0= UNTIL                   -- a nfa  OR  a 0
  2456                        ;   DUP IF
  2457                        ;       NIP DUP NFA>CFA        -- nfa xt
  2458                        ;       SWAP IMMED?            -- xt iflag
  2459                        ;       0= 1 OR                -- xt 1/-1
  2460                        ;   THEN ;
  2461                        
  2462 00:113E: D9 10 00 04                  HEADER  4,"FIND",NORMAL
       00:1142: 46 49 4E 44 
  2463 00:1146: 20 BE 14     FIND:           jsr     DO_COLON
  2464 00:1149: 94 04                        dw      LATEST
  2465 00:114B: B9 05                        dw      FETCH
  2466 00:114D: BF 06        FIND1:          dw      TWO_DUP
  2467 00:114F: A5 07                        dw      OVER
  2468 00:1151: 0C 06                        dw      C_FETCH
  2469 00:1153: 7A 06                        dw      CHAR_PLUS
  2470 00:1155: 01 12                        dw      S_EQUAL
  2471 00:1157: 82 07                        dw      DUP
  2472 00:1159: 7D 16 65 11                  dw      QUERY_BRANCH,FIND2
  2473 00:115D: 71 07                        dw      DROP
  2474 00:115F: 97 11                        dw      NFA_TO_LFA
  2475 00:1161: B9 05                        dw      FETCH
  2476 00:1163: 82 07                        dw      DUP
  2477 00:1165: 03 0D        FIND2:          dw      ZERO_EQUAL
  2478 00:1167: 7D 16 4D 11                  dw      QUERY_BRANCH,FIND1
  2479 00:116B: 82 07                        dw      DUP
  2480 00:116D: 7D 16 83 11                  dw      QUERY_BRANCH,FIND3
  2481 00:1171: 97 07                        dw      NIP
  2482 00:1173: 82 07                        dw      DUP
  2483 00:1175: 8E 11                        dw      NFA_TO_CFA
  2484 00:1177: 09 08                        dw      SWAP
  2485 00:1179: 85 11                        dw      IMMED_QUERY
  2486 00:117B: 03 0D                        dw      ZERO_EQUAL
  2487 00:117D: C4 16 01 00                  dw      DO_LITERAL,1
  2488 00:1181: 13 0E                        dw      OR
  2489 00:1183: E3 0E        FIND3:          dw      EXIT
  2490                        
  2491                        ; IMMED? ( nfa -- f )
  Tue Aug 22 2017 23:21                                                                                                    Page 50


  2492                        
  2493 00:1185: 20 BE 14     IMMED_QUERY:    jsr     DO_COLON
  2494 00:1188: 7B 09                        dw      ONE_MINUS
  2495 00:118A: 0C 06                        dw      C_FETCH
  2496 00:118C: E3 0E                        dw      EXIT
  2497                        
  2498                        ; NFA>CFA ( nfa -- cfa )
  2499                        
  2500 00:118E: 20 BE 14     NFA_TO_CFA:     jsr     DO_COLON
  2501 00:1191: 0A 14                        dw      COUNT
  2502 00:1193: 15 09                        dw      PLUS
  2503 00:1195: E3 0E                        dw      EXIT
  2504                        
  2505                        ; NFA>LFA ( nfa -- lfa )
  2506                        
  2507 00:1197: 20 BE 14     NFA_TO_LFA:     jsr     DO_COLON
  2508 00:119A: C4 16 03 00                  dw      DO_LITERAL,3
  2509 00:119E: 2B 09                        dw      MINUS
  2510 00:11A0: E3 0E                        dw      EXIT
  2511                        
  2512                        ; REFILL ( -- flag )
  2513                        ;
  2514                        ; Attempt to fill the input buffer from the input source, returning a true flag
  2515                        ; if successful.
  2516                        ;
  2517                        ; When the input source is the user input device, attempt to receive input into
  2518                        ; the terminal input buffer. If successful, make the result the input buffer,
  2519                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  2520                        ; is considered successful. If there is no input available from the current
  2521                        ; input source, return false.
  2522                        ;
  2523                        ; When the input source is a string from EVALUATE, return false and perform no
  2524                        ; other action.
  2525                        ;
  2526                        ; In this implementation it is defined as:
  2527                        ;
  2528                        ;   SOURCE-ID 0= IF
  2529                        ;     TIB DUP #TIB @ ACCEPT SPACE
  2530                        ;     LENGTH ! BUFFER !
  2531                        ;     0 >IN ! TRUE EXIT
  2532                        ;   THEN
  2533                        ;   FALSE
  2534                        
  2535 00:11A2: 41 11 00 06                  HEADER  6,"REFILL",NORMAL
       00:11A6: 52 45 46 49 
       00:11AA: 4C 4C 
  2536 00:11AC: 20 BE 14     REFILL:         jsr     DO_COLON
  2537 00:11AF: A0 12                        dw      SOURCE_ID
  2538 00:11B1: 03 0D                        dw      ZERO_EQUAL
  2539 00:11B3: 7D 16 D5 11                  dw      QUERY_BRANCH,REFILL_1
  2540 00:11B7: C4 04                        dw      TIB
  2541 00:11B9: 82 07                        dw      DUP
  2542 00:11BB: 49 04                        dw      HASH_TIB
  2543 00:11BD: B9 05                        dw      FETCH
  2544 00:11BF: FB 0F                        dw      ACCEPT
  2545 00:11C1: CA 18                        dw      SPACE
  2546 00:11C3: 99 04                        dw      LENGTH
  2547 00:11C5: 4B 05                        dw      STORE
  Tue Aug 22 2017 23:21                                                                                                    Page 51


  2548 00:11C7: 75 04                        dw      BUFFER
  2549 00:11C9: 4B 05                        dw      STORE
  2550 00:11CB: CE 04                        dw      ZERO
  2551 00:11CD: 57 04                        dw      TO_IN
  2552 00:11CF: 4B 05                        dw      STORE
  2553 00:11D1: 0C 05                        dw      TRUE
  2554 00:11D3: E3 0E                        dw      EXIT
  2555 00:11D5: F8 04        REFILL_1:       dw      FALSE
  2556 00:11D7: E3 0E                        dw      EXIT
  2557                        
  2558                        ; RESTORE-INPUT ( xn ... x1 n -- flag )
  2559                        ;
  2560                        ; Attempt to restore the input source specification to the state described by
  2561                        ; x1 through xn. flag is true if the input source specification cannot be so
  2562                        ; restored.
  2563                        ;
  2564                        ; An ambiguous condition exists if the input source represented by the
  2565                        ; arguments is not the same as the current input source.
  2566                        ;
  2567                        ; In this implementation it is defined as:
  2568                        ;
  2569                        ;   >IN ! (LENGTH) ! BUFFER !
  2570                        ;   SOURCEID !
  2571                        ;   TRUE
  2572                        
  2573 00:11D9: A5 11 00 0D                  HEADER  13,"RESTORE-INPUT",NORMAL
       00:11DD: 52 45 53 54 
       00:11E1: 4F 52 45 2D 
       00:11E5: 49 4E 50 55 
       00:11E9: 54 
  2574 00:11EA: 20 BE 14     RESTORE_INPUT   jsr     DO_COLON
  2575 00:11ED: 57 04                        dw      TO_IN
  2576 00:11EF: 4B 05                        dw      STORE
  2577 00:11F1: 99 04                        dw      LENGTH
  2578 00:11F3: 4B 05                        dw      STORE
  2579 00:11F5: 75 04                        dw      BUFFER
  2580 00:11F7: 4B 05                        dw      STORE
  2581 00:11F9: AA 04                        dw      SOURCEID
  2582 00:11FB: 4B 05                        dw      STORE
  2583 00:11FD: 0C 05                        dw      TRUE
  2584 00:11FF: E3 0E                        dw      EXIT
  2585                        
  2586                        ; S= ( c-addr1 caddr2 u -- n)
  2587                        ;
  2588                        ; Misnamed, more like C's strncmp. Note that counted length bytes are compared!
  2589                        
  2590                        S_EQUAL:
  2591 00:1201: 5A                           phy
  2592 00:1202: A6 01                        ldx     <1                      ; Fetch maximum length
  2593 00:1204: F0 14                        beq     S_EQUAL_3
  2594 00:1206: A0 00 00                     ldy     #0
  2595 00:1209: E2 20                        short_a
  2596                        S_EQUAL_1:
  2597 00:120B: B1 05                        lda     (5),y                   ; Compare bytes
  2598 00:120D: D1 03                        cmp     (3),y
  2599 00:120F: D0 06                        bne     S_EQUAL_2
  2600 00:1211: C8                           iny
  2601 00:1212: CA                           dex                             ; End of strings?
  Tue Aug 22 2017 23:21                                                                                                    Page 52


  2602 00:1213: D0 F6                        bne     S_EQUAL_1               ; No
  2603 00:1215: 80 03                        bra     S_EQUAL_3               ; Yes. must be the same
  2604                        S_EQUAL_2:
  2605 00:1217: A2 FF FF                     ldx     #$ffff                  ; Difference found
  2606                        S_EQUAL_3:
  2607 00:121A: C2 20                        long_a
  2608 00:121C: 7B                           tdc                             ; Clean up the stack
  2609 00:121D: 1A                           inc     a
  2610 00:121E: 1A                           inc     a
  2611 00:121F: 1A                           inc     a
  2612 00:1220: 1A                           inc     a
  2613 00:1221: 5B                           tcd
  2614 00:1222: 86 01                        stx     <1                      ; Save the flag
  2615 00:1224: 7A                           ply
  2616 00:1225: BB C8 C8 7C                  CONTINUE
       00:1229: 00 00 
  2617                        
  2618                        ; SAVE-INPUT ( -- xn ... x1 n )
  2619                        ;
  2620                        ; x1 through xn describe the current state of the input source specification
  2621                        ; for later use by RESTORE-INPUT.
  2622                        
  2623 00:122B: DC 11 00 0A                  HEADER  10,"SAVE-INPUT",NORMAL
       00:122F: 53 41 56 45 
       00:1233: 2D 49 4E 50 
       00:1237: 55 54 
  2624 00:1239: 20 BE 14     SAVE_INPUT:     jsr     DO_COLON
  2625 00:123C: AA 04                        dw      SOURCEID
  2626 00:123E: B9 05                        dw      FETCH
  2627 00:1240: 75 04                        dw      BUFFER
  2628 00:1242: B9 05                        dw      FETCH
  2629 00:1244: 99 04                        dw      LENGTH
  2630 00:1246: B9 05                        dw      FETCH
  2631 00:1248: 57 04                        dw      TO_IN
  2632 00:124A: B9 05                        dw      FETCH
  2633 00:124C: E3 0E                        dw      EXIT
  2634                        
  2635                        ; SCAN ( c-addr n c == c-addr' n' )
  2636                        
  2637                        SCAN:
  2638                        SCAN_1:
  2639 00:124E: A5 03                        lda     <3                      ; Any data left to scan?
  2640 00:1250: F0 10                        beq     SCAN_2                  ; No.
  2641 00:1252: A5 01                        lda     <1                      ; Fetch and compare with scan
  2642 00:1254: E2 20                        short_a
  2643 00:1256: D2 05                        cmp     (5)
  2644 00:1258: C2 20                        long_a
  2645 00:125A: F0 06                        beq     SCAN_2
  2646 00:125C: E6 05                        inc     <5
  2647 00:125E: C6 03                        dec     <3
  2648 00:1260: 80 EC                        bra     SCAN_1
  2649                        SCAN_2:
  2650 00:1262: 4C 71 07                     jmp     DROP                    ; Drop the character
  2651                        
  2652                        ; SKIP ( c-addr n c == c-addr' n' )
  2653                        
  2654                        SKIP:
  2655 00:1265: A5 03        SKIP_1:         lda     <3                      ; Any data left to skip over?
  Tue Aug 22 2017 23:21                                                                                                    Page 53


  2656 00:1267: F0 10                        beq     SKIP_2                  ; No.
  2657 00:1269: A5 01                        lda     <1                      ; Fetch and compare with skip
  2658 00:126B: E2 20                        short_a
  2659 00:126D: D2 05                        cmp     (5)
  2660 00:126F: C2 20                        long_a
  2661 00:1271: D0 06                        bne     SKIP_2                  ; Cannot be skipped
  2662 00:1273: E6 05                        inc     <5                      ; Bump data address
  2663 00:1275: C6 03                        dec     <3                      ; and update length
  2664 00:1277: 80 EC                        bra     SKIP_1                  ; And repeat
  2665                        SKIP_2:
  2666 00:1279: 4C 71 07                     jmp     DROP                    ; Drop the character
  2667                        
  2668                        ; SOURCE ( -- c-addr u )
  2669                        ;
  2670                        ; c-addr is the address of, and u is the number of characters in, the input
  2671                        ; buffer.
  2672                        ;
  2673                        ; In this implementation it is defined as
  2674                        ;
  2675                        ;   BUFFER @ LENGTH @
  2676                        
  2677 00:127C: 2E 12 00 06                  HEADER  6,"SOURCE",NORMAL
       00:1280: 53 4F 55 52 
       00:1284: 43 45 
  2678 00:1286: 20 BE 14     SOURCE:         jsr     DO_COLON
  2679 00:1289: 75 04                        dw      BUFFER
  2680 00:128B: B9 05                        dw      FETCH
  2681 00:128D: 99 04                        dw      LENGTH
  2682 00:128F: B9 05                        dw      FETCH
  2683 00:1291: E3 0E                        dw      EXIT
  2684                        
  2685                        ; SOURCE-ID ( -- 0 | -1 )
  2686                        ;
  2687                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  2688                        ; device.
  2689                        
  2690 00:1293: 7F 12 00 09                  HEADER  9,"SOURCE-ID",NORMAL
       00:1297: 53 4F 55 52 
       00:129B: 43 45 2D 49 
       00:129F: 44 
  2691 00:12A0: 20 BE 14     SOURCE_ID:      jsr     DO_COLON
  2692 00:12A3: AA 04                        dw      SOURCEID
  2693 00:12A5: B9 05                        dw      FETCH
  2694 00:12A7: E3 0E                        dw      EXIT
  2695                        
  2696                        ; WORD ( char <chars>ccc<char> -- c-addr )
  2697                        ;
  2698                        ; Skip leading delimiters. Parse characters ccc delimited by char. An
  2699                        ; ambiguous condition exists if the length of the parsed string is greater
  2700                        ; than the implementation-defined length of a counted string.
  2701                        ;
  2702                        ; c-addr is the address of a transient region containing the parsed word as
  2703                        ; a counted string. If the parse area was empty or contained no characters
  2704                        ; other than the delimiter, the resulting string has a zero length. A space,
  2705                        ; not included in the length, follows the string. A program may replace
  2706                        ; characters within the string.
  2707                        ;
  2708                        ; In this implementation it is defined as:
  Tue Aug 22 2017 23:21                                                                                                    Page 54


  2709                        ;
  2710                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  2711                        ;   DUP >R   ROT SKIP           -- c adr' n'
  2712                        ;   OVER >R  ROT SCAN           -- adr" n"
  2713                        ;   DUP IF CHAR- THEN        skip trailing delim.
  2714                        ;   R> R> ROT -   >IN +!        update >IN offset
  2715                        ;   TUCK -                      -- adr' N
  2716                        ;   HERE >counted               --
  2717                        ;   HERE                        -- a
  2718                        ;   BL OVER COUNT + C! ;    append trailing blank
  2719                        
  2720 00:12A9: 96 12 00 04                  HEADER  4,"WORD",NORMAL
       00:12AD: 57 4F 52 44 
  2721 00:12B1: 20 BE 14     WORD:           jsr     DO_COLON
  2722 00:12B4: 82 07                        dw      DUP
  2723 00:12B6: 86 12                        dw      SOURCE
  2724 00:12B8: 57 04                        dw      TO_IN
  2725 00:12BA: B9 05                        dw      FETCH
  2726 00:12BC: 2D 13                        dw      SLASH_STRING
  2727 00:12BE: 82 07                        dw      DUP
  2728 00:12C0: 7B 08                        dw      TO_R
  2729 00:12C2: EF 07                        dw      ROT
  2730 00:12C4: 65 12                        dw      SKIP
  2731 00:12C6: A5 07                        dw      OVER
  2732 00:12C8: 7B 08                        dw      TO_R
  2733 00:12CA: EF 07                        dw      ROT
  2734 00:12CC: 4E 12                        dw      SCAN
  2735 00:12CE: 82 07                        dw      DUP
  2736 00:12D0: 7D 16 D6 12                  dw      QUERY_BRANCH,WORD_1
  2737 00:12D4: 8B 06                        dw      CHAR_MINUS
  2738 00:12D6: B4 08        WORD_1:         dw      R_FROM
  2739 00:12D8: B4 08                        dw      R_FROM
  2740 00:12DA: EF 07                        dw      ROT
  2741 00:12DC: 2B 09                        dw      MINUS
  2742 00:12DE: 57 04                        dw      TO_IN
  2743 00:12E0: 61 05                        dw      PLUS_STORE
  2744 00:12E2: 1F 08                        dw      TUCK
  2745 00:12E4: 2B 09                        dw      MINUS
  2746 00:12E6: 24 06                        dw      HERE
  2747 00:12E8: A2 0F                        dw      TO_COUNTED
  2748 00:12EA: 24 06                        dw      HERE
  2749 00:12EC: E0 04                        dw      BL
  2750 00:12EE: A5 07                        dw      OVER
  2751 00:12F0: 0A 14                        dw      COUNT
  2752 00:12F2: 15 09                        dw      PLUS
  2753 00:12F4: DB 05                        dw      C_STORE
  2754 00:12F6: E3 0E                        dw      EXIT
  2755                        
  2756                        ;===============================================================================
  2757                        ; String Words
  2758                        ;-------------------------------------------------------------------------------
  2759                        
  2760                        ; -TRAILING ( c-addr u1 -- c-addr u2 )
  2761                        ;
  2762                        ; If u1 is greater than zero, u2 is equal to u1 less the number of spaces at
  2763                        ; the end of the character string specified by c-addr u1. If u1 is zero or the
  2764                        ; entire string consists of spaces, u2 is zero.
  2765                        
  Tue Aug 22 2017 23:21                                                                                                    Page 55


  2766 00:12F8: AC 12 00 09                  HEADER  9,"-TRAILING",NORMAL
       00:12FC: 2D 54 52 41 
       00:1300: 49 4C 49 4E 
       00:1304: 47 
  2767                        DASH_TRAILING:
  2768 00:1305: 5A                           phy                             ; Save IP
  2769 00:1306: A4 01                        ldy     <1                      ; Is u1 > 0?
  2770 00:1308: F0 0F                        beq     DASH_TRAIL_3            ; No
  2771 00:130A: E2 20                        short_a
  2772 00:130C: 88                           dey                             ; Convert to offset
  2773 00:130D: B1 03        DASH_TRAIL_1:   lda     (3),y                   ; Space character at end?
  2774 00:130F: C9 20                        cmp     #' '
  2775 00:1311: D0 03                        bne     DASH_TRAIL_2            ; No
  2776 00:1313: 88                           dey                             ; More characters to check?
  2777 00:1314: 10 F7                        bpl     DASH_TRAIL_1            ; Yes
  2778 00:1316: C2 20        DASH_TRAIL_2:   long_a
  2779 00:1318: C8                           iny                             ; Convert to length
  2780 00:1319: 84 01        DASH_TRAIL_3:   sty     <1                      ; Update
  2781 00:131B: 7A                           ply                             ; Restore IP
  2782 00:131C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1320: 00 00 
  2783                        
  2784                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  2785                        ;
  2786                        ; Adjust the character string at c-addr1 by n characters. The resulting
  2787                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  2788                        ; characters and is u1 minus n characters long.
  2789                        ;
  2790                        ; In this implementation it is defined as:
  2791                        ;
  2792                        ;   ROT OVER + ROT ROT -
  2793                        
  2794 00:1322: FB 12 00 07                  HEADER  7,"/STRING",NORMAL
       00:1326: 2F 53 54 52 
       00:132A: 49 4E 47 
  2795 00:132D: 20 BE 14     SLASH_STRING:   jsr     DO_COLON
  2796 00:1330: EF 07                        dw      ROT
  2797 00:1332: A5 07                        dw      OVER
  2798 00:1334: 15 09                        dw      PLUS
  2799 00:1336: EF 07                        dw      ROT
  2800 00:1338: EF 07                        dw      ROT
  2801 00:133A: 2B 09                        dw      MINUS
  2802 00:133C: E3 0E                        dw      EXIT
  2803                        
  2804                        ; BLANK ( c-addr u -- )
  2805                        ;
  2806                        ; If u is greater than zero, store the character value for space in u
  2807                        ; consecutive character positions beginning at c-addr.
  2808                        ;
  2809                        ; In this implementation it is defined as
  2810                        ;
  2811                        ;   ?DUP IF OVER + SWAP DO BL I C! LOOP ELSE DROP THEN
  2812                        
  2813 00:133E: 25 13 00 05                  HEADER  5,"BLANK",NORMAL
       00:1342: 42 4C 41 4E 
       00:1346: 4B 
  2814 00:1347: 20 BE 14     BLANK:          jsr     DO_COLON
  2815 00:134A: 45 07                        dw      QUERY_DUP
  Tue Aug 22 2017 23:21                                                                                                    Page 56


  2816 00:134C: 7D 16 64 13                  dw      QUERY_BRANCH,BLANK_2
  2817 00:1350: A5 07                        dw      OVER
  2818 00:1352: 15 09                        dw      PLUS
  2819 00:1354: 09 08                        dw      SWAP
  2820 00:1356: 2B 16                        dw      DO_DO
  2821 00:1358: E0 04        BLANK_1:        dw      BL
  2822 00:135A: 8D 08                        dw      I
  2823 00:135C: DB 05                        dw      C_STORE
  2824 00:135E: F6 16 58 13                  dw      DO_LOOP,BLANK_1
  2825 00:1362: E3 0E                        dw      EXIT
  2826 00:1364: 71 07        BLANK_2:        dw      DROP
  2827 00:1366: E3 0E                        dw      EXIT
  2828                        
  2829                        ; CMOVE ( c-addr1 c-addr2 u -- )
  2830                        ;
  2831                        ; If u is greater than zero, copy u consecutive characters from the data space
  2832                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2833                        ; character from lower addresses to higher addresses.
  2834                        
  2835 00:1368: 41 13 00 05                  HEADER  5,"CMOVE",NORMAL
       00:136C: 43 4D 4F 56 
       00:1370: 45 
  2836                        CMOVE:
  2837 00:1371: 5A                           phy
  2838 00:1372: A6 01                        ldx     <1                      ; Any characters to move?
  2839 00:1374: F0 0F                        beq     CMOVE_2                 ; No
  2840 00:1376: A0 00 00                     ldy     #0
  2841 00:1379: E2 20                        short_a
  2842                        CMOVE_1:                                        ; Transfer a byte
  2843 00:137B: B1 05                        lda     (5),y
  2844 00:137D: 91 03                        sta     (3),y
  2845 00:137F: C8                           iny
  2846 00:1380: CA                           dex                             ; Decrement count
  2847 00:1381: D0 F8                        bne     CMOVE_1                 ; .. and repeat until done
  2848 00:1383: C2 20                        long_a
  2849                        CMOVE_2:
  2850 00:1385: 7B                           tdc                             ; Clean up the stack
  2851 00:1386: 18                           clc
  2852 00:1387: 69 06 00                     adc     #6
  2853 00:138A: 5B                           tcd
  2854 00:138B: 7A                           ply
  2855 00:138C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1390: 00 00 
  2856                        
  2857                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  2858                        ;
  2859                        ; If u is greater than zero, copy u consecutive characters from the data space
  2860                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2861                        ; character from higher addresses to lower addresses.
  2862                        
  2863 00:1392: 6B 13 00 06                  HEADER  6,"CMOVE>",NORMAL
       00:1396: 43 4D 4F 56 
       00:139A: 45 3E 
  2864                        CMOVE_GREATER:
  2865 00:139C: 5A                           phy
  2866 00:139D: A6 01                        ldx     <1                      ; Any characters to move?
  2867 00:139F: F0 0E                        beq     CMOVE_GT_2              ; No.
  2868 00:13A1: A4 01                        ldy     <1
  Tue Aug 22 2017 23:21                                                                                                    Page 57


  2869 00:13A3: E2 20                        short_a
  2870                        CMOVE_GT_1:
  2871 00:13A5: 88                           dey                             ; Transfer a byte
  2872 00:13A6: B1 05                        lda     (5),y
  2873 00:13A8: 91 03                        sta     (3),y
  2874 00:13AA: CA                           dex                             ; Decrement length
  2875 00:13AB: D0 F8                        bne     CMOVE_GT_1              ; .. and repeat until done
  2876 00:13AD: C2 20                        long_a
  2877                        CMOVE_GT_2:
  2878 00:13AF: 7B                           tdc                             ; Clean up the stack
  2879 00:13B0: 18                           clc
  2880 00:13B1: 69 06 00                     adc     #6
  2881 00:13B4: 5B                           tcd
  2882 00:13B5: 7A                           ply
  2883 00:13B6: BB C8 C8 7C                  CONTINUE                        ; Done
       00:13BA: 00 00 
  2884                        
  2885                        ; COMPARE ( c-addr1 u1 c-addr2 u2 -- n )
  2886                        ;
  2887                        ; Compare the string specified by c-addr1 u1 to the string specified by c-addr2
  2888                        ; u2. The strings are compared, beginning at the given addresses, character by
  2889                        ; character, up to the length of the shorter string or until a difference is
  2890                        ; found. If the two strings are identical, n is zero. If the two strings are
  2891                        ; identical up to the length of the shorter string, n is minus-one (-1) if u1
  2892                        ; is less than u2 and one (1) otherwise. If the two strings are not identical
  2893                        ; up to the length of the shorter string, n is minus-one (-1) if the first
  2894                        ; non-matching character in the string specified by c-addr1 u1 has a lesser
  2895                        ; numeric value than the corresponding character in the string specified by
  2896                        ; c-addr2 u2 and one (1) otherwise.
  2897                        
  2898 00:13BC: 95 13 00 07                  HEADER  7,"COMPARE",NORMAL
       00:13C0: 43 4F 4D 50 
       00:13C4: 41 52 45 
  2899                        COMPARE:
  2900 00:13C7: A5 01                        lda     <1                      ; Both string lengths zero?
  2901 00:13C9: 05 05                        ora     <5
  2902 00:13CB: F0 26                        beq     COMPARE_X               ; Yes, must be equal
  2903                        
  2904 00:13CD: A5 01                        lda     <1                      ; Second string length zero?
  2905 00:13CF: F0 1A                        beq     COMPARE_P               ; Yes, must be shorter
  2906 00:13D1: A5 05                        lda     <5                      ; First string length zero?
  2907 00:13D3: F0 1B                        beq     COMPARE_N               ; Yes, must be shorter
  2908 00:13D5: E2 20                        short_a
  2909 00:13D7: B2 07                        lda     (7)                     ; Compare next characters
  2910 00:13D9: D2 03                        cmp     (3)
  2911 00:13DB: C2 20                        long_a
  2912 00:13DD: 90 11                        bcc     COMPARE_N
  2913 00:13DF: D0 0A                        bne     COMPARE_P
  2914                        
  2915 00:13E1: E6 03                        inc     <3                      ; Bump string pointers
  2916 00:13E3: E6 07                        inc     <7
  2917 00:13E5: C6 01                        dec     <1                      ; And reduce lengths
  2918 00:13E7: C6 05                        dec     <5
  2919 00:13E9: 80 DC                        bra     COMPARE
  2920                        
  2921 00:13EB: A9 01 00     COMPARE_P:      lda     #1
  2922 00:13EE: 80 03                        bra     COMPARE_X
  2923 00:13F0: A9 FF FF     COMPARE_N:      lda     #-1
  Tue Aug 22 2017 23:21                                                                                                    Page 58


  2924                        
  2925 00:13F3: 85 07        COMPARE_X:      sta     <7                      ; Save the result
  2926 00:13F5: 7B                           tdc
  2927 00:13F6: 18                           clc
  2928 00:13F7: 69 06 00                     adc     #6
  2929 00:13FA: 5B                           tcd
  2930 00:13FB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:13FF: 00 00 
  2931                        
  2932                        ; COUNT ( c-addr1 -- c-addr2 u )
  2933                        ;
  2934                        ; Return the character string specification for the counted string stored at
  2935                        ; c-addr1. c-addr2 is the address of the first character after c-addr1. u is
  2936                        ; the contents of the character at c-addr1, which is the length in characters
  2937                        ; of the string at c-addr2.
  2938                        ;
  2939                        ; In this implementation it is defined as
  2940                        ;
  2941                        ;   DUP CHAR+ SWAP C@
  2942                        
  2943 00:1401: BF 13 00 05                  HEADER  5,"COUNT",NORMAL
       00:1405: 43 4F 55 4E 
       00:1409: 54 
  2944 00:140A: 20 BE 14     COUNT:          jsr     DO_COLON
  2945 00:140D: 82 07                        dw      DUP
  2946 00:140F: 7A 06                        dw      CHAR_PLUS
  2947 00:1411: 09 08                        dw      SWAP
  2948 00:1413: 0C 06                        dw      C_FETCH
  2949 00:1415: E3 0E                        dw      EXIT
  2950                        
  2951                        ; SEARCH ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
  2952                        ;
  2953                        ; Search the string specified by c-addr1 u1 for the string specified by c-addr2
  2954                        ; u2. If flag is true, a match was found at c-addr3 with u3 characters
  2955                        ; remaining. If flag is false there was no match and c-addr3 is c-addr1 and u3
  2956                        ; is u1.
  2957                        
  2958 00:1417: 04 14 00 06                  HEADER  6,"SEARCH",NORMAL
       00:141B: 53 45 41 52 
       00:141F: 43 48 
  2959 00:1421: 20 BE 14     SEARCH:         jsr     DO_COLON
  2960                        ; TODO
  2961 00:1424: BB C8 C8 7C                  CONTINUE
       00:1428: 00 00 
  2962                        
  2963                        ;===============================================================================
  2964                        ; Compiling Words
  2965                        ;-------------------------------------------------------------------------------
  2966                        
  2967                        ; ( ( -- )
  2968                        ;
  2969                        ; Parse ccc delimited by ) (right parenthesis). ( is an immediate word.
  2970                        ;
  2971                        ; The number of characters in ccc may be zero to the number of characters in the
  2972                        ; parse area.
  2973                        ;
  2974                        ; In this implementation it is defined as:
  2975                        ;
  Tue Aug 22 2017 23:21                                                                                                    Page 59


  2976                        ;  [ HEX ] 29 WORD DROP ; IMMEDIATE
  2977                        
  2978 00:142A: 1A 14 80 01                  HEADER  1,"(",IMMEDIATE
       00:142E: 28 
  2979 00:142F: 20 BE 14                     jsr     DO_COLON
  2980 00:1432: C4 16 29 00                  dw      DO_LITERAL,')'
  2981 00:1436: B1 12                        dw      WORD
  2982 00:1438: 71 07                        dw      DROP
  2983 00:143A: E3 0E                        dw      EXIT
  2984                        
  2985                        ; .(
  2986                        
  2987 00:143C: 2D 14 80 02                  HEADER  2,".(",IMMEDIATE
       00:1440: 2E 28 
  2988 00:1442: 20 BE 14     DOT_PAREN:      jsr     DO_COLON
  2989 00:1445: C4 16 29 00                  dw      DO_LITERAL,')'
  2990 00:1449: B1 12                        dw      WORD
  2991 00:144B: 0A 14                        dw      COUNT
  2992 00:144D: FC 18                        dw      TYPE
  2993 00:144F: E3 0E                        dw      EXIT
  2994                        
  2995                        ; ." ( -- )
  2996                        
  2997 00:1451: 3F 14 80                     LINK    IMMEDIATE
  2998 00:1454: 02 2E 22                     db      2,".",'"'
  2999 00:1457: 20 BE 14     DOT_QUOTE:      jsr     DO_COLON
  3000 00:145A: 66 17                        dw      S_QUOTE
  3001 00:145C: C4 16 FC 18                  dw      DO_LITERAL,TYPE
  3002 00:1460: 79 05                        dw      COMMA
  3003 00:1462: E3 0E                        dw      EXIT
  3004                        
  3005                        
  3006                        ; +LOOP ( -- )
  3007                        
  3008 00:1464: 54 14 80 05                  HEADER  5,"+LOOP",IMMEDIATE
       00:1468: 2B 4C 4F 4F 
       00:146C: 50 
  3009 00:146D: 20 BE 14     PLUS_LOOP:      jsr     DO_COLON
  3010 00:1470: C4 16 86 14                  dw      DO_LITERAL,DO_PLUS_LOOP
  3011 00:1474: 79 05                        dw      COMMA
  3012 00:1476: 79 05                        dw      COMMA
  3013 00:1478: 45 07                        dw      QUERY_DUP
  3014 00:147A: 7D 16 84 14                  dw      QUERY_BRANCH,PLUS_LOOP_1
  3015 00:147E: 24 06                        dw      HERE
  3016 00:1480: 09 08                        dw      SWAP
  3017 00:1482: 4B 05                        dw      STORE
  3018 00:1484: E3 0E        PLUS_LOOP_1:    dw      EXIT
  3019                        
  3020                        DO_PLUS_LOOP:
  3021 00:1486: A6 01                        ldx     <1                      ; Fetch increment
  3022 00:1488: 7B                           tdc                             ; And drop
  3023 00:1489: 1A                           inc     a
  3024 00:148A: 1A                           inc     a
  3025 00:148B: 5B                           tcd
  3026 00:148C: 18                           clc                             ; Add to loop counter
  3027 00:148D: 8A                           txa
  3028 00:148E: 63 01                        adc     1,s
  3029 00:1490: 83 01                        sta     1,s
  Tue Aug 22 2017 23:21                                                                                                    Page 60


  3030 00:1492: C3 03                        cmp     3,s                     ; Reached limit?
  3031 00:1494: B0 0A                        bcs     DO_PLOOP_END            ; Yes
  3032 00:1496: B9 00 00                     lda     !0,y                    ; No, branch back to start
  3033 00:1499: A8                           tay
  3034 00:149A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:149E: 00 00 
  3035                        
  3036 00:14A0: C8           DO_PLOOP_END:   iny                             ; Skip over address
  3037 00:14A1: C8                           iny
  3038 00:14A2: 68                           pla                             ; Drop loop variables
  3039 00:14A3: 68                           pla
  3040 00:14A4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:14A8: 00 00 
  3041                        
  3042                        ; : ( -- )
  3043                        
  3044 00:14AA: 67 14 00 01                  HEADER  1,":",NORMAL
       00:14AE: 3A 
  3045 00:14AF: 20 BE 14     COLON:          jsr     DO_COLON
  3046 00:14B2: A8 0E                        dw      CREATE
  3047 00:14B4: C4 16 BE 14                  dw      DO_LITERAL,DO_COLON
  3048 00:14B8: 91 0E                        dw      BUILD
  3049 00:14BA: 6C 18                        dw      RIGHT_BRACKET
  3050 00:14BC: E3 0E                        dw      EXIT
  3051                        
  3052                        DO_COLON:
  3053 00:14BE: FA                           plx                             ; Pull new word IP-1
  3054 00:14BF: 5A                           phy                             ; Save the old IP
  3055 00:14C0: E8                           inx                             ; Work out new IP
  3056 00:14C1: 9B                           txy
  3057 00:14C2: BB C8 C8 7C                  CONTINUE                        ; Done
       00:14C6: 00 00 
  3058                        
  3059                        ; :NONAME ( -- xt )
  3060                        
  3061 00:14C8: AD 14 00 07                  HEADER  7,":NONAME",NORMAL
       00:14CC: 3A 4E 4F 4E 
       00:14D0: 41 4D 45 
  3062 00:14D3: 20 BE 14     NONAME:         jsr     DO_COLON
  3063 00:14D6: 24 06                        dw      HERE
  3064 00:14D8: C4 16 BE 14                  dw      DO_LITERAL,DO_COLON
  3065 00:14DC: 91 0E                        dw      BUILD
  3066 00:14DE: 6C 18                        dw      RIGHT_BRACKET
  3067 00:14E0: E3 0E                        dw      EXIT
  3068                        
  3069                        ; ; ( -- )
  3070                        
  3071 00:14E2: CB 14 80                     LINK    IMMEDIATE
  3072 00:14E5: 01 3B                        db      1,";"
  3073 00:14E7: 20 BE 14     SEMICOLON:      jsr     DO_COLON
  3074 00:14EA: C4 16 E3 0E                  dw      DO_LITERAL,EXIT
  3075 00:14EE: 79 05                        dw      COMMA
  3076 00:14F0: 4A 18                        dw      LEFT_BRACKET
  3077 00:14F2: E3 0E                        dw      EXIT
  3078                        
  3079                        ; ?DO ( -- )
  3080                        
  3081 00:14F4: E5 14 80 03                  HEADER  3,"?DO",IMMEDIATE
  Tue Aug 22 2017 23:21                                                                                                    Page 61


       00:14F8: 3F 44 4F 
  3082 00:14FB: 20 BE 14     QUERY_DO:       jsr     DO_COLON
  3083 00:14FE: C4 16 0E 15                  dw      DO_LITERAL,QUERY_DO_DO
  3084 00:1502: 79 05                        dw      COMMA
  3085 00:1504: 24 06                        dw      HERE
  3086 00:1506: CE 04                        dw      ZERO
  3087 00:1508: 79 05                        dw      COMMA
  3088 00:150A: 24 06                        dw      HERE
  3089 00:150C: E3 0E                        dw      EXIT
  3090                        
  3091                        QUERY_DO_DO:
  3092 00:150E: A5 01                        lda     <1                      ; Are the start and limit
  3093 00:1510: 45 03                        eor     <3                      ; .. the same?
  3094 00:1512: F0 05                        beq     QUERY_DO_DO_1
  3095 00:1514: C8                           iny                             ; No, Skip over jump address
  3096 00:1515: C8                           iny
  3097 00:1516: 4C 2B 16                     jmp     DO_DO                   ; And start a normal loop
  3098                        
  3099 00:1519: 7B           QUERY_DO_DO_1:  tdc                             ; Drop the loop parameters
  3100 00:151A: 1A                           inc     a
  3101 00:151B: 1A                           inc     a
  3102 00:151C: 1A                           inc     a
  3103 00:151D: 1A                           inc     a
  3104 00:151E: 5B                           tcd
  3105 00:151F: 4C 5C 16                     jmp     BRANCH                  ; And skip over loop
  3106                        
  3107                        ; 2CONSTANT ( x <spaces>name -- )
  3108                        ;
  3109                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  3110                        ; definition for name with the execution semantics defined below.
  3111                        
  3112 00:1522: F7 14 00 09                  HEADER  9,"2CONSTANT",NORMAL
       00:1526: 32 43 4F 4E 
       00:152A: 53 54 41 4E 
       00:152E: 54 
  3113 00:152F: 20 BE 14     TWO_CONSTANT:   jsr     DO_COLON
  3114 00:1532: A8 0E                        dw      CREATE
  3115 00:1534: C4 16 40 15                  dw      DO_LITERAL,DO_TWO_CONSTANT
  3116 00:1538: 91 0E                        dw      BUILD
  3117 00:153A: 79 05                        dw      COMMA
  3118 00:153C: 79 05                        dw      COMMA
  3119 00:153E: E3 0E                        dw      EXIT; AGAIN ( -- )
  3120                        
  3121                        DO_TWO_CONSTANT:
  3122 00:1540: FA                           plx                             ; Get return address
  3123 00:1541: 7B                           tdc                             ; Create space on stack
  3124 00:1542: 3A                           dec     a
  3125 00:1543: 3A                           dec     a
  3126 00:1544: 3A                           dec     a
  3127 00:1545: 3A                           dec     a
  3128 00:1546: 5B                           tcd
  3129 00:1547: BD 01 00                     lda     !1,x                    ; Transfer the value
  3130 00:154A: 85 01                        sta     <1
  3131 00:154C: BD 03 00                     lda     !3,x
  3132 00:154F: 85 03                        sta     <3
  3133 00:1551: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1555: 00 00 
  3134                        
  Tue Aug 22 2017 23:21                                                                                                    Page 62


  3135                        ; 2LITERAL
  3136                        
  3137 00:1557: 25 15 80 08                  HEADER  8,"2LITERAL",IMMEDIATE
       00:155B: 32 4C 49 54 
       00:155F: 45 52 41 4C 
  3138 00:1563: 20 BE 14     TWO_LITERAL:    jsr     DO_COLON
  3139 00:1566: C4 16 72 15                  dw      DO_LITERAL,DO_TWO_LITERAL
  3140 00:156A: 79 05                        dw      COMMA
  3141 00:156C: 79 05                        dw      COMMA
  3142 00:156E: 79 05                        dw      COMMA
  3143 00:1570: E3 0E                        dw      EXIT
  3144                        
  3145                        DO_TWO_LITERAL:
  3146 00:1572: 7B                           tdc                             ; Make room on stack
  3147 00:1573: 3A                           dec     a
  3148 00:1574: 3A                           dec     a
  3149 00:1575: 3A                           dec     a
  3150 00:1576: 3A                           dec     a
  3151 00:1577: 5B                           tcd
  3152 00:1578: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  3153 00:157B: 85 01                        sta     <1
  3154 00:157D: B9 02 00                     lda     !2,y
  3155 00:1580: 85 03                        sta     <3
  3156 00:1582: C8                           iny                             ; Bump IP
  3157 00:1583: C8                           iny
  3158 00:1584: C8                           iny
  3159 00:1585: C8                           iny
  3160 00:1586: BB C8 C8 7C                  CONTINUE                        ; Done
       00:158A: 00 00 
  3161                        
  3162                        ; 2VARIABLE
  3163                        
  3164 00:158C: 5A 15 80 09                  HEADER  9,"2VARIABLE",IMMEDIATE
       00:1590: 32 56 41 52 
       00:1594: 49 41 42 4C 
       00:1598: 45 
  3165 00:1599: 20 BE 14     TWO_VARIABLE:   jsr     DO_COLON
  3166 00:159C: A8 0E                        dw      CREATE
  3167 00:159E: C4 16 0F 18                  dw      DO_LITERAL,DO_VARIABLE
  3168 00:15A2: 91 0E                        dw      BUILD
  3169 00:15A4: C4 16 02 00                  dw      DO_LITERAL,2
  3170 00:15A8: 69 06                        dw      CELLS
  3171 00:15AA: CC 05                        dw      ALLOT
  3172 00:15AC: E3 0E                        dw      EXIT
  3173                        
  3174                        ; ABORT" ( -- )
  3175                        
  3176 00:15AE: 8F 15 80                     LINK    IMMEDIATE
  3177 00:15B1: 06 41 42 4F                  db      6,"ABORT",'"'
       00:15B5: 52 54 22 
  3178 00:15B8: 20 BE 14     ABORT_QUOTE:    jsr     DO_COLON
  3179 00:15BB: 66 17                        dw      S_QUOTE
  3180 00:15BD: C4 16 66 0E                  dw      DO_LITERAL,QUERY_ABORT
  3181 00:15C1: 79 05                        dw      COMMA
  3182 00:15C3: E3 0E                        dw      EXIT
  3183                        
  3184                        ; AGAIN ( -- )
  3185 00:15C5: B1 15 80 05                  HEADER  5,"AGAIN",IMMEDIATE
  Tue Aug 22 2017 23:21                                                                                                    Page 63


       00:15C9: 41 47 41 49 
       00:15CD: 4E 
  3186 00:15CE: 20 BE 14     AGAIN:          jsr     DO_COLON
  3187 00:15D1: C4 16 5C 16                  dw      DO_LITERAL,BRANCH
  3188 00:15D5: 79 05                        dw      COMMA
  3189 00:15D7: 79 05                        dw      COMMA
  3190 00:15D9: E3 0E                        dw      EXIT
  3191                        
  3192                        ; BEGIN ( -- )
  3193                        
  3194 00:15DB: C8 15 80 05                  HEADER  5,"BEGIN",IMMEDIATE
       00:15DF: 42 45 47 49 
       00:15E3: 4E 
  3195 00:15E4: 20 BE 14     BEGIN:          jsr     DO_COLON
  3196 00:15E7: 24 06                        dw      HERE
  3197 00:15E9: E3 0E                        dw      EXIT
  3198                        
  3199                        ; CONSTANT ( x <spaces>name -- )
  3200                        ;
  3201                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  3202                        ; definition for name with the execution semantics defined below.
  3203                        
  3204 00:15EB: DE 15 00 08                  HEADER  8,"CONSTANT",NORMAL
       00:15EF: 43 4F 4E 53 
       00:15F3: 54 41 4E 54 
  3205 00:15F7: 20 BE 14     CONSTANT:       jsr     DO_COLON
  3206 00:15FA: A8 0E                        dw      CREATE
  3207 00:15FC: C4 16 06 16                  dw      DO_LITERAL,DO_CONSTANT
  3208 00:1600: 91 0E                        dw      BUILD
  3209 00:1602: 79 05                        dw      COMMA
  3210 00:1604: E3 0E                        dw      EXIT
  3211                        
  3212                        DO_CONSTANT:
  3213 00:1606: FA                           plx                             ; Get return address
  3214 00:1607: 7B                           tdc                             ; Create space on stack
  3215 00:1608: 3A                           dec     a
  3216 00:1609: 3A                           dec     a
  3217 00:160A: 5B                           tcd
  3218 00:160B: BD 01 00                     lda     !1,x                    ; Transfer the value
  3219 00:160E: 85 01                        sta     <1
  3220 00:1610: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1614: 00 00 
  3221                        
  3222                        ; DO ( -- )
  3223                        
  3224 00:1616: EE 15 80 02                  HEADER  2,"DO",IMMEDIATE
       00:161A: 44 4F 
  3225 00:161C: 20 BE 14     DO:             jsr     DO_COLON
  3226 00:161F: C4 16 2B 16                  dw      DO_LITERAL,DO_DO
  3227 00:1623: 79 05                        dw      COMMA
  3228 00:1625: CE 04                        dw      ZERO
  3229 00:1627: 24 06                        dw      HERE
  3230 00:1629: E3 0E                        dw      EXIT
  3231                        
  3232                        DO_DO:
  3233 00:162B: A5 03                        lda     <3
  3234 00:162D: 48                           pha
  3235 00:162E: A5 01                        lda     <1
  Tue Aug 22 2017 23:21                                                                                                    Page 64


  3236 00:1630: 48                           pha
  3237 00:1631: 7B                           tdc
  3238 00:1632: 1A                           inc     a
  3239 00:1633: 1A                           inc     a
  3240 00:1634: 1A                           inc     a
  3241 00:1635: 1A                           inc     a
  3242 00:1636: 5B                           tcd
  3243 00:1637: BB C8 C8 7C                  CONTINUE
       00:163B: 00 00 
  3244                        
  3245                        ; ELSE ( -- )
  3246                        
  3247 00:163D: 19 16 80 04                  HEADER  4,"ELSE",IMMEDIATE
       00:1641: 45 4C 53 45 
  3248 00:1645: 20 BE 14     ELSE:           jsr     DO_COLON
  3249 00:1648: C4 16 5C 16                  dw      DO_LITERAL,BRANCH
  3250 00:164C: 79 05                        dw      COMMA
  3251 00:164E: 24 06                        dw      HERE
  3252 00:1650: CE 04                        dw      ZERO
  3253 00:1652: 79 05                        dw      COMMA
  3254 00:1654: 24 06                        dw      HERE
  3255 00:1656: 09 08                        dw      SWAP
  3256 00:1658: 4B 05                        dw      STORE
  3257 00:165A: E3 0E                        dw      EXIT
  3258                        
  3259                        BRANCH:
  3260 00:165C: B9 00 00                     lda     !0,y                    ; Load branch address into IP
  3261 00:165F: A8                           tay
  3262 00:1660: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1664: 00 00 
  3263                        
  3264                        ; IF ( -- )
  3265                        
  3266 00:1666: 40 16 80 02                  HEADER  2,"IF",IMMEDIATE
       00:166A: 49 46 
  3267 00:166C: 20 BE 14     IF:             jsr     DO_COLON
  3268 00:166F: C4 16 7D 16                  dw      DO_LITERAL,QUERY_BRANCH
  3269 00:1673: 79 05                        dw      COMMA
  3270 00:1675: 24 06                        dw      HERE
  3271 00:1677: CE 04                        dw      ZERO
  3272 00:1679: 79 05                        dw      COMMA
  3273 00:167B: E3 0E                        dw      EXIT
  3274                        
  3275                        QUERY_BRANCH:
  3276 00:167D: A6 01                        ldx     <1                      ; Pull the top of stack value
  3277 00:167F: 7B                           tdc
  3278 00:1680: 1A                           inc     a                       ; Drop top item
  3279 00:1681: 1A                           inc     a
  3280 00:1682: 5B                           tcd
  3281 00:1683: 8A                           txa
  3282 00:1684: F0 D6                        beq     BRANCH                  ; Branch if top was zero
  3283 00:1686: C8                           iny                             ; Otherwise skip address
  3284 00:1687: C8                           iny
  3285 00:1688: BB C8 C8 7C                  CONTINUE                        ; Done
       00:168C: 00 00 
  3286                        
  3287                        ; IMMEDIATE ( -- )
  3288                        
  Tue Aug 22 2017 23:21                                                                                                    Page 65


  3289 00:168E: 69 16 80 09                  HEADER  9,"IMMEDIATE",IMMEDIATE
       00:1692: 49 4D 4D 45 
       00:1696: 44 49 41 54 
       00:169A: 45 
  3290 00:169B: 20 BE 14                     jsr     DO_COLON
  3291 00:169E: C4 16 80 00                  dw      DO_LITERAL,IMMEDIATE
  3292 00:16A2: 94 04                        dw      LATEST
  3293 00:16A4: B9 05                        dw      FETCH
  3294 00:16A6: 7B 09                        dw      ONE_MINUS
  3295 00:16A8: DB 05                        dw      C_STORE
  3296 00:16AA: E3 0E                        dw      EXIT
  3297                        
  3298                        ; LITERAL ( x -- )
  3299                        ;
  3300                        ; Append the run-time semantics given below to the current definition.
  3301                        
  3302 00:16AC: 91 16 80 07                  HEADER  7,"LITERAL",IMMEDIATE
       00:16B0: 4C 49 54 45 
       00:16B4: 52 41 4C 
  3303 00:16B7: 20 BE 14     LITERAL:        jsr     DO_COLON
  3304 00:16BA: C4 16 C4 16                  dw      DO_LITERAL,DO_LITERAL
  3305 00:16BE: 79 05                        dw      COMMA
  3306 00:16C0: 79 05                        dw      COMMA
  3307 00:16C2: E3 0E                        dw      EXIT
  3308                        
  3309                        DO_LITERAL:
  3310 00:16C4: 7B                           tdc                             ; Make room on stack
  3311 00:16C5: 3A                           dec     a
  3312 00:16C6: 3A                           dec     a
  3313 00:16C7: 5B                           tcd
  3314 00:16C8: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  3315 00:16CB: 85 01                        sta     <1
  3316 00:16CD: C8                           iny
  3317 00:16CE: C8                           iny
  3318 00:16CF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:16D3: 00 00 
  3319                        
  3320                        ; LOOP
  3321                        
  3322 00:16D5: AF 16 80 04                  HEADER  4,"LOOP",IMMEDIATE
       00:16D9: 4C 4F 4F 50 
  3323 00:16DD: 20 BE 14     LOOP:           jsr     DO_COLON
  3324 00:16E0: C4 16 F6 16                  dw      DO_LITERAL,DO_LOOP
  3325 00:16E4: 79 05                        dw      COMMA
  3326 00:16E6: 79 05                        dw      COMMA
  3327 00:16E8: 45 07                        dw      QUERY_DUP
  3328 00:16EA: 7D 16 F4 16                  dw      QUERY_BRANCH,LOOP_1
  3329 00:16EE: 24 06                        dw      HERE
  3330 00:16F0: 09 08                        dw      SWAP
  3331 00:16F2: 4B 05                        dw      STORE
  3332 00:16F4: E3 0E        LOOP_1:         dw      EXIT
  3333                        
  3334                        ; (LOOP)
  3335                        
  3336                        ;               HEADER  6,"(LOOP)",NORMAL
  3337                        DO_LOOP
  3338 00:16F6: A3 01                        lda     1,s                     ; Add one to loop counter
  3339 00:16F8: 1A                           inc     a
  Tue Aug 22 2017 23:21                                                                                                    Page 66


  3340 00:16F9: 83 01                        sta     1,s
  3341 00:16FB: C3 03                        cmp     3,s                     ; Reached limit?
  3342 00:16FD: B0 0A                        bcs     DO_LOOP_END             ; Yes
  3343 00:16FF: B9 00 00                     lda     !0,y                    ; No, branch back to start
  3344 00:1702: A8                           tay
  3345 00:1703: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1707: 00 00 
  3346                        
  3347 00:1709: C8           DO_LOOP_END:    iny                             ; Skip over address
  3348 00:170A: C8                           iny
  3349 00:170B: 68                           pla                             ; Drop loop variables
  3350 00:170C: 68                           pla
  3351 00:170D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1711: 00 00 
  3352                        
  3353                        ; POSTPONE
  3354                        
  3355                        ;   BL WORD FIND
  3356                        ;   DUP 0= ABORT" ?"
  3357                        ;   0< IF   -- xt       non immed: add code to current
  3358                        ;                       def'n to compile xt later.
  3359                        ;       ['] LIT ,XT  ,  add "LIT,xt,COMMAXT"
  3360                        ;       ['] ,XT ,XT     to current definition
  3361                        ;   ELSE  ,XT      immed: compile into cur. def'n
  3362                        ;   THEN ; IMMEDIATE
  3363                        
  3364 00:1713: D8 16 80 08                  HEADER  8,"POSTPONE",IMMEDIATE
       00:1717: 50 4F 53 54 
       00:171B: 50 4F 4E 45 
  3365 00:171F: 20 BE 14     POSTPONE:       jsr     DO_COLON
  3366 00:1722: E0 04                        dw      BL
  3367 00:1724: B1 12                        dw      WORD
  3368 00:1726: 46 11                        dw      FIND
  3369 00:1728: 82 07                        dw      DUP
  3370 00:172A: 03 0D                        dw      ZERO_EQUAL
  3371 00:172C: 7F 17                        dw      DO_S_QUOTE
  3372 00:172E: 01 3F                        db      1,"?"
  3373 00:1730: 66 0E                        dw      QUERY_ABORT
  3374 00:1732: DA 0C                        dw      ZERO_LESS
  3375 00:1734: 7D 16 44 17                  dw      QUERY_BRANCH,POSTPONE_1
  3376 00:1738: C4 16 C4 16                  dw      DO_LITERAL,DO_LITERAL
  3377 00:173C: 79 05                        dw      COMMA
  3378 00:173E: 79 05                        dw      COMMA
  3379 00:1740: 5C 16 46 17                  dw      BRANCH,POSTPONE_2
  3380 00:1744: 79 05        POSTPONE_1:     dw      COMMA
  3381 00:1746: E3 0E        POSTPONE_2:     dw      EXIT
  3382                        
  3383                        ; RECURSE ( -- )
  3384                        
  3385 00:1748: 16 17 80 07                  HEADER  7,"RECURSE",IMMEDIATE
       00:174C: 52 45 43 55 
       00:1750: 52 53 45 
  3386 00:1753: 20 BE 14     RECURSE:        jsr     DO_COLON
  3387 00:1756: 94 04                        dw      LATEST
  3388 00:1758: B9 05                        dw      FETCH
  3389 00:175A: 8E 11                        dw      NFA_TO_CFA
  3390 00:175C: 79 05                        dw      COMMA
  3391 00:175E: E3 0E                        dw      EXIT
  Tue Aug 22 2017 23:21                                                                                                    Page 67


  3392                        
  3393                        ; S"
  3394                        
  3395 00:1760: 4B 17 80                     LINK    IMMEDIATE
  3396 00:1763: 02 53 22                     db      2,"S",'"'
  3397 00:1766: 20 BE 14     S_QUOTE:        jsr     DO_COLON
  3398 00:1769: C4 16 7F 17                  dw      DO_LITERAL,DO_S_QUOTE
  3399 00:176D: 79 05                        dw      COMMA
  3400 00:176F: C4 16 22 00                  dw      DO_LITERAL,'"'
  3401 00:1773: B1 12                        dw      WORD
  3402 00:1775: 0C 06                        dw      C_FETCH
  3403 00:1777: 6D 09                        dw      ONE_PLUS
  3404 00:1779: 47 06                        dw      ALIGNED
  3405 00:177B: CC 05                        dw      ALLOT
  3406 00:177D: E3 0E                        dw      EXIT
  3407                        
  3408                        ; (S") ( -- c-addr u )
  3409                        
  3410                        DO_S_QUOTE:
  3411 00:177F: 20 BE 14                     jsr     DO_COLON
  3412 00:1782: B4 08                        dw      R_FROM
  3413 00:1784: 0A 14                        dw      COUNT
  3414 00:1786: BF 06                        dw      TWO_DUP
  3415 00:1788: 15 09                        dw      PLUS
  3416 00:178A: 47 06                        dw      ALIGNED
  3417 00:178C: 7B 08                        dw      TO_R
  3418 00:178E: E3 0E                        dw      EXIT
  3419                        
  3420                        ; THEN ( -- )
  3421                        
  3422 00:1790: 63 17 80 04                  HEADER  4,"THEN",IMMEDIATE
       00:1794: 54 48 45 4E 
  3423 00:1798: 20 BE 14     THEN:           jsr     DO_COLON
  3424 00:179B: 24 06                        dw      HERE
  3425 00:179D: 09 08                        dw      SWAP
  3426 00:179F: 4B 05                        dw      STORE
  3427 00:17A1: E3 0E                        dw      EXIT
  3428                        
  3429                        ; UNTIL ( -- )
  3430                        
  3431 00:17A3: 93 17 80 05                  HEADER  5,"UNTIL",IMMEDIATE
       00:17A7: 55 4E 54 49 
       00:17AB: 4C 
  3432 00:17AC: 20 BE 14     UNTIL:          jsr     DO_COLON
  3433 00:17AF: C4 16 7D 16                  dw      DO_LITERAL,QUERY_BRANCH
  3434 00:17B3: 79 05                        dw      COMMA
  3435 00:17B5: 79 05                        dw      COMMA
  3436 00:17B7: E3 0E                        dw      EXIT
  3437                        
  3438                        ; USER
  3439                        
  3440 00:17B9: A6 17 00 04                  HEADER  4,"USER",NORMAL
       00:17BD: 55 53 45 52 
  3441 00:17C1: 20 BE 14     USER:           jsr     DO_COLON
  3442 00:17C4: A8 0E                        dw      CREATE
  3443 00:17C6: C4 16 DA 17                  dw      DO_LITERAL,DO_USER
  3444 00:17CA: 91 0E                        dw      BUILD
  3445 00:17CC: 79 05                        dw      COMMA
  Tue Aug 22 2017 23:21                                                                                                    Page 68


  3446 00:17CE: E3 0E                        dw      EXIT
  3447                        
  3448 00:17D0: BC 17 00 06                  HEADER  6,"(USER)",NORMAL
       00:17D4: 28 55 53 45 
       00:17D8: 52 29 
  3449                        DO_USER:
  3450 00:17DA: 7B                           tdc
  3451 00:17DB: 3A                           dec     a                       ; Push on data stack
  3452 00:17DC: 3A                           dec     a
  3453 00:17DD: 5B                           tcd
  3454 00:17DE: FA                           plx
  3455 00:17DF: 18                           clc
  3456 00:17E0: BD 01 00                     lda     !1,x
  3457 00:17E3: 69 00 00                     adc     #USER_AREA
  3458 00:17E6: 85 01                        sta     <1
  3459 00:17E8: BB C8 C8 7C                  CONTINUE                        ; Done
       00:17EC: 00 00 
  3460                        
  3461                        ; VARIABLE ( <spaces>name -- )
  3462                        ;
  3463                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  3464                        ; definition for name with the execution semantics defined below. Reserve one
  3465                        ; cell of data space at an aligned address.
  3466                        
  3467 00:17EE: D3 17 00                     LINK    NORMAL
  3468 00:17F1: 08 56 41 52                  db      8,"VARIABLE"
       00:17F5: 49 41 42 4C 
       00:17F9: 45 
  3469 00:17FA: 20 BE 14     VARIABLE:       jsr     DO_COLON
  3470 00:17FD: A8 0E                        dw      CREATE
  3471 00:17FF: C4 16 0F 18                  dw      DO_LITERAL,DO_VARIABLE
  3472 00:1803: 91 0E                        dw      BUILD
  3473 00:1805: C4 16 01 00                  dw      DO_LITERAL,1
  3474 00:1809: 69 06                        dw      CELLS
  3475 00:180B: CC 05                        dw      ALLOT
  3476 00:180D: E3 0E                        dw      EXIT
  3477                        
  3478                        DO_VARIABLE:
  3479 00:180F: 7B                           tdc
  3480 00:1810: 3A                           dec     a
  3481 00:1811: 3A                           dec     a
  3482 00:1812: 5B                           tcd
  3483 00:1813: 68                           pla
  3484 00:1814: 1A                           inc     a
  3485 00:1815: 85 01                        sta     <1
  3486 00:1817: BB C8 C8 7C                  CONTINUE
       00:181B: 00 00 
  3487                        
  3488                        ; WORDS ( -- )
  3489                        ;
  3490                        ;   LATEST @ BEGIN
  3491                        ;       DUP COUNT TYPE SPACE
  3492                        ;       NFA>LFA @
  3493                        ;   DUP 0= UNTIL
  3494                        ;   DROP ;
  3495                        
  3496 00:181D: F1 17 00 05                  HEADER  5,"WORDS",NORMAL
       00:1821: 57 4F 52 44 
  Tue Aug 22 2017 23:21                                                                                                    Page 69


       00:1825: 53 
  3497 00:1826: 20 BE 14                     jsr     DO_COLON
  3498 00:1829: 94 04                        dw      LATEST
  3499 00:182B: B9 05                        dw      FETCH
  3500 00:182D: 82 07        WORDS_1:        dw      DUP
  3501 00:182F: 0A 14                        dw      COUNT
  3502 00:1831: FC 18                        dw      TYPE
  3503 00:1833: CA 18                        dw      SPACE
  3504 00:1835: 97 11                        dw      NFA_TO_LFA
  3505 00:1837: B9 05                        dw      FETCH
  3506 00:1839: 82 07                        dw      DUP
  3507 00:183B: 03 0D                        dw      ZERO_EQUAL
  3508 00:183D: 7D 16 2D 18                  dw      QUERY_BRANCH,WORDS_1
  3509 00:1841: 71 07                        dw      DROP
  3510 00:1843: E3 0E                        dw      EXIT
  3511                        
  3512                        ; [
  3513                        ;
  3514                        ; In this implementation it is defined as
  3515                        ;
  3516                        ;   0 STATE !
  3517                        
  3518 00:1845: 20 18 80 01                  HEADER  1,"[",IMMEDIATE
       00:1849: 5B 
  3519 00:184A: 20 BE 14     LEFT_BRACKET:   jsr     DO_COLON
  3520 00:184D: CE 04                        dw      ZERO
  3521 00:184F: B8 04                        dw      STATE
  3522 00:1851: 4B 05                        dw      STORE
  3523 00:1853: E3 0E                        dw      EXIT
  3524                        
  3525                        ; \ ( -- )
  3526                        ;
  3527                        ; Parse and discard the remainder of the parse area. \ is an immediate word.
  3528                        ;
  3529                        ; In this implementation it is defined as
  3530                        ;
  3531                        ;   1 WORD DROP
  3532                        
  3533 00:1855: 48 18 80 01                  HEADER  1,"\",IMMEDIATE
       00:1859: 5C 
  3534 00:185A: 20 BE 14     BACKSLASH:      jsr     DO_COLON
  3535 00:185D: C4 16 01 00                  dw      DO_LITERAL,1
  3536 00:1861: B1 12                        dw      WORD
  3537 00:1863: 71 07                        dw      DROP
  3538 00:1865: E3 0E                        dw      EXIT
  3539                        
  3540                        ; ]
  3541                        ;
  3542                        ; In this implementation it is defined as
  3543                        ;
  3544                        ;   -1 STATE !
  3545                        
  3546 00:1867: 58 18 00 01                  HEADER  1,"]",NORMAL
       00:186B: 5D 
  3547 00:186C: 20 BE 14     RIGHT_BRACKET:  jsr     DO_COLON
  3548 00:186F: C4 16 FF FF                  dw      DO_LITERAL,-1
  3549 00:1873: B8 04                        dw      STATE
  3550 00:1875: 4B 05                        dw      STORE
  Tue Aug 22 2017 23:21                                                                                                    Page 70


  3551 00:1877: E3 0E                        dw      EXIT
  3552                        
  3553                        ;===============================================================================
  3554                        ; I/O Operations
  3555                        ;-------------------------------------------------------------------------------
  3556                        
  3557                        ; CR ( -- )
  3558                        ;
  3559                        ; Cause subsequent output to appear at the beginning of the next line.
  3560                        ;
  3561                        ; In this implementation it is defined as
  3562                        ;
  3563                        ;   13 EMIT 10 EMIT
  3564                        
  3565 00:1879: 6A 18 00 02                  HEADER  2,"CR",NORMAL
       00:187D: 43 52 
  3566 00:187F: 20 BE 14     CR:             jsr     DO_COLON
  3567 00:1882: C4 16 0D 00                  dw      DO_LITERAL,13
  3568 00:1886: 98 18                        dw      EMIT
  3569 00:1888: C4 16 0A 00                  dw      DO_LITERAL,10
  3570 00:188C: 98 18                        dw      EMIT
  3571 00:188E: E3 0E                        dw      EXIT
  3572                        
  3573                        ; EMIT ( x -- )
  3574                        ;
  3575                        ; If x is a graphic character in the implementation-defined character set,
  3576                        ; display x. The effect of EMIT for all other values of x is implementation
  3577                        ; -defined.
  3578                        
  3579 00:1890: 7C 18 00 04                  HEADER  4,"EMIT",NORMAL
       00:1894: 45 4D 49 54 
  3580                                        extern  UartTx
  3581                        EMIT:
  3582 00:1898: A5 01                        lda     <1                      ; Fetch character from stack
  3583 00:189A: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  3584 00:189D: 7B                           tdc
  3585 00:189E: 1A                           inc     a                       ; Drop the character
  3586 00:189F: 1A                           inc     a
  3587 00:18A0: 5B                           tcd
  3588 00:18A1: BB C8 C8 7C                  CONTINUE                        ; Done
       00:18A5: 00 00 
  3589                        
  3590                        ; KEY ( -- char )
  3591                        ;
  3592                        ; Receive one character char, a member of the implementation-defined character
  3593                        ; set. Keyboard events that do not correspond to such characters are discarded
  3594                        ; until a valid character is received, and those events are subsequently
  3595                        ; unavailable.
  3596                        ;
  3597                        ; All standard characters can be received. Characters received by KEY are not
  3598                        ; displayed.
  3599                        
  3600 00:18A7: 93 18 00 03                  HEADER  3,"KEY",NORMAL
       00:18AB: 4B 45 59 
  3601                                        extern  UartRx
  3602                        KEY:
  3603 00:18AE: 20 xx xx                     jsr     UartRx                  ; Receive a character
  3604 00:18B1: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  Tue Aug 22 2017 23:21                                                                                                    Page 71


  3605 00:18B4: AA                           tax
  3606 00:18B5: 7B                           tdc
  3607 00:18B6: 3A                           dec     a                       ; And push to stack
  3608 00:18B7: 3A                           dec     a
  3609 00:18B8: 5B                           tcd
  3610 00:18B9: 86 01                        stx     <1
  3611 00:18BB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:18BF: 00 00 
  3612                        
  3613                        ; SPACE ( -- )
  3614                        ;
  3615                        ; Display one space.
  3616                        ;
  3617                        ; In this implementation it is defined as
  3618                        ;
  3619                        ;   BL EMIT
  3620                        
  3621 00:18C1: AA 18 00 05                  HEADER  5,"SPACE",NORMAL
       00:18C5: 53 50 41 43 
       00:18C9: 45 
  3622 00:18CA: 20 BE 14     SPACE:          jsr     DO_COLON
  3623 00:18CD: E0 04                        dw      BL
  3624 00:18CF: 98 18                        dw      EMIT
  3625 00:18D1: E3 0E                        dw      EXIT
  3626                        
  3627                        ; SPACES ( n -- )
  3628                        ;
  3629                        ; If n is greater than zero, display n spaces.
  3630                        ;
  3631                        ; In this implementation it is defined as
  3632                        ;
  3633                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  3634                        
  3635 00:18D3: C4 18 00 06                  HEADER  6,"SPACES",NORMAL
       00:18D7: 53 50 41 43 
       00:18DB: 45 53 
  3636 00:18DD: 20 BE 14     SPACES:         jsr     DO_COLON
  3637 00:18E0: 82 07        SPACES_1:       dw      DUP
  3638 00:18E2: 17 0D                        dw      ZERO_GREATER
  3639 00:18E4: 7D 16 F0 18                  dw      QUERY_BRANCH,SPACES_2
  3640 00:18E8: CA 18                        dw      SPACE
  3641 00:18EA: 7B 09                        dw      ONE_MINUS
  3642 00:18EC: 5C 16 E0 18                  dw      BRANCH,SPACES_1
  3643 00:18F0: 71 07        SPACES_2:       dw      DROP
  3644 00:18F2: E3 0E                        dw      EXIT
  3645                        
  3646                        ; TYPE ( c-addr u -- )
  3647                        ;
  3648                        ; If u is greater than zero, display the character string specified by c-addr
  3649                        ; and u.
  3650                        ;
  3651                        ; In this implementation it is defined as
  3652                        ;
  3653                        ;   ?DUP IF
  3654                        ;     OVER + SWAP DO I C@ EMIT LOOP
  3655                        ;   ELSE DROP THEN
  3656                        
  3657 00:18F4: D6 18 00 04                  HEADER  4,"TYPE",NORMAL
  Tue Aug 22 2017 23:21                                                                                                    Page 72


       00:18F8: 54 59 50 45 
  3658 00:18FC: 20 BE 14     TYPE:           jsr     DO_COLON
  3659 00:18FF: 45 07                        dw      QUERY_DUP
  3660 00:1901: 7D 16 1B 19                  dw      QUERY_BRANCH,TYPE_2
  3661 00:1905: A5 07                        dw      OVER
  3662 00:1907: 15 09                        dw      PLUS
  3663 00:1909: 09 08                        dw      SWAP
  3664 00:190B: 2B 16                        dw      DO_DO
  3665 00:190D: 8D 08        TYPE_1:         dw      I
  3666 00:190F: 0C 06                        dw      C_FETCH
  3667 00:1911: 98 18                        dw      EMIT
  3668 00:1913: F6 16 0D 19                  dw      DO_LOOP,TYPE_1
  3669 00:1917: 5C 16 1D 19                  dw      BRANCH,TYPE_3
  3670 00:191B: 71 07        TYPE_2          dw      DROP
  3671 00:191D: E3 0E        TYPE_3          dw      EXIT
  3672                        
  3673                        ;===============================================================================
  3674                        ; Formatted Output
  3675                        ;-------------------------------------------------------------------------------
  3676                        
  3677                        ; # ( ud1 -- ud2 )
  3678                        ;
  3679                        ; Divide ud1 by the number in BASE giving the quotient ud2 and the remainder n.
  3680                        ; (n is the least-significant digit of ud1.) Convert n to external form and add
  3681                        ; the resulting character to the beginning of the pictured numeric output string.
  3682                        ; An ambiguous condition exists if # executes outside of a <# #> delimited
  3683                        ; number conversion.
  3684                        ;
  3685                        ;       BASE @ >R 0 R@ UM/MOD ROT ROT R> UM/MOD ROT ROT DUP 9 > 7 AND + 30 + HOLD
  3686                        
  3687 00:191F: F7 18 00 01                  HEADER  1,"#",NORMAL
       00:1923: 23 
  3688 00:1924: 20 BE 14     HASH:           jsr     DO_COLON
  3689 00:1927: 64 04                        dw      BASE
  3690 00:1929: B9 05                        dw      FETCH
  3691 00:192B: 7B 08                        dw      TO_R
  3692 00:192D: CE 04                        dw      ZERO
  3693 00:192F: C7 08                        dw      R_FETCH
  3694 00:1931: A5 0C                        dw      UM_SLASH_MOD
  3695 00:1933: EF 07                        dw      ROT
  3696 00:1935: EF 07                        dw      ROT
  3697 00:1937: B4 08                        dw      R_FROM
  3698 00:1939: A5 0C                        dw      UM_SLASH_MOD
  3699 00:193B: EF 07                        dw      ROT
  3700 00:193D: EF 07                        dw      ROT
  3701 00:193F: 82 07                        dw      DUP
  3702 00:1941: C4 16 09 00                  dw      DO_LITERAL,9
  3703 00:1945: 6D 0D                        dw      GREATER
  3704 00:1947: C4 16 07 00                  dw      DO_LITERAL,7
  3705 00:194B: BA 0D                        dw      AND
  3706 00:194D: 15 09                        dw      PLUS
  3707 00:194F: C4 16 30 00                  dw      DO_LITERAL,'0'
  3708 00:1953: 15 09                        dw      PLUS
  3709 00:1955: BE 19                        dw      HOLD
  3710 00:1957: E3 0E                        dw      EXIT
  3711                        
  3712                        ; #> ( xd -- c-addr u )
  3713                        ;
  Tue Aug 22 2017 23:21                                                                                                    Page 73


  3714                        ; Drop xd. Make the pictured numeric output string available as a character
  3715                        ; string. c-addr and u specify the resulting character string. A program may
  3716                        ; replace characters within the string.
  3717                        ;
  3718                        ;       2DROP HP @ PAD OVER -
  3719                        
  3720 00:1959: 22 19 00 02                  HEADER  2,"#>",NORMAL
       00:195D: 23 3E 
  3721 00:195F: 20 BE 14     HASH_GREATER:   jsr     DO_COLON
  3722 00:1962: AB 06                        dw      TWO_DROP
  3723 00:1964: 85 04                        dw      HP
  3724 00:1966: B9 05                        dw      FETCH
  3725 00:1968: D8 19                        dw      PAD
  3726 00:196A: A5 07                        dw      OVER
  3727 00:196C: 2B 09                        dw      MINUS
  3728 00:196E: E3 0E                        dw      EXIT
  3729                        
  3730                        ; #S ( ud1 -- ud2 )
  3731                        ;
  3732                        ; Convert one digit of ud1 according to the rule for #. Continue conversion
  3733                        ; until the quotient is zero. ud2 is zero. An ambiguous condition exists if #S
  3734                        ; executes outside of a <# #> delimited number conversion.
  3735                        ;
  3736                        ;       BEGIN # 2DUP OR 0= UNTIL
  3737                        
  3738 00:1970: 5C 19 00 02                  HEADER  2,"#S",NORMAL
       00:1974: 23 53 
  3739 00:1976: 20 BE 14     HASH_S:         jsr     DO_COLON
  3740 00:1979: 24 19        HASH_S_1:       dw      HASH
  3741 00:197B: BF 06                        dw      TWO_DUP
  3742 00:197D: 13 0E                        dw      OR
  3743 00:197F: 03 0D                        dw      ZERO_EQUAL
  3744 00:1981: 7D 16 79 19                  dw      QUERY_BRANCH,HASH_S_1
  3745 00:1985: E3 0E                        dw      EXIT
  3746                        
  3747                        ; . ( n -- )
  3748                        ;
  3749                        ; Display n in free field format.
  3750                        ;
  3751                        ;       <# DUP ABS 0 #S ROT SIGN #> TYPE SPACE
  3752                        
  3753 00:1987: 73 19 00 01                  HEADER  1,".",NORMAL
       00:198B: 2E 
  3754 00:198C: 20 BE 14     DOT:            jsr     DO_COLON
  3755 00:198F: AB 19                        dw      LESS_HASH
  3756 00:1991: 82 07                        dw      DUP
  3757 00:1993: B6 09                        dw      ABS
  3758 00:1995: CE 04                        dw      ZERO
  3759 00:1997: 76 19                        dw      HASH_S
  3760 00:1999: EF 07                        dw      ROT
  3761 00:199B: E5 19                        dw      SIGN
  3762 00:199D: 5F 19                        dw      HASH_GREATER
  3763 00:199F: FC 18                        dw      TYPE
  3764 00:19A1: CA 18                        dw      SPACE
  3765 00:19A3: E3 0E                        dw      EXIT
  3766                        
  3767                        ; <# ( -- )
  3768                        ;
  Tue Aug 22 2017 23:21                                                                                                    Page 74


  3769                        ; Initialize the pictured numeric output conversion process.
  3770                        ;
  3771                        ;       PAD HP !
  3772                        
  3773 00:19A5: 8A 19 00 02                  HEADER  2,"<#",NORMAL
       00:19A9: 3C 23 
  3774 00:19AB: 20 BE 14     LESS_HASH:      jsr     DO_COLON
  3775 00:19AE: D8 19                        dw      PAD
  3776 00:19B0: 85 04                        dw      HP
  3777 00:19B2: 4B 05                        dw      STORE
  3778 00:19B4: E3 0E                        dw      EXIT
  3779                        
  3780                        ; HOLD ( char -- )
  3781                        
  3782                        ; Add char to the beginning of the pictured numeric output string. An
  3783                        ; ambiguous condition exists if HOLD executes outside of a <# #> delimited
  3784                        ; number conversion.
  3785                        ;
  3786                        ;       -1 HP +!  HP @ C!
  3787                        
  3788 00:19B6: A8 19 00 04                  HEADER  4,"HOLD",NORMAL
       00:19BA: 48 4F 4C 44 
  3789 00:19BE: 20 BE 14     HOLD:           jsr     DO_COLON
  3790 00:19C1: C4 16 FF FF                  dw      DO_LITERAL,-1
  3791 00:19C5: 85 04                        dw      HP
  3792 00:19C7: 61 05                        dw      PLUS_STORE
  3793 00:19C9: 85 04                        dw      HP
  3794 00:19CB: B9 05                        dw      FETCH
  3795 00:19CD: DB 05                        dw      C_STORE
  3796 00:19CF: E3 0E                        dw      EXIT
  3797                        
  3798                        ; PAD ( -- c-addr )
  3799                        ;
  3800                        ; c-addr is the address of a transient region that can be used to hold data
  3801                        ; for intermediate processing.
  3802                        
  3803 00:19D1: B9 19 00 03                  HEADER  3,"PAD",NORMAL
       00:19D5: 50 41 44 
  3804 00:19D8: 20 06 16     PAD:            jsr     DO_CONSTANT
  3805 00:19DB: B0 02                        dw      PAD_AREA
  3806                        
  3807                        ; SIGN ( n -- )
  3808                        ;
  3809                        ; If n is negative, add a minus sign to the beginning of the pictured numeric
  3810                        ; output string. An ambiguous condition exists if SIGN executes outside of a
  3811                        ; <# #> delimited number conversion.
  3812                        ;
  3813                        ;       [ HEX ] 0< IF 2D HOLD THEN
  3814                        
  3815 00:19DD: D4 19 00 04                  HEADER  4,"SIGN",NORMAL
       00:19E1: 53 49 47 4E 
  3816 00:19E5: 20 BE 14     SIGN:           jsr     DO_COLON
  3817 00:19E8: DA 0C                        dw      ZERO_LESS
  3818 00:19EA: 7D 16 F4 19                  dw      QUERY_BRANCH,SIGN_1
  3819 00:19EE: C4 16 2D 00                  dw      DO_LITERAL,'-'
  3820 00:19F2: BE 19                        dw      HOLD
  3821 00:19F4: E3 0E        SIGN_1:         dw      EXIT
  3822                        
  Tue Aug 22 2017 23:21                                                                                                    Page 75


  3823                        ; U. ( u -- )
  3824                        ;
  3825                        ; Display u in free field format.
  3826                        ;
  3827                        ;  <# 0 #S #> TYPE SPACE
  3828                        
  3829 00:19F6: E0 19 00 02                  HEADER  2,"U.",NORMAL
       00:19FA: 55 2E 
  3830 00:19FC: 20 BE 14     U_DOT:          jsr     DO_COLON
  3831 00:19FF: AB 19                        dw      LESS_HASH
  3832 00:1A01: CE 04                        dw      ZERO
  3833 00:1A03: 76 19                        dw      HASH_S
  3834 00:1A05: 5F 19                        dw      HASH_GREATER
  3835 00:1A07: FC 18                        dw      TYPE
  3836 00:1A09: CA 18                        dw      SPACE
  3837 00:1A0B: E3 0E                        dw      EXIT
  3838                        
  3839                        ;===============================================================================
  3840                        ; Programming Tools
  3841                        ;-------------------------------------------------------------------------------
  3842                        
  3843                        ; .NYBBLE ( n -- )
  3844                        ;
  3845                        ; Print the least significant nybble of the top value on the stack in hex.
  3846                        
  3847                        ;               HEADER  7,".NYBBLE",NORMAL
  3848                        DOT_NYBBLE:
  3849 00:1A0D: A5 01                        lda     <1
  3850 00:1A0F: 29 0F 00                     and     #$000f
  3851 00:1A12: 09 30 00                     ora     #$0030
  3852 00:1A15: C9 3A 00                     cmp     #$003a
  3853 00:1A18: 90 03                        bcc     $+5
  3854 00:1A1A: 69 06 00                     adc     #$0006
  3855 00:1A1D: 20 xx xx                     jsr     UartTx
  3856 00:1A20: 4C 71 07                     jmp     DROP
  3857                        
  3858                        ; .BYTE ( n -- )
  3859                        ;
  3860                        ; Print least significant byte of top value on the stack in hex followed by
  3861                        ; a space.
  3862                        
  3863 00:1A23: F9 19 00 05                  HEADER  5,".BYTE",NORMAL
       00:1A27: 2E 42 59 54 
       00:1A2B: 45 
  3864 00:1A2C: 20 BE 14     DOT_BYTE:       jsr     DO_COLON
  3865 00:1A2F: 82 07                        dw      DUP
  3866 00:1A31: C4 16 04 00                  dw      DO_LITERAL,4
  3867 00:1A35: 2D 0E                        dw      RSHIFT
  3868 00:1A37: 0D 1A                        dw      DOT_NYBBLE
  3869 00:1A39: 0D 1A                        dw      DOT_NYBBLE
  3870 00:1A3B: CA 18                        dw      SPACE
  3871 00:1A3D: E3 0E                        dw      EXIT
  3872                        
  3873                        ; .WORD ( n -- )
  3874                        ;
  3875                        ; Print the top value on the stack in hex followed by a space.
  3876                        
  3877 00:1A3F: 26 1A 00 05                  HEADER  5,".WORD",NORMAL
  Tue Aug 22 2017 23:21                                                                                                    Page 76


       00:1A43: 2E 57 4F 52 
       00:1A47: 44 
  3878 00:1A48: 20 BE 14     DOT_WORD:       jsr     DO_COLON
  3879 00:1A4B: 82 07                        dw      DUP
  3880 00:1A4D: C4 16 0C 00                  dw      DO_LITERAL,12
  3881 00:1A51: 2D 0E                        dw      RSHIFT
  3882 00:1A53: 0D 1A                        dw      DOT_NYBBLE
  3883 00:1A55: 82 07                        dw      DUP
  3884 00:1A57: C4 16 08 00                  dw      DO_LITERAL,8
  3885 00:1A5B: 2D 0E                        dw      RSHIFT
  3886 00:1A5D: 0D 1A                        dw      DOT_NYBBLE
  3887 00:1A5F: 82 07                        dw      DUP
  3888 00:1A61: C4 16 04 00                  dw      DO_LITERAL,4
  3889 00:1A65: 2D 0E                        dw      RSHIFT
  3890 00:1A67: 0D 1A                        dw      DOT_NYBBLE
  3891 00:1A69: 0D 1A                        dw      DOT_NYBBLE
  3892 00:1A6B: CA 18                        dw      SPACE
  3893 00:1A6D: E3 0E                        dw      EXIT
  3894                        
  3895                        ; .DP
  3896                        
  3897 00:1A6F: 42 1A 00 03                  HEADER  3,".DP",NORMAL
       00:1A73: 2E 44 50 
  3898 00:1A76: 20 BE 14                     jsr     DO_COLON
  3899 00:1A79: DB 1A                        dw      AT_DP
  3900 00:1A7B: 48 1A                        dw      DOT_WORD
  3901 00:1A7D: E3 0E                        dw      EXIT
  3902                        
  3903 00:1A7F: 72 1A 00 03                  HEADER  3,".RP",NORMAL
       00:1A83: 2E 52 50 
  3904 00:1A86: 20 BE 14                     jsr     DO_COLON
  3905 00:1A89: F0 1A                        dw      AT_RP
  3906 00:1A8B: 48 1A                        dw      DOT_WORD
  3907 00:1A8D: E3 0E                        dw      EXIT
  3908                        
  3909                        ; .S ( -- )
  3910                        ;
  3911                        ; Copy and display the values currently on the data stack. The format of the
  3912                        ; display is implementation-dependent.
  3913                        
  3914 00:1A8F: 82 1A 00 02                  HEADER  2,".S",NORMAL
       00:1A93: 2E 53 
  3915 00:1A95: 20 BE 14                     jsr     DO_COLON
  3916 00:1A98: C4 16 7B 00  		dw	DO_LITERAL,'{'
  3917 00:1A9C: 98 18        		dw	EMIT
  3918 00:1A9E: CA 18        		dw	SPACE
  3919 00:1AA0: DB 1A                        dw      AT_DP
  3920 00:1AA2: 6D 09                        dw      ONE_PLUS
  3921 00:1AA4: C4 16 80 01                  dw      DO_LITERAL,DSTACK_END
  3922 00:1AA8: 09 08                        dw      SWAP
  3923 00:1AAA: 0E 15 BC 1A                  dw      QUERY_DO_DO,DOT_S_2
  3924 00:1AAE: 8D 08        DOT_S_1:        dw      I
  3925 00:1AB0: B9 05                        dw      FETCH
  3926 00:1AB2: 48 1A                        dw      DOT_WORD
  3927 00:1AB4: C4 16 02 00                  dw      DO_LITERAL,2
  3928 00:1AB8: 86 14                        dw      DO_PLUS_LOOP
  3929 00:1ABA: AE 1A                        dw      DOT_S_1
  3930 00:1ABC: C4 16 7D 00  DOT_S_2:	dw	DO_LITERAL,'}'
  Tue Aug 22 2017 23:21                                                                                                    Page 77


  3931 00:1AC0: 98 18        		dw	EMIT
  3932 00:1AC2: CA 18        		dw	SPACE
  3933 00:1AC4: E3 0E                        dw      EXIT
  3934                        
  3935                        ; ? ( a-addr -- )
  3936                        ;
  3937                        ; Display the value stored at a-addr.
  3938                        
  3939 00:1AC6: 92 1A 00 01                  HEADER  1,"?",NORMAL
       00:1ACA: 3F 
  3940 00:1ACB: 20 BE 14                     jsr     DO_COLON
  3941 00:1ACE: B9 05                        dw      FETCH
  3942 00:1AD0: 48 1A                        dw      DOT_WORD
  3943 00:1AD2: E3 0E                        dw      EXIT
  3944                        
  3945 00:1AD4: C9 1A 00 03                  HEADER  3,"@DP",NORMAL
       00:1AD8: 40 44 50 
  3946                        AT_DP:
  3947 00:1ADB: 0B                           phd
  3948 00:1ADC: 7B                           tdc
  3949 00:1ADD: 3A                           dec     a
  3950 00:1ADE: 3A                           dec     a
  3951 00:1ADF: 5B                           tcd
  3952 00:1AE0: 68                           pla
  3953 00:1AE1: 85 01                        sta     <1
  3954 00:1AE3: BB C8 C8 7C                  CONTINUE
       00:1AE7: 00 00 
  3955                        
  3956 00:1AE9: D7 1A 00 03                  HEADER  3,"@RP",NORMAL
       00:1AED: 40 52 50 
  3957                        AT_RP:
  3958 00:1AF0: 7B                           tdc
  3959 00:1AF1: 3A                           dec     a
  3960 00:1AF2: 3A                           dec     a
  3961 00:1AF3: 5B                           tcd
  3962 00:1AF4: BA                           tsx
  3963 00:1AF5: 86 01                        stx     <1
  3964 00:1AF7: BB C8 C8 7C                  CONTINUE
       00:1AFB: 00 00 
  3965                        
  3966                        
  3967                        ;-------------------------------------------------------------------------------
  3968                        
  3969                                        include "device.asm"
     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; Device Specific Words for the W65C816SXB
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
  Tue Aug 22 2017 23:21                                                                                                    Page 78


    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ;------------------------------------------------------------------------------
    23                        
    24                        ; (TITLE) - ( -- )
    25                        ;
    26                        
    27                        ;               HEADER  7,"(TITLE)",NORMAL
    28 00:1AFD: 20 BE 14     DO_TITLE:       jsr     DO_COLON
    29 00:1B00: 7F 17                        dw      DO_S_QUOTE
    30 00:1B02: 1C 57 36 35                  db      28,"W65C816SXB ANS-Forth [16.05]"
       00:1B06: 43 38 31 36 
       00:1B0A: 53 58 42 20 
       00:1B0E: 41 4E 53 2D 
       00:1B12: 46 6F 72 74 
       00:1B16: 68 20 5B 31 
       00:1B1A: 36 2E 30 35 
       00:1B1E: 5D 
    31 00:1B1F: E3 0E                        dw      EXIT
    32                        
    33                        ; BYE ( -- )
    34                        ;
    35                        ; Return control to the host operating system, if any.
    36                        
    37 00:1B21: EC 1A 00 03                  HEADER  3,"BYE",NORMAL
       00:1B25: 42 59 45 
    38                        BYE:
    39 00:1B28: 78                           sei
    40 00:1B29: D8                           cld
    41 00:1B2A: 38 FB                        emulate
    42 00:1B2C: 6C FC FF                     jmp     ($fffc)         ; Reset the processor
    43                        
    44                        ; UNUSED ( -- u )
    45                        ;
    46                        ; u is the amount of space remaining in the region addressed by HERE , in
    47                        ; address units.
    48                        
    49 00:1B2F: 24 1B 00 06                  HEADER  6,"UNUSED",NORMAL
       00:1B33: 55 4E 55 53 
       00:1B37: 45 44 
    50 00:1B39: 20 BE 14     UNUSED:         jsr     DO_COLON
    51 00:1B3C: C4 16 00 7E                  dw      DO_LITERAL,$7e00
    52 00:1B40: 24 06                        dw      HERE
    53 00:1B42: 2B 09                        dw      MINUS
    54 00:1B44: E3 0E                        dw      EXIT
    55                        
    56                        ;-------------------------------------------------------------------------------
    57                        
    58 00:1B46: 32 1B 00 08                  HEADER  8,"ACIA$RXD",NORMAL
       00:1B4A: 41 43 49 41 
       00:1B4E: 24 52 58 44 
    59 00:1B52: 20 06 16                     jsr     DO_CONSTANT
    60 00:1B55: 80 7F                        dw      $7f80
  Tue Aug 22 2017 23:21                                                                                                    Page 79


    61                        
    62 00:1B57: 49 1B 00 08                  HEADER  8,"ACIA$TXD",NORMAL
       00:1B5B: 41 43 49 41 
       00:1B5F: 24 54 58 44 
    63 00:1B63: 20 06 16                     jsr     DO_CONSTANT
    64 00:1B66: 80 7F                        dw      $7f80
    65                        
    66 00:1B68: 5A 1B 00 07                  HEADER  7,"ACIA$SR",NORMAL
       00:1B6C: 41 43 49 41 
       00:1B70: 24 53 52 
    67 00:1B73: 20 06 16                     jsr     DO_CONSTANT
    68 00:1B76: 81 7F                        dw      $7f81
    69                        
    70 00:1B78: 6B 1B 00 08                  HEADER  8,"ACIA$CMD",NORMAL
       00:1B7C: 41 43 49 41 
       00:1B80: 24 43 4D 44 
    71 00:1B84: 20 06 16                     jsr     DO_CONSTANT
    72 00:1B87: 82 7F                        dw      $7f82
    73                        
    74 00:1B89: 7B 1B 00 08                  HEADER  8,"ACIA$CTL",NORMAL
       00:1B8D: 41 43 49 41 
       00:1B91: 24 43 54 4C 
    75 00:1B95: 20 06 16                     jsr     DO_CONSTANT
    76 00:1B98: 83 7F                        dw      $7f83
    77                        
    78                        ;-------------------------------------------------------------------------------
    79                        
    80 00:1B9A: 8C 1B 00 07                  HEADER  7,"PIA$PIA",NORMAL
       00:1B9E: 50 49 41 24 
       00:1BA2: 50 49 41 
    81 00:1BA5: 20 06 16                     jsr     DO_CONSTANT
    82 00:1BA8: A0 7F                        dw      $7fa0
    83                        
    84 00:1BAA: 9D 1B 00 08                  HEADER  8,"PIA$DDRA",NORMAL
       00:1BAE: 50 49 41 24 
       00:1BB2: 44 44 52 41 
    85 00:1BB6: 20 06 16                     jsr     DO_CONSTANT
    86 00:1BB9: A0 7F                        dw      $7fa0
    87                        
    88 00:1BBB: AD 1B 00 07                  HEADER  7,"PIA$CRA",NORMAL
       00:1BBF: 50 49 41 24 
       00:1BC3: 43 52 41 
    89 00:1BC6: 20 06 16                     jsr     DO_CONSTANT
    90 00:1BC9: A1 7F                        dw      $7fa1
    91                        
    92 00:1BCB: BE 1B 00 07                  HEADER  7,"PIA$PIB",NORMAL
       00:1BCF: 50 49 41 24 
       00:1BD3: 50 49 42 
    93 00:1BD6: 20 06 16                     jsr     DO_CONSTANT
    94 00:1BD9: A2 7F                        dw      $7fa2
    95                        
    96 00:1BDB: CE 1B 00 08                  HEADER  8,"PIA$DDRB",NORMAL
       00:1BDF: 50 49 41 24 
       00:1BE3: 44 44 52 42 
    97 00:1BE7: 20 06 16                     jsr     DO_CONSTANT
    98 00:1BEA: A2 7F                        dw      $7fa2
    99                        
   100 00:1BEC: DE 1B 00 07                  HEADER  7,"PIA$CRB",NORMAL
  Tue Aug 22 2017 23:21                                                                                                    Page 80


       00:1BF0: 50 49 41 24 
       00:1BF4: 43 52 42 
   101 00:1BF7: 20 06 16                     jsr     DO_CONSTANT
   102 00:1BFA: A3 7F                        dw      $7fa3
   103                        
   104                        ;-------------------------------------------------------------------------------
   105                        
   106 00:1BFC: EF 1B 00 08                  HEADER  8,"VIA1$ORB",NORMAL
       00:1C00: 56 49 41 31 
       00:1C04: 24 4F 52 42 
   107 00:1C08: 20 06 16                     jsr     DO_CONSTANT
   108 00:1C0B: C0 7F                        dw      $7fc0
   109                        
   110 00:1C0D: FF 1B 00 08                  HEADER  8,"VIA1$IRB",NORMAL
       00:1C11: 56 49 41 31 
       00:1C15: 24 49 52 42 
   111 00:1C19: 20 06 16                     jsr     DO_CONSTANT
   112 00:1C1C: C0 7F                        dw      $7fc0
   113                        
   114 00:1C1E: 10 1C 00 08                  HEADER  8,"VIA1$ORA",NORMAL
       00:1C22: 56 49 41 31 
       00:1C26: 24 4F 52 41 
   115 00:1C2A: 20 06 16                     jsr     DO_CONSTANT
   116 00:1C2D: C1 7F                        dw      $7fc1
   117                        
   118 00:1C2F: 21 1C 00 08                  HEADER  8,"VIA1$IRA",NORMAL
       00:1C33: 56 49 41 31 
       00:1C37: 24 49 52 41 
   119 00:1C3B: 20 06 16                     jsr     DO_CONSTANT
   120 00:1C3E: C1 7F                        dw      $7fc1
   121                        
   122 00:1C40: 32 1C 00 09                  HEADER  9,"VIA1$DDRB",NORMAL
       00:1C44: 56 49 41 31 
       00:1C48: 24 44 44 52 
       00:1C4C: 42 
   123 00:1C4D: 20 06 16                     jsr     DO_CONSTANT
   124 00:1C50: C2 7F                        dw      $7fc2
   125                        
   126 00:1C52: 43 1C 00 09                  HEADER  9,"VIA1$DDRA",NORMAL
       00:1C56: 56 49 41 31 
       00:1C5A: 24 44 44 52 
       00:1C5E: 41 
   127 00:1C5F: 20 06 16                     jsr     DO_CONSTANT
   128 00:1C62: C3 7F                        dw      $7fc3
   129                        
   130 00:1C64: 55 1C 00 09                  HEADER  9,"VIA1$T1CL",NORMAL
       00:1C68: 56 49 41 31 
       00:1C6C: 24 54 31 43 
       00:1C70: 4C 
   131 00:1C71: 20 06 16                     jsr     DO_CONSTANT
   132 00:1C74: C4 7F                        dw      $7fc4
   133                        
   134 00:1C76: 67 1C 00 09                  HEADER  9,"VIA1$T1CH",NORMAL
       00:1C7A: 56 49 41 31 
       00:1C7E: 24 54 31 43 
       00:1C82: 48 
   135 00:1C83: 20 06 16                     jsr     DO_CONSTANT
   136 00:1C86: C5 7F                        dw      $7fc5
  Tue Aug 22 2017 23:21                                                                                                    Page 81


   137                        
   138 00:1C88: 79 1C 00 09                  HEADER  9,"VIA1$T1LL",NORMAL
       00:1C8C: 56 49 41 31 
       00:1C90: 24 54 31 4C 
       00:1C94: 4C 
   139 00:1C95: 20 06 16                     jsr     DO_CONSTANT
   140 00:1C98: C6 7F                        dw      $7fc6
   141                        
   142 00:1C9A: 8B 1C 00 09                  HEADER  9,"VIA1$T1LH",NORMAL
       00:1C9E: 56 49 41 31 
       00:1CA2: 24 54 31 4C 
       00:1CA6: 48 
   143 00:1CA7: 20 06 16                     jsr     DO_CONSTANT
   144 00:1CAA: C7 7F                        dw      $7fc7
   145                        
   146 00:1CAC: 9D 1C 00 09                  HEADER  9,"VIA1$T2CL",NORMAL
       00:1CB0: 56 49 41 31 
       00:1CB4: 24 54 32 43 
       00:1CB8: 4C 
   147 00:1CB9: 20 06 16                     jsr     DO_CONSTANT
   148 00:1CBC: C8 7F                        dw      $7fc8
   149                        
   150 00:1CBE: AF 1C 00 09                  HEADER  9,"VIA1$T2CH",NORMAL
       00:1CC2: 56 49 41 31 
       00:1CC6: 24 54 32 43 
       00:1CCA: 48 
   151 00:1CCB: 20 06 16                     jsr     DO_CONSTANT
   152 00:1CCE: C9 7F                        dw      $7fc9
   153                        
   154 00:1CD0: C1 1C 00 07                  HEADER  7,"VIA1$SR",NORMAL
       00:1CD4: 56 49 41 31 
       00:1CD8: 24 53 52 
   155 00:1CDB: 20 06 16                     jsr     DO_CONSTANT
   156 00:1CDE: CA 7F                        dw      $7fca
   157                        
   158 00:1CE0: D3 1C 00 08                  HEADER  8,"VIA1$ACR",NORMAL
       00:1CE4: 56 49 41 31 
       00:1CE8: 24 41 43 52 
   159 00:1CEC: 20 06 16                     jsr     DO_CONSTANT
   160 00:1CEF: CB 7F                        dw      $7fcb
   161                        
   162 00:1CF1: E3 1C 00 08                  HEADER  8,"VIA1$PCR",NORMAL
       00:1CF5: 56 49 41 31 
       00:1CF9: 24 50 43 52 
   163 00:1CFD: 20 06 16                     jsr     DO_CONSTANT
   164 00:1D00: CC 7F                        dw      $7fcc
   165                        
   166 00:1D02: F4 1C 00 08                  HEADER  8,"VIA1$IFR",NORMAL
       00:1D06: 56 49 41 31 
       00:1D0A: 24 49 46 52 
   167 00:1D0E: 20 06 16                     jsr     DO_CONSTANT
   168 00:1D11: CD 7F                        dw      $7fcd
   169                        
   170 00:1D13: 05 1D 00 08                  HEADER  8,"VIA1$IER",NORMAL
       00:1D17: 56 49 41 31 
       00:1D1B: 24 49 45 52 
   171 00:1D1F: 20 06 16                     jsr     DO_CONSTANT
   172 00:1D22: CE 7F                        dw      $7fce
  Tue Aug 22 2017 23:21                                                                                                    Page 82


   173                        
   174 00:1D24: 16 1D 00 09                  HEADER  9,"VIA1$ORAN",NORMAL
       00:1D28: 56 49 41 31 
       00:1D2C: 24 4F 52 41 
       00:1D30: 4E 
   175 00:1D31: 20 06 16                     jsr     DO_CONSTANT
   176 00:1D34: CF 7F                        dw      $7fcf
   177                        
   178 00:1D36: 27 1D 00 09                  HEADER  9,"VIA1$IRAN",NORMAL
       00:1D3A: 56 49 41 31 
       00:1D3E: 24 49 52 41 
       00:1D42: 4E 
   179 00:1D43: 20 06 16                     jsr     DO_CONSTANT
   180 00:1D46: CF 7F                        dw      $7fcf
   181                        
   182                        ;-------------------------------------------------------------------------------
   183                        
   184                        
   185 00:1D48: 39 1D 00 08                  HEADER  8,"VIA2$ORB",NORMAL
       00:1D4C: 56 49 41 32 
       00:1D50: 24 4F 52 42 
   186 00:1D54: 20 06 16                     jsr     DO_CONSTANT
   187 00:1D57: E0 7F                        dw      $7fe0
   188                        
   189 00:1D59: 4B 1D 00 08                  HEADER  8,"VIA2$IRB",NORMAL
       00:1D5D: 56 49 41 32 
       00:1D61: 24 49 52 42 
   190 00:1D65: 20 06 16                     jsr     DO_CONSTANT
   191 00:1D68: E0 7F                        dw      $7fe0
   192                        
   193 00:1D6A: 5C 1D 00 08                  HEADER  8,"VIA2$ORA",NORMAL
       00:1D6E: 56 49 41 32 
       00:1D72: 24 4F 52 41 
   194 00:1D76: 20 06 16                     jsr     DO_CONSTANT
   195 00:1D79: E1 7F                        dw      $7fe1
   196                        
   197 00:1D7B: 6D 1D 00 08                  HEADER  8,"VIA2$IRA",NORMAL
       00:1D7F: 56 49 41 32 
       00:1D83: 24 49 52 41 
   198 00:1D87: 20 06 16                     jsr     DO_CONSTANT
   199 00:1D8A: E1 7F                        dw      $7fe1
   200                        
   201 00:1D8C: 7E 1D 00 09                  HEADER  9,"VIA2$DDRB",NORMAL
       00:1D90: 56 49 41 32 
       00:1D94: 24 44 44 52 
       00:1D98: 42 
   202 00:1D99: 20 06 16                     jsr     DO_CONSTANT
   203 00:1D9C: E2 7F                        dw      $7fe2
   204                        
   205 00:1D9E: 8F 1D 00 09                  HEADER  9,"VIA2$DDRA",NORMAL
       00:1DA2: 56 49 41 32 
       00:1DA6: 24 44 44 52 
       00:1DAA: 41 
   206 00:1DAB: 20 06 16                     jsr     DO_CONSTANT
   207 00:1DAE: E3 7F                        dw      $7fe3
   208                        
   209 00:1DB0: A1 1D 00 09                  HEADER  9,"VIA2$T1CL",NORMAL
       00:1DB4: 56 49 41 32 
  Tue Aug 22 2017 23:21                                                                                                    Page 83


       00:1DB8: 24 54 31 43 
       00:1DBC: 4C 
   210 00:1DBD: 20 06 16                     jsr     DO_CONSTANT
   211 00:1DC0: E4 7F                        dw      $7fe4
   212                        
   213 00:1DC2: B3 1D 00 09                  HEADER  9,"VIA2$T1CH",NORMAL
       00:1DC6: 56 49 41 32 
       00:1DCA: 24 54 31 43 
       00:1DCE: 48 
   214 00:1DCF: 20 06 16                     jsr     DO_CONSTANT
   215 00:1DD2: E5 7F                        dw      $7fe5
   216                        
   217 00:1DD4: C5 1D 00 09                  HEADER  9,"VIA2$T1LL",NORMAL
       00:1DD8: 56 49 41 32 
       00:1DDC: 24 54 31 4C 
       00:1DE0: 4C 
   218 00:1DE1: 20 06 16                     jsr     DO_CONSTANT
   219 00:1DE4: E6 7F                        dw      $7fe6
   220                        
   221 00:1DE6: D7 1D 00 09                  HEADER  9,"VIA2$T1LH",NORMAL
       00:1DEA: 56 49 41 32 
       00:1DEE: 24 54 31 4C 
       00:1DF2: 48 
   222 00:1DF3: 20 06 16                     jsr     DO_CONSTANT
   223 00:1DF6: E7 7F                        dw      $7fe7
   224                        
   225 00:1DF8: E9 1D 00 09                  HEADER  9,"VIA2$T2CL",NORMAL
       00:1DFC: 56 49 41 32 
       00:1E00: 24 54 32 43 
       00:1E04: 4C 
   226 00:1E05: 20 06 16                     jsr     DO_CONSTANT
   227 00:1E08: E8 7F                        dw      $7fe8
   228                        
   229 00:1E0A: FB 1D 00 09                  HEADER  9,"VIA2$T2CH",NORMAL
       00:1E0E: 56 49 41 32 
       00:1E12: 24 54 32 43 
       00:1E16: 48 
   230 00:1E17: 20 06 16                     jsr     DO_CONSTANT
   231 00:1E1A: E9 7F                        dw      $7fe9
   232                        
   233 00:1E1C: 0D 1E 00 07                  HEADER  7,"VIA2$SR",NORMAL
       00:1E20: 56 49 41 32 
       00:1E24: 24 53 52 
   234 00:1E27: 20 06 16                     jsr     DO_CONSTANT
   235 00:1E2A: EA 7F                        dw      $7fea
   236                        
   237 00:1E2C: 1F 1E 00 08                  HEADER  8,"VIA2$ACR",NORMAL
       00:1E30: 56 49 41 32 
       00:1E34: 24 41 43 52 
   238 00:1E38: 20 06 16                     jsr     DO_CONSTANT
   239 00:1E3B: EB 7F                        dw      $7feb
   240                        
   241 00:1E3D: 2F 1E 00 08                  HEADER  8,"VIA2$PCR",NORMAL
       00:1E41: 56 49 41 32 
       00:1E45: 24 50 43 52 
   242 00:1E49: 20 06 16                     jsr     DO_CONSTANT
   243 00:1E4C: EC 7F                        dw      $7fec
   244                        
  Tue Aug 22 2017 23:21                                                                                                    Page 84


   245 00:1E4E: 40 1E 00 08                  HEADER  8,"VIA2$IFR",NORMAL
       00:1E52: 56 49 41 32 
       00:1E56: 24 49 46 52 
   246 00:1E5A: 20 06 16                     jsr     DO_CONSTANT
   247 00:1E5D: ED 7F                        dw      $7fed
   248                        
   249 00:1E5F: 51 1E 00 08                  HEADER  8,"VIA2$IER",NORMAL
       00:1E63: 56 49 41 32 
       00:1E67: 24 49 45 52 
   250 00:1E6B: 20 06 16                     jsr     DO_CONSTANT
   251 00:1E6E: EE 7F                        dw      $7fee
   252                        
   253 00:1E70: 62 1E 00 09                  HEADER  9,"VIA2$ORAN",NORMAL
       00:1E74: 56 49 41 32 
       00:1E78: 24 4F 52 41 
       00:1E7C: 4E 
   254 00:1E7D: 20 06 16                     jsr     DO_CONSTANT
   255 00:1E80: EF 7F                        dw      $7fef
   256                        
   257 00:1E82: 73 1E 00 09                  HEADER  9,"VIA2$IRAN",NORMAL
       00:1E86: 56 49 41 32 
       00:1E8A: 24 49 52 41 
       00:1E8E: 4E 
   258 00:1E8F: 20 06 16                     jsr     DO_CONSTANT
   259 00:1E92: EF 7F                        dw      $7fef
  3970                        
  3971                                        TRAILER
  3972                        NEXT_WORD:
  3973                        
  3974                                        end


      Lines assembled: 6249
      Errors: 0
