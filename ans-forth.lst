  Thu Feb 11 2016 20:45                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The Forth data stack is DP
    27                        ;
    28                        ; The Y register holds the forth instruction pointer and the direct page
    29                        ; register is used to access the word address pointer and user variables.
    30                        ;
    31                        ;==============================================================================
    32                        ;------------------------------------------------------------------------------
    33                        
    34                                        pw      132
    35                                        inclist on
    36                                        maclist off
    37                        
    38                                        chip    65816
    39                                        longi   off
    40                                        longa   off
    41                        
    42                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
     7                        ;
     8                        ; Western Design Center W65C816 device definitions                                          
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
  Thu Feb 11 2016 20:45                                                                                                    Page 2


    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;===============================================================================
    25                        ; Revision History:
    26                        ;
    27                        ; 2015-12-18 AJ Initial version
    28                        ;-------------------------------------------------------------------------------
    29                        ; $Id$
    30                        ;-------------------------------------------------------------------------------
    31                        
    32                        ;==============================================================================
    33                        ; Status Register Bits
    34                        ;------------------------------------------------------------------------------
    35                        
    36             00000080   N_FLAG          equ     1<<7
    37             00000040   V_FLAG          equ     1<<6
    38             00000020   M_FLAG          equ     1<<5
    39             00000010   X_FLAG          equ     1<<4
    40             00000010   B_FLAG          equ     1<<4
    41             00000008   D_FLAG          equ     1<<3
    42             00000004   I_FLAG          equ     1<<2
    43             00000002   Z_FLAG          equ     1<<1
    44             00000001   C_FLAG          equ     1<<0
    45                        
    46                        ;==============================================================================
    47                        ; Macros
    48                        ;------------------------------------------------------------------------------
    49                        
    50                        ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
    51                        ; is fixed at $0100-$01ff. 
    52                        
    53                        emulate         macro
    54                                        sec
    55                                        xce
    56                                        endm
    57                        
    58                        ; Puts the processor in native mode. The size of the memory and index register
    59                        ; operations is not controlled by the M & X bits in the status register.
    60                        
    61                        native          macro
    62                                        clc
    63                                        xce
    64                                        endm
    65                        
    66                        ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
    67                         
    68                        long_a          macro
  Thu Feb 11 2016 20:45                                                                                                    Page 3


    69                                        rep     #M_FLAG
    70                                        longa   on
    71                                        endm
    72                        
    73                        ; Resets the X bit making the index registers 16-bits wide
    74                        
    75                        long_i          macro
    76                                        rep     #X_FLAG
    77                                        longi   on
    78                                        endm
    79                        
    80                        ; Resets the M and X bits making the accumulator, memory accesses and index
    81                        ; registers 16-bits wide.
    82                                        
    83                        long_ai         macro
    84                                        rep     #M_FLAG|X_FLAG
    85                                        longa   on
    86                                        longi   on
    87                                        endm
    88                        
    89                        ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
    90                        
    91                        short_a         macro
    92                                        sep     #M_FLAG
    93                                        longa   off
    94                                        endm
    95                        
    96                        ; Sets the X bit making the index registers 8-bits wide.
    97                        
    98                        short_i         macro
    99                                        sep     #X_FLAG
   100                                        longi   off
   101                                        endm
   102                                        
   103                        ; Sets the M & X bits making the accumulator, memory accesses and index
   104                        ; registers 8-bits wide.
   105                        
   106                        short_ai        macro
   107                                        sep     #M_FLAG|X_FLAG
   108                                        longa   off
   109                                        longi   off
   110                                        endm
    43                        
    44                        ;==============================================================================
    45                        ; Macros
    46                        ;------------------------------------------------------------------------------
    47                        
    48             00000000   COUNT           set     0                       ; Word counter
    49             00000000   WORD0           equ     0                       ; Null address for first word
    50                        
    51                        HEADER          macro   TYPE
    52                        WORD@<COUNT+1>:
    53                                        dw      WORD@<COUNT>
    54                                        db      TYPE
    55                        COUNT           set     COUNT+1
    56                                        endm
    57                        
    58             00000000   NORMAL          equ     $00
  Thu Feb 11 2016 20:45                                                                                                    Page 4


    59             00000080   IMMEDIATE       equ     $80
    60                        
    61                        TRAILER         macro
    62                        LAST_WORD       equ     WORD@<COUNT>
    63                                        endm
    64                        
    65                        ;==============================================================================
    66                        ; Definitions
    67                        ;------------------------------------------------------------------------------
    68                        
    69             00000014   USER_SIZE       equ     20
    70             00000080   DSTACK_SIZE     equ     128
    71             00000080   RSTACK_SIZE     equ     128
    72                        
    73             00000000   TO_IN_OFFSET    equ     0
    74             00000002   BASE_OFFSET     equ     2
    75             00000004   BLK_OFFSET      equ     4
    76             00000006   DP_OFFSET       equ     6
    77             00000008   LATEST_OFFSET   equ     8
    78             0000000A   SCR_OFFSET      equ     10
    79             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
    80             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
    81             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
    82             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
    83                        
    84             00000080   TIB_SIZE        equ     128
    85                        
    86                        ;==============================================================================
    87                        ; Data Areas
    88                        ;------------------------------------------------------------------------------
    89                        
    90                                        page0
    91                                        org     $00
    92                        
    93 00:0000:              USER_AREA       ds      USER_SIZE               ; User Variables
    94                        
    95                        
    96             00000100   DSTACK_START	equ	$0100
    97             00000180   DSTACK_END	equ	DSTACK_START+DSTACK_SIZE
    98                        
    99             00000180   RSTACK_START	equ	$0180
   100             00000200   RSTACK_END	equ	RSTACK_START+RSTACK_SIZE
   101                        
   102                        
   103                                        data
   104                                        org     $0200
   105                        
   106 00:0200:              TIB_AREA        ds      TIB_SIZE                ; Terminal Input Buffer
   107                        
   108                        ;==============================================================================
   109                        ; Forth Entry Point
   110                        ;------------------------------------------------------------------------------
   111                        
   112                        FORTH           section OFFSET $0400
   113                        
   114                                        public  Start
   115                        Start:
   116 00:0400: 18 FB                        native                          ; Go to native mode
  Thu Feb 11 2016 20:45                                                                                                    Page 5


   117 00:0402: C2 30                        long_ai                         ; And all 16-bit registers
   118 00:0404: A9 FF 01                     lda     #RSTACK_END-1           ; Initialise return stack
   119 00:0407: 1B                           tcs
   120 00:0408: A9 7F 01                     lda     #DSTACK_END-1           ; .. and data stack
   121 00:040B: 5B                           tcd
   122                        
   123 00:040C: A0 12 04                     ldy     #COLD                   ; Then perform COLD start
   124 00:040F: 4C 3C 0D                     jmp     NEXT
   125                        
   126                        COLD:
   127 00:0412: 4C 05                        dw      DECIMAL
   128 00:0414: 01 05 81 04                  dw      ZERO,BLK,STORE
       00:0418: 72 05 
   129 00:041A: 25 05 EB 04                  dw      FALSE,STATE,STORE
       00:041E: 72 05 
   130 00:0420: BB 0E BB 0E                  dw      CR,CR,DO_S_QUOTE
       00:0424: 99 0E 
   131 00:0426: 23 48 61 6E                  db      35,"HandCoded W65C816 ANS-Forth [16.02]"
       00:042A: 64 43 6F 64 
       00:042E: 65 64 20 57 
       00:0432: 36 35 43 38 
       00:0436: 31 36 20 41 
       00:043A: 4E 53 2D 46 
       00:043E: 6F 72 74 68 
       00:0442: 20 5B 31 36 
       00:0446: 2E 30 32 5D 
   132 00:044A: 32 0F BB 0E                  dw      TYPE,CR,CR
       00:044E: BB 0E 
   133 00:0450: FF 09                        dw      ABORT
   134                        
   135                        ;==============================================================================
   136                        ; System/User Variables
   137                        ;------------------------------------------------------------------------------
   138                        
   139                        ; #TIB ( -- a-addr )
   140                        ;
   141                        ; a-addr is the address of a cell containing the number of characters in the
   142                        ; terminal input buffer.
   143                        
   144 00:0452: 00 00 00                     HEADER  NORMAL
   145 00:0455: 04 23 54 49                  db      4,"#TIB"
       00:0459: 42 
   146 00:045A: 20 83 0D     HASH_TIB:       jsr     DO_CONSTANT
   147 00:045D: 5F 04                        dw      $+2
   148 00:045F: 7E 00                        dw      TIB_SIZE-2
   149                        
   150                        ; >IN ( -- a-addr )
   151                        ;
   152                        ; a-addr is the address of a cell containing the offset in characters from the
   153                        ; start of the input buffer to the start of the parse area.
   154                        
   155 00:0461: 52 04 00                     HEADER  NORMAL
   156 00:0464: 03 3E 49 4E                  db      3,">IN"
   157 00:0468: 20 58 0E     TO_IN:          jsr     DO_USER
   158 00:046B: 00 00                        dw      TO_IN_OFFSET
   159                        
   160                        ; BASE ( -- a-addr )
   161                        ;
  Thu Feb 11 2016 20:45                                                                                                    Page 6


   162                        ; a-addr is the address of a cell containing the current number-conversion
   163                        ; radix {{2...36}}.
   164                        
   165 00:046D: 61 04 00                     HEADER  NORMAL
   166 00:0470: 04 42 41 53                  db      4,"BASE"
       00:0474: 45 
   167 00:0475: 20 58 0E     BASE:           jsr     DO_USER
   168 00:0478: 02 00                        dw      BASE_OFFSET
   169                        
   170                        ; BLK ( -- a-addr )
   171                        ;
   172                        ; a-addr is the address of a cell containing zero or the number of the mass-
   173                        ; storage block being interpreted. If BLK contains zero, the input source is
   174                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   175                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   176                        
   177 00:047A: 6D 04 00                     HEADER  NORMAL
   178 00:047D: 03 42 4C 4B                  db      3,"BLK"
   179 00:0481: 20 58 0E     BLK:            jsr     DO_USER
   180 00:0484: 04 00                        dw      BLK_OFFSET
   181                        
   182                        ; (BUFFER)
   183                        
   184 00:0486: 7A 04 00                     HEADER  NORMAL
   185 00:0489: 08 28 42 55                  db      8,"(BUFFER)"
       00:048D: 46 46 45 52 
       00:0491: 29 
   186 00:0492: 20 58 0E     BUFFER:         jsr     DO_USER
   187 00:0495: 10 00                        dw      BUFFER_OFFSET
   188                        
   189                        ; DP ( -- a-addr )
   190                        
   191 00:0497: 86 04 00                     HEADER  NORMAL
   192 00:049A: 02 44 50                     db      2,"DP"
   193 00:049D: 20 58 0E     DP:             jsr     DO_USER
   194 00:04A0: 06 00                        dw      DP_OFFSET
   195                        
   196                        ; LATEST ( -- a-addr )
   197                        
   198 00:04A2: 97 04 00                     HEADER  NORMAL
   199 00:04A5: 06 4C 41 54                  db      6,"LATEST"
       00:04A9: 45 53 54 
   200 00:04AC: 20 58 0E     LATEST:         jsr     DO_USER
   201 00:04AF: 08 00                        dw      LATEST_OFFSET
   202                        
   203                        ; (LENGTH)
   204                        
   205 00:04B1: A2 04 00                     HEADER  NORMAL
   206 00:04B4: 08 28 4C 45                  db      8,"(LENGTH)"
       00:04B8: 4E 47 54 48 
       00:04BC: 29 
   207 00:04BD: 20 58 0E     LENGTH:         jsr     DO_USER
   208 00:04C0: 12 00                        dw      LENGTH_OFFSET
   209                        
   210                        ; SCR ( -- a-addr )
   211                        ;
   212                        ; a-addr is the address of a cell containing the block number of the block most
   213                        ; recently LISTed.
  Thu Feb 11 2016 20:45                                                                                                    Page 7


   214                        
   215 00:04C2: B1 04 00                     HEADER  NORMAL
   216 00:04C5: 03 53 43 52                  db      3,"SCR"
   217 00:04C9: 20 58 0E     SCR:            jsr     DO_USER
   218 00:04CC: 0A 00                        dw      SCR_OFFSET
   219                        
   220                        ; (SOURCE-ID)
   221                        
   222 00:04CE: C2 04 00                     HEADER  NORMAL
   223 00:04D1: 0B 28 53 4F                  db      11,"(SOURCE-ID)"
       00:04D5: 55 52 43 45 
       00:04D9: 2D 49 44 29 
   224 00:04DD: 20 58 0E     SOURCEID:       jsr     DO_USER
   225 00:04E0: 0C 00                        dw      SOURCEID_OFFSET
   226                        
   227                        ; STATE ( -- a-addr )
   228                        ;
   229                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   230                        ; is true when in compilation state, false otherwise. The true value in STATE
   231                        ; is non-zero, but is otherwise implementation-defined.
   232                        
   233 00:04E2: CE 04 00                     HEADER  NORMAL
   234 00:04E5: 05 53 54 41                  db      5,"STATE"
       00:04E9: 54 45 
   235 00:04EB: 20 58 0E     STATE:          jsr     DO_USER
   236 00:04EE: 0E 00                        dw      STATE_OFFSET
   237                        
   238                        ; TIB ( -- c-addr )
   239                        ;
   240                        ; c-addr is the address of the terminal input buffer.
   241                        
   242 00:04F0: E2 04 00                     HEADER  NORMAL
   243 00:04F3: 03 54 49 42                  db      3,"TIB"
   244 00:04F7: 20 83 0D     TIB:            jsr     DO_CONSTANT
   245 00:04FA: 00 02                        dw      TIB_AREA
   246                        
   247                        ;==============================================================================
   248                        ; Constants
   249                        ;------------------------------------------------------------------------------
   250                        
   251                        ; 0 ( -- 0 )
   252                        ;
   253                        ; Push the constant value zero on the stack
   254                        
   255 00:04FC: F0 04 00                     HEADER  NORMAL
   256 00:04FF: 01 30                        db      1,"0"
   257                        ZERO:
   258 00:0501: 7B                           tdc
   259 00:0502: 3A                           dec     a                       ; Make space on the stack
   260 00:0503: 3A                           dec     a
   261 00:0504: 5B                           tcd
   262 00:0505: 64 01                        stz     <1                      ; And create a zero value
   263 00:0507: 4C 3C 0D                     jmp     NEXT                    ; Done
   264                        
   265                        ; BL ( -- char )
   266                        ;
   267                        ; char is the character value for a space.
   268                        
  Thu Feb 11 2016 20:45                                                                                                    Page 8


   269 00:050A: FC 04 00                     HEADER  NORMAL
   270 00:050D: 02 42 4C                     db      2,"BL"
   271                        BL:
   272 00:0510: 7B                           tdc
   273 00:0511: 3A                           dec     a                       ; Make space on the stack
   274 00:0512: 3A                           dec     a
   275 00:0513: 5B                           tcd
   276 00:0514: A9 20 00                     lda     #' '                    ; And save a space value
   277 00:0517: 85 01                        sta     <1
   278 00:0519: 4C 3C 0D                     jmp     NEXT                    ; Done
   279                        
   280                        ; FALSE ( -- false )
   281                        ;
   282                        ; Return a false flag.
   283                        
   284 00:051C: 0A 05 00                     HEADER  NORMAL
   285 00:051F: 05 46 41 4C                  db      5,"FALSE"
       00:0523: 53 45 
   286                        FALSE:
   287 00:0525: 7B                           tdc
   288 00:0526: 3A                           dec     a                       ; Make space on the stack
   289 00:0527: 3A                           dec     a
   290 00:0528: 5B                           tcd
   291 00:0529: 64 01                        stz     <1                      ; And create a false value
   292 00:052B: 4C 3C 0D                     jmp     NEXT                    ; Done
   293                        
   294                        ; TRUE ( -- true )
   295                        ;
   296                        ; Return a true flag, a single-cell value with all bits set.
   297                        
   298 00:052E: 1C 05 00                     HEADER  NORMAL
   299 00:0531: 04 54 52 55                  db      4,"TRUE"
       00:0535: 45 
   300                        TRUE:
   301 00:0536: 7B                           tdc
   302 00:0537: 3A                           dec     a                       ; Make space on the stack
   303 00:0538: 3A                           dec     a
   304 00:0539: 5B                           tcd
   305 00:053A: 64 01                        stz     <1                      ; And create a true value
   306 00:053C: C6 01                        dec     <1
   307 00:053E: 4C 3C 0D                     jmp     NEXT                    ; Done
   308                        
   309                        ;==============================================================================
   310                        ; Radix
   311                        ;------------------------------------------------------------------------------
   312                        
   313                        ; DECIMAL ( -- )
   314                        ;
   315                        ; Set the numeric conversion radix to ten (decimal).
   316                        
   317 00:0541: 2E 05 00                     HEADER  NORMAL
   318 00:0544: 07 44 45 43                  db      7,"DECIMAL"
       00:0548: 49 4D 41 4C 
   319 00:054C: 20 38 0D     DECIMAL:        jsr     DO_COLON
   320 00:054F: 05 0E 0A 00                  dw      DO_LITERAL,10,BASE,STORE
       00:0553: 75 04 72 05 
   321 00:0557: 60 0A                        dw      EXIT
   322                        
  Thu Feb 11 2016 20:45                                                                                                    Page 9


   323                        ; HEX ( -- )
   324                        ;
   325                        ; Set contents of BASE to sixteen.
   326                        
   327 00:0559: 41 05 00                     HEADER  NORMAL
   328 00:055C: 03 48 45 58                  db      3,"HEX"
   329 00:0560: 20 38 0D     HEX:            jsr     DO_COLON
   330 00:0563: 05 0E 10 00                  dw      DO_LITERAL,16,BASE,STORE
       00:0567: 75 04 72 05 
   331 00:056B: 60 0A                        dw      EXIT
   332                        
   333                        ;==============================================================================
   334                        ; Memory Operations
   335                        ;------------------------------------------------------------------------------
   336                        
   337                        ; ! ( x a-addr -- )
   338                        ;
   339                        ; Store x at a-addr.
   340                        
   341 00:056D: 59 05 00                     HEADER  NORMAL
   342 00:0570: 01 21                        db      1,"!"
   343                        STORE:
   344 00:0572: A5 03                        lda     <3                      ; Fetch data value
   345 00:0574: 92 01                        sta     (1)                     ; .. and store
   346 00:0576: 7B                           tdc                             ; Clean up data stack
   347 00:0577: 1A                           inc     a
   348 00:0578: 1A                           inc     a
   349 00:0579: 1A                           inc     a
   350 00:057A: 1A                           inc     a
   351 00:057B: 5B                           tcd
   352 00:057C: 4C 3C 0D                     jmp     NEXT                    ; Done
   353                        
   354                        ; +! ( n|u a-addr -- )
   355                        ;
   356                        ; Add n|u to the single-cell number at a-addr.
   357                        
   358 00:057F: 6D 05 00                     HEADER  NORMAL
   359 00:0582: 02 2B 21                     db      2,"+!"
   360                        PLUS_STORE:
   361 00:0585: 18                           clc
   362 00:0586: A5 03                        lda     <3                      ; Fetch data value
   363 00:0588: 72 01                        adc     (1)
   364 00:058A: 92 01                        sta     (1)
   365 00:058C: 7B                           tdc                             ; Clean up data stack
   366 00:058D: 1A                           inc     a
   367 00:058E: 1A                           inc     a
   368 00:058F: 1A                           inc     a
   369 00:0590: 1A                           inc     a
   370 00:0591: 5B                           tcd
   371 00:0592: 4C 3C 0D                     jmp     NEXT                    ; Done
   372                        
   373                        ; , ( x -- )
   374                        ;
   375                        ; Reserve one cell of data space and store x in the cell. If the data-space
   376                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   377                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   378                        ; is not aligned prior to execution of ,.
   379                        ;
  Thu Feb 11 2016 20:45                                                                                                    Page 10


   380                        ;   HERE ! 1 CELLS ALLOT
   381                        
   382 00:0595: 7F 05 00                     HEADER  NORMAL
   383 00:0598: 01 2C                        db      1,","
   384 00:059A: 20 38 0D     COMMA:          jsr     DO_COLON
   385 00:059D: 3C 06 72 05                  dw      HERE,STORE
   386 00:05A1: 05 0E 01 00                  dw      DO_LITERAL,1,CELLS,ALLOT
       00:05A5: 78 06 EA 05 
   387 00:05A9: 60 0A                        dw      EXIT
   388                        
   389                        ; 2! ( x1 x2 a-addr -- )
   390                        ;
   391                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   392                        ; consecutive cell. It is equivalent to the sequence SWAP OVER ! CELL+ !.
   393                        
   394 00:05AB: 95 05 00                     HEADER  NORMAL
   395 00:05AE: 02 32 21                     db      2,"2!"
   396 00:05B1: 20 38 0D     TWO_STORE:      jsr     DO_COLON
   397 00:05B4: 54 07                        dw      SWAP
   398 00:05B6: 41 07                        dw      OVER
   399 00:05B8: 72 05                        dw      STORE
   400 00:05BA: 68 06                        dw      CELL_PLUS
   401 00:05BC: 72 05                        dw      STORE
   402 00:05BE: 60 0A                        dw      EXIT
   403                        
   404                        ; 2@ ( a-addr -- x1 x2 )
   405                        ;
   406                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   407                        ; the next consecutive cell. It is equivalent to the sequence DUP CELL+ @ SWAP
   408                        ; @.
   409                        
   410 00:05C0: AB 05 00                     HEADER  NORMAL
   411 00:05C3: 02 32 40                     db      2,"2@"
   412 00:05C6: 20 38 0D     TWO_FETCH:      jsr     DO_COLON
   413 00:05C9: 21 07                        dw      DUP
   414 00:05CB: 68 06                        dw      CELL_PLUS
   415 00:05CD: DA 05                        dw      FETCH
   416 00:05CF: 54 07                        dw      SWAP
   417 00:05D1: DA 05                        dw      FETCH
   418 00:05D3: 60 0A                        dw      EXIT
   419                        
   420                        ; @ ( a-addr -- x )
   421                        ;
   422                        ; x is the value stored at a-addr.
   423                        
   424 00:05D5: C0 05 00                     HEADER  NORMAL
   425 00:05D8: 01 40                        db      1,"@"
   426                        FETCH:
   427 00:05DA: B2 01                        lda     (1)                     ; Fetch from memory
   428 00:05DC: 85 01                        sta     <1                      ; .. and replace top value
   429 00:05DE: 4C 3C 0D                     jmp     NEXT                    ; Done
   430                        
   431                        ; ALLOT ( n -- )
   432                        ;
   433                        ; If n is greater than zero, reserve n address units of data space. If n is
   434                        ; less than zero, release |n| address units of data space. If n is zero, leave
   435                        ; the data-space pointer unchanged.
   436                        ;
  Thu Feb 11 2016 20:45                                                                                                    Page 11


   437                        ; In this implementation its is defined as:
   438                        ;
   439                        ;   DP +!
   440                        
   441 00:05E1: D5 05 00                     HEADER  NORMAL
   442 00:05E4: 05 41 4C 4C                  db      5,"ALLOT"
       00:05E8: 4F 54 
   443 00:05EA: 20 38 0D     ALLOT:          jsr     DO_COLON
   444 00:05ED: 9D 04 85 05                  dw      DP,PLUS_STORE
   445 00:05F1: 60 0A                        dw      EXIT
   446                        
   447                        ; C! ( char c-addr -- )
   448                        ;
   449                        ; Store char at c-addr. When character size is smaller than cell size, only the
   450                        ; number of low-order bits corresponding to character size are transferred.
   451                        
   452 00:05F3: E1 05 00                     HEADER  NORMAL
   453 00:05F6: 02 43 21                     db      2,"C!"
   454                        C_STORE:
   455 00:05F9: A5 03                        lda     <3                      ; Fetch the data value
   456 00:05FB: E2 20                        short_a
   457 00:05FD: 92 01                        sta     (1)                     ; And store it
   458 00:05FF: C2 20                        long_a
   459 00:0601: 7B                           tdc                             ; Clean up the stack
   460 00:0602: 1A                           inc     a
   461 00:0603: 1A                           inc     a
   462 00:0604: 1A                           inc     a
   463 00:0605: 1A                           inc     a
   464 00:0606: 5B                           tcd
   465 00:0607: 4C 3C 0D                     jmp     NEXT                    ; Done
   466                        
   467                        ; C, ( char -- )
   468                        ;
   469                        ; Reserve space for one character in the data space and store char in the
   470                        ; space. If the data-space pointer is character aligned when C, begins
   471                        ; execution, it will remain character aligned when C, finishes execution.
   472                        ; An ambiguous condition exists if the data-space pointer is not character-
   473                        ; aligned prior to execution of C,
   474                        ;
   475                        ;   HERE C! 1 CHARS ALLOT
   476                        
   477 00:060A: F3 05 00                     HEADER  NORMAL
   478 00:060D: 02 43 2C                     db      2,"C,"
   479 00:0610: 20 38 0D     C_COMMA:        jsr     DO_COLON
   480 00:0613: 3C 06 F9 05                  dw      HERE,C_STORE
   481 00:0617: 05 0E 01 00                  dw      DO_LITERAL,1,CHARS,ALLOT
       00:061B: 94 06 EA 05 
   482 00:061F: 60 0A                        dw      EXIT
   483                        
   484                        ; C@ ( c-addr -- char )
   485                        ;
   486                        ; Fetch the character stored at c-addr. When the cell size is greater than
   487                        ; character size, the unused high-order bits are all zeroes.
   488                        
   489 00:0621: 0A 06 00                     HEADER  NORMAL
   490 00:0624: 02 43 40                     db      2,"C@"
   491                        C_FETCH:
   492 00:0627: E2 20                        short_a
  Thu Feb 11 2016 20:45                                                                                                    Page 12


   493 00:0629: B2 01                        lda     (1)                     ; Fetch the data byte
   494 00:062B: 85 01                        sta     <1                      ; .. and replace stack value
   495 00:062D: 64 02                        stz     <2
   496 00:062F: C2 20                        long_a
   497 00:0631: 4C 3C 0D                     jmp     NEXT                    ; Done
   498                        
   499                        ; HERE
   500                        
   501 00:0634: 21 06 00                     HEADER  NORMAL
   502 00:0637: 04 48 45 52                  db      4,"HERE"
       00:063B: 45 
   503 00:063C: 20 38 0D     HERE:           jsr     DO_COLON
   504 00:063F: 9D 04 DA 05                  dw      DP,FETCH
   505 00:0643: 60 0A                        dw      EXIT
   506                        
   507                        ;==============================================================================
   508                        ; Alignment
   509                        ;------------------------------------------------------------------------------
   510                        
   511                        ; ALIGN ( -- )
   512                        ;
   513                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   514                        
   515 00:0645: 34 06 00                     HEADER  NORMAL
   516 00:0648: 05 41 4C 49                  db      5,"ALIGN"
       00:064C: 47 4E 
   517                        ALIGN:
   518 00:064E: 4C 3C 0D                     jmp     NEXT                    ; Done
   519                        
   520                        ; ALIGNED ( addr -- a-addr )
   521                        ;
   522                        ; a-addr is the first aligned address greater than or equal to addr.
   523                        
   524 00:0651: 45 06 00                     HEADER  NORMAL
   525 00:0654: 07 41 4C 49                  db      7,"ALIGNED"
       00:0658: 47 4E 45 44 
   526                        ALIGNED:
   527 00:065C: 4C 3C 0D                     jmp     NEXT                    ; Done
   528                        
   529                        ; CELL+ ( a-addr1 -- a-addr2 )
   530                        ;
   531                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   532                        
   533 00:065F: 51 06 00                     HEADER  NORMAL
   534 00:0662: 05 43 45 4C                  db      5,"CELL+"
       00:0666: 4C 2B 
   535                        CELL_PLUS:
   536 00:0668: E6 01                        inc     <1                      ; Bump the address by two
   537 00:066A: E6 01                        inc     <1
   538 00:066C: 4C 3C 0D                     jmp     NEXT
   539                        
   540                        ; CELLS ( n1 -- n2 )
   541                        ;
   542                        ; n2 is the size in address units of n1 cells.
   543                        
   544 00:066F: 5F 06 00                     HEADER  NORMAL
   545 00:0672: 05 43 45 4C                  db      5,"CELLS"
       00:0676: 4C 53 
  Thu Feb 11 2016 20:45                                                                                                    Page 13


   546                        CELLS:
   547 00:0678: 06 01                        asl     <1                      ; Two bytes per cell
   548 00:067A: 4C 3C 0D                     jmp     NEXT
   549                        
   550                        ; CHAR+ ( c-addr1 -- c-addr2 )
   551                        ;
   552                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
   553                        
   554 00:067D: 6F 06 00                     HEADER  NORMAL
   555 00:0680: 05 43 48 41                  db      5,"CHAR+"
       00:0684: 52 2B 
   556                        CHAR_PLUS:
   557 00:0686: E6 01                        inc     <1                      ; Bump the address by one
   558 00:0688: 4C 3C 0D                     jmp     NEXT
   559                        
   560                        ; CHARS ( n1 -- n2 )
   561                        ;
   562                        ; n2 is the size in address units of n1 characters.
   563                        
   564 00:068B: 7D 06 00                     HEADER  NORMAL
   565 00:068E: 05 43 48 41                  db      5,"CHARS"
       00:0692: 52 53 
   566                        CHARS:
   567 00:0694: 4C 3C 0D                     jmp     NEXT
   568                        
   569                        ;==============================================================================
   570                        ; Stack Operations
   571                        ;------------------------------------------------------------------------------
   572                        
   573                        ; 2DROP ( x1 x2 -- )
   574                        ;
   575                        ; Drop cell pair x1 x2 from the stack.
   576                        
   577 00:0697: 8B 06 00                     HEADER  NORMAL
   578 00:069A: 05 32 44 52                  db      5,"2DROP"
       00:069E: 4F 50 
   579                        TWO_DROP:
   580 00:06A0: 7B                           tdc                             ; Removed two words from stack
   581 00:06A1: 1A                           inc     a
   582 00:06A2: 1A                           inc     a
   583 00:06A3: 1A                           inc     a
   584 00:06A4: 1A                           inc     a
   585 00:06A5: 5B                           tcd
   586 00:06A6: 4C 3C 0D                     jmp     NEXT                    ; Done
   587                        
   588                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   589                        ;
   590                        ; Duplicate cell pair x1 x2.
   591                        
   592 00:06A9: 97 06 00                     HEADER  NORMAL
   593 00:06AC: 04 32 44 55                  db      4,"2DUP"
       00:06B0: 50 
   594                        TWO_DUP:
   595 00:06B1: 7B                           tdc                             ; Make space for new value
   596 00:06B2: 3A                           dec     a
   597 00:06B3: 3A                           dec     a
   598 00:06B4: 3A                           dec     a
   599 00:06B5: 3A                           dec     a
  Thu Feb 11 2016 20:45                                                                                                    Page 14


   600 00:06B6: 5B                           tcd
   601 00:06B7: A5 05                        lda     <5                      ; Copy top two values
   602 00:06B9: 85 01                        sta     <1
   603 00:06BB: A5 07                        lda     <7
   604 00:06BD: 85 03                        sta     <3
   605 00:06BF: 4C 3C 0D                     jmp     NEXT                    ; Done
   606                        
   607                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   608                        ;
   609                        ; Copy cell pair x1 x2 to the top of the stack.
   610                        
   611 00:06C2: A9 06 00                     HEADER  NORMAL
   612 00:06C5: 05 32 4F 56                  db      5,"2OVER"
       00:06C9: 45 52 
   613                        TWO_OVER:
   614 00:06CB: 7B                           tdc                             ; Make space for new value
   615 00:06CC: 3A                           dec     a
   616 00:06CD: 3A                           dec     a
   617 00:06CE: 3A                           dec     a
   618 00:06CF: 3A                           dec     a
   619 00:06D0: 5B                           tcd
   620 00:06D1: A5 09                        lda     <9                      ; Ciopy top two values
   621 00:06D3: 85 01                        sta     <1
   622 00:06D5: A5 0B                        lda     <11
   623 00:06D7: 85 03                        sta     <3
   624 00:06D9: 4C 3C 0D                     jmp     NEXT                    ; Done
   625                        
   626                        ; 2ROT
   627                        
   628                        ; TODO
   629                        
   630                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   631                        ;
   632                        ; Exchange the top two cell pairs.
   633                        
   634 00:06DC: C2 06 00                     HEADER  NORMAL
   635 00:06DF: 05 32 53 57                  db      5,"2SWAP"
       00:06E3: 41 50 
   636                        TWO_SWAP:
   637 00:06E5: A5 03                        lda     <3                      ; Save x3
   638 00:06E7: 48                           pha
   639 00:06E8: A5 01                        lda     <1                      ; Save x4
   640 00:06EA: 48                           pha
   641 00:06EB: A5 07                        lda     <7                      ; Move x1
   642 00:06ED: 85 03                        sta     <3
   643 00:06EF: A5 05                        lda     <5                      ; Move x2
   644 00:06F1: 85 01                        sta     <1
   645 00:06F3: 68                           pla                             ; Move x4
   646 00:06F4: 85 05                        sta     <5
   647 00:06F6: 68                           pla                             ; Move x3
   648 00:06F7: 85 07                        sta     <7
   649 00:06F9: 4C 3C 0D                     jmp     NEXT                    ; Done
   650                        
   651                        ; ?DUP ( x -- 0 | x x )
   652                        ;
   653                        ; Duplicate x if it is non-zero.
   654                        
   655 00:06FC: DC 06 00                     HEADER  NORMAL
  Thu Feb 11 2016 20:45                                                                                                    Page 15


   656 00:06FF: 04 3F 44 55                  db      4,"?DUP"
       00:0703: 50 
   657                        QUERY_DUP:
   658 00:0704: A5 01                        lda     <1                      ; Fetch top value
   659 00:0706: D0 19                        bne     DUP                     ; Non-zero value?
   660 00:0708: 4C 3C 0D                     jmp     NEXT                    ; Done
   661                        
   662                        ; DROP ( x -- )
   663                        ;
   664                        ; Remove x from the stack.
   665                        
   666 00:070B: FC 06 00                     HEADER  NORMAL
   667 00:070E: 04 44 52 4F                  db      4,"DROP"
       00:0712: 50 
   668                        DROP:
   669 00:0713: 7B                           tdc                             ; Drop the top value
   670 00:0714: 1A                           inc     a
   671 00:0715: 1A                           inc     a
   672 00:0716: 5B                           tcd
   673 00:0717: 4C 3C 0D                     jmp     NEXT                    ; Done
   674                        
   675                        ; DUP ( x -- x x )
   676                        ;
   677                        ; Duplicate x.
   678                        
   679 00:071A: 0B 07 00                     HEADER  NORMAL
   680 00:071D: 03 44 55 50                  db      3,"DUP"
   681                        DUP:
   682 00:0721: 7B                           tdc
   683 00:0722: 3A                           dec     a
   684 00:0723: 3A                           dec     a
   685 00:0724: 5B                           tcd
   686 00:0725: A5 03                        lda     <3                      ; Fetch top value
   687 00:0727: 85 01                        sta     <1                      ; And make a copy
   688 00:0729: 4C 3C 0D                     jmp     NEXT                    ; Done
   689                        
   690                        ; NIP ( x1 x2 -- x2 )
   691                        ;
   692                        ; Drop the first item below the top of stack.
   693                        
   694 00:072C: 1A 07 00                     HEADER  NORMAL
   695 00:072F: 03 4E 49 50                  db      3,"NIP"
   696                        NIP:
   697 00:0733: A5 01                        lda     <1                      ; Copy x2 over x1
   698 00:0735: 85 03                        sta     <3
   699 00:0737: 80 DA                        bra     DROP
   700                        
   701                        ; OVER ( x1 x2 -- x1 x2 x1 )
   702                        ;
   703                        ; Place a copy of x1 on top of the stack.
   704                        
   705 00:0739: 2C 07 00                     HEADER  NORMAL
   706 00:073C: 04 4F 56 45                  db      4,"OVER"
       00:0740: 52 
   707                        OVER:
   708 00:0741: 7B                           tdc
   709 00:0742: 3A                           dec     a
   710 00:0743: 3A                           dec     a
  Thu Feb 11 2016 20:45                                                                                                    Page 16


   711 00:0744: 5B                           tcd
   712 00:0745: A5 05                        lda     <5                      ; Fetch second value
   713 00:0747: 85 01                        sta     <1                      ; And make a copy
   714 00:0749: 4C 3C 0D                     jmp     NEXT                    ; Done
   715                        
   716                        ; SWAP ( x1 x2 -- x2 x1 )
   717                        ;
   718                        ; Exchange the top two stack items.
   719                        
   720 00:074C: 39 07 00                     HEADER  NORMAL
   721 00:074F: 04 53 57 41                  db      4,"SWAP"
       00:0753: 50 
   722                        SWAP:
   723 00:0754: A5 01                        lda     <1                      ; Switch top two words
   724 00:0756: A6 03                        ldx     <3
   725 00:0758: 85 03                        sta     <3
   726 00:075A: 86 01                        stx     <1
   727 00:075C: 4C 3C 0D                     jmp     NEXT                    ; Done
   728                        
   729                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   730                        ;
   731                        ; Rotate the top three stack entries.
   732                        
   733 00:075F: 4C 07 00                     HEADER  NORMAL
   734 00:0762: 03 52 4F 54                  db      3,"ROT"
   735                        ROT:
   736 00:0766: A6 05                        ldx     <5                      ; Save x1
   737 00:0768: A5 03                        lda     <3                      ; Move x2
   738 00:076A: 85 05                        sta     <5
   739 00:076C: A5 01                        lda     <1                      ; Move x3
   740 00:076E: 85 03                        sta     <3
   741 00:0770: 86 01                        stx     <1                      ; Restore x1
   742 00:0772: 4C 3C 0D                     jmp     NEXT
   743                        
   744                        ; ROLL [TODO]
   745                        
   746                        ; TUCK ( x1 x2 -- x2 x1 x2 )
   747                        ;
   748                        ; Copy the first (top) stack item below the second stack item.
   749                        
   750 00:0775: 5F 07 00                     HEADER  NORMAL
   751 00:0778: 04 54 55 43                  db      4,"TUCK"
       00:077C: 4B 
   752 00:077D: 20 38 0D     TUCK:           jsr     DO_COLON
   753 00:0780: 54 07                        dw      SWAP
   754 00:0782: 41 07                        dw      OVER
   755 00:0784: 60 0A                        dw      EXIT
   756                        
   757                        ;==============================================================================
   758                        ; Return Stack Operations
   759                        ;------------------------------------------------------------------------------
   760                        
   761                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   762                        ;
   763                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   764                        ; SWAP >R >R.
   765                        
   766 00:0786: 75 07 00                     HEADER  NORMAL
  Thu Feb 11 2016 20:45                                                                                                    Page 17


   767 00:0789: 03 32 3E 52                  db      3,"2>R"
   768                        TWO_TO_R:
   769 00:078D: A5 03                        lda     <3                      ; Transfer x1
   770 00:078F: 48                           pha
   771 00:0790: A5 01                        lda     <1                      ; Transfer x2
   772 00:0792: 48                           pha
   773 00:0793: 7B                           tdc
   774 00:0794: 1A                           inc     a                       ; Clean up data stack
   775 00:0795: 1A                           inc     a
   776 00:0796: 1A                           inc     a
   777 00:0797: 1A                           inc     a
   778 00:0798: 5B                           tcd
   779 00:0799: 4C 3C 0D                     jmp     NEXT                    ; Done
   780                        
   781                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   782                        ;
   783                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   784                        ; R> SWAP.
   785                        
   786 00:079C: 86 07 00                     HEADER  NORMAL
   787 00:079F: 03 32 52 3E                  db      3,"2R>"
   788                        TWO_R_FROM:
   789 00:07A3: 7B                           tdc
   790 00:07A4: 3A                           dec     a                       ; Make space for values
   791 00:07A5: 3A                           dec     a
   792 00:07A6: 3A                           dec     a
   793 00:07A7: 3A                           dec     a
   794 00:07A8: 5B                           tcd
   795 00:07A9: 68                           pla                             ; Transfer x2
   796 00:07AA: 85 01                        sta     <1
   797 00:07AC: 68                           pla                             ; Transfer x1
   798 00:07AD: 85 03                        sta     <3
   799 00:07AF: 4C 3C 0D                     jmp     NEXT                    ; Done
   800                        
   801                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
   802                        ;
   803                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   804                        ; 2DUP >R >R SWAP.
   805                        
   806 00:07B2: 9C 07 00                     HEADER  NORMAL
   807 00:07B5: 03 32 52 40                  db      3,"2R@"
   808                        TWO_R_FETCH:
   809 00:07B9: 7B                           tdc
   810 00:07BA: 3A                           dec     a                       ; Make space for values
   811 00:07BB: 3A                           dec     a
   812 00:07BC: 3A                           dec     a
   813 00:07BD: 3A                           dec     a
   814 00:07BE: 5B                           tcd
   815 00:07BF: A3 01                        lda     1,s                     ; Transfer x2
   816 00:07C1: 85 01                        sta     <1
   817 00:07C3: A3 03                        lda     3,s                     ; Transfer x1
   818 00:07C5: 85 03                        sta     <3
   819 00:07C7: 4C 3C 0D                     jmp     NEXT                    ; Done
   820                        
   821                        ; >R ( x -- ) ( R: -- x )
   822                        ;
   823                        ; Move x to the return stack.
   824                        
  Thu Feb 11 2016 20:45                                                                                                    Page 18


   825 00:07CA: B2 07 00                     HEADER  NORMAL
   826 00:07CD: 02 3E 52                     db      2,">R"
   827                        TO_R:
   828 00:07D0: A5 01                        lda     <1                      ; Transfer top value
   829 00:07D2: 48                           pha                             ; .. to return stack
   830 00:07D3: 7B                           tdc
   831 00:07D4: 1A                           inc     a
   832 00:07D5: 1A                           inc     a
   833 00:07D6: 5B                           tcd
   834 00:07D7: 4C 3C 0D                     jmp     NEXT                    ; Done
   835                        
   836                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   837                        ;
   838                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   839                        ; exists if the loop control parameters are unavailable.
   840                        
   841 00:07DA: CA 07 00                     HEADER  NORMAL
   842 00:07DD: 01 49                        db      1,"I"
   843                        I:
   844 00:07DF: 7B                           tdc
   845 00:07E0: 3A                           dec     a
   846 00:07E1: 3A                           dec     a
   847 00:07E2: 5B                           tcd
   848 00:07E3: A3 01                        lda     1,s
   849 00:07E5: 85 01                        sta     <1
   850 00:07E7: 4C 3C 0D                     jmp     NEXT
   851                        
   852                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   853                        ;
   854                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   855                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   856                        ; unavailable.
   857                        
   858 00:07EA: DA 07 00                     HEADER  NORMAL
   859 00:07ED: 01 4A                        db      1,"J"
   860                        J:
   861 00:07EF: 7B                           tdc
   862 00:07F0: 3A                           dec     a
   863 00:07F1: 3A                           dec     a
   864 00:07F2: 5B                           tcd
   865 00:07F3: A3 05                        lda     5,s
   866 00:07F5: 85 01                        sta     <1
   867 00:07F7: 4C 3C 0D                     jmp     NEXT
   868                        
   869                        ; R> ( -- x ) ( R: x -- )
   870                        ;
   871                        ; Move x from the return stack to the data stack.
   872                        
   873 00:07FA: EA 07 00                     HEADER  NORMAL
   874 00:07FD: 02 52 3E                     db      2,"R>"
   875                        R_FROM:
   876 00:0800: 7B                           tdc
   877 00:0801: 3A                           dec     a
   878 00:0802: 3A                           dec     a
   879 00:0803: 5B                           tcd
   880 00:0804: 68                           pla                             ; Fetch return stack value
   881 00:0805: 85 01                        sta     <1
   882 00:0807: 4C 3C 0D                     jmp     NEXT                    ; Done
  Thu Feb 11 2016 20:45                                                                                                    Page 19


   883                        
   884                        ; R@ ( -- x ) ( R: x -- x )
   885                        ;
   886                        ; Copy x from the return stack to the data stack.
   887                        
   888 00:080A: FA 07 00                     HEADER  NORMAL
   889 00:080D: 02 52 40                     db      2,"R@"
   890                        R_FETCH:
   891 00:0810: 7B                           tdc
   892 00:0811: 3A                           dec     a
   893 00:0812: 3A                           dec     a
   894 00:0813: 5B                           tcd
   895 00:0814: A3 01                        lda     1,s
   896 00:0816: 85 01                        sta     <1
   897 00:0818: 4C 3C 0D                     jmp     NEXT
   898                        
   899                        ;==============================================================================
   900                        ; Single Precision Arithmetic
   901                        ;------------------------------------------------------------------------------
   902                        
   903                        ; * ( n1|u1 n2|u2 -- n3|u3 )
   904                        ;
   905                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
   906                        
   907 00:081B: 0A 08 00                     HEADER  NORMAL
   908 00:081E: 01 2A                        db      1,"*"
   909                        STAR:
   910 00:0820: 4C 3C 0D                     jmp     NEXT                    ; Done
   911                        
   912                        ; */
   913                        ; */MOD
   914                        
   915                        
   916                        ; + ( n1|u1 n2|u2 -- n3|u3 )
   917                        ;
   918                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
   919                        
   920 00:0823: 1B 08 00                     HEADER  NORMAL
   921 00:0826: 01 2B                        db      1,"+"
   922                        PLUS:
   923 00:0828: 18                           clc                             ; Add top two values
   924 00:0829: A5 03                        lda     <3
   925 00:082B: 65 01                        adc     <1
   926 00:082D: 85 03                        sta     <3                      ; Save result
   927 00:082F: 7B                           tdc
   928 00:0830: 1A                           inc     a                       ; Clean up data stack
   929 00:0831: 1A                           inc     a
   930 00:0832: 5B                           tcd
   931 00:0833: 4C 3C 0D                     jmp     NEXT                    ; Done
   932                        
   933                        ; - ( n1|u1 n2|u2 -- n3|u3 )
   934                        ;
   935                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
   936                        
   937 00:0836: 23 08 00                     HEADER  NORMAL
   938 00:0839: 01 2D                        db      1,"-"
   939                        MINUS:
   940 00:083B: 38                           sec                             ; Subtract top two values
  Thu Feb 11 2016 20:45                                                                                                    Page 20


   941 00:083C: A5 03                        lda     <3
   942 00:083E: E5 01                        sbc     <1
   943 00:0840: 85 03                        sta     <3                      ; Save result
   944 00:0842: 7B                           tdc
   945 00:0843: 1A                           inc     a                       ; Clean up data stack
   946 00:0844: 1A                           inc     a
   947 00:0845: 5B                           tcd
   948 00:0846: 4C 3C 0D                     jmp     NEXT                    ; Done
   949                        
   950                        ; /
   951                        ; /MOD
   952                        
   953                        ; 1+ ( n1|u1 -- n2|u2 )
   954                        ;
   955                        ; Add one (1) to n1|u1 giving the sum n2|u2.
   956                        
   957 00:0849: 36 08 00                     HEADER  NORMAL
   958 00:084C: 02 31 2B                     db      2,"1+"
   959                        ONE_PLUS:
   960 00:084F: E6 01                        inc     <1                      ; Increment top of stack
   961 00:0851: 4C 3C 0D                     jmp     NEXT                    ; Done
   962                        
   963                        ; 1- ( n1|u1 -- n2|u2 )
   964                        ;
   965                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
   966                        
   967 00:0854: 49 08 00                     HEADER  NORMAL
   968 00:0857: 02 31 2D                     db      2,"1-"
   969                        ONE_MINUS:
   970 00:085A: C6 01                        dec     <1                      ; Decrement top of stack
   971 00:085C: 4C 3C 0D                     jmp     NEXT                    ; Done
   972                        
   973                        ; 2* ( x1 -- x2 )
   974                        ;
   975                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
   976                        ; filling the vacated least-significant bit with zero.
   977                        
   978 00:085F: 54 08 00                     HEADER  NORMAL
   979 00:0862: 02 32 2A                     db      2,"2*"
   980                        TWO_STAR:
   981 00:0865: 06 01                        asl     <1                      ; Multiply top value by two
   982 00:0867: 4C 3C 0D                     jmp     NEXT                    ; Done
   983                        
   984                        ; 2/ ( x1 -- x2 )
   985                        ;
   986                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
   987                        ; leaving the most-significant bit unchanged.
   988                        
   989 00:086A: 5F 08 00                     HEADER  NORMAL
   990 00:086D: 02 32 2F                     db      2,"2/"
   991                        TWO_SLASH:
   992 00:0870: A5 01                        lda     <1                      ; Load the top value
   993 00:0872: 2A                           rol     a                       ; Extract the top bit
   994 00:0873: 66 01                        ror     <1                      ; And shift back into value
   995 00:0875: 4C 3C 0D                     jmp     NEXT
   996                        
   997                        ; ABS ( n -- u )
   998                        ;
  Thu Feb 11 2016 20:45                                                                                                    Page 21


   999                        ; u is the absolute value of n.
  1000                        
  1001 00:0878: 6A 08 00                     HEADER  NORMAL
  1002 00:087B: 03 41 42 53                  db      3,"ABS"
  1003                        ABS:
  1004 00:087F: A5 01                        lda     <1
  1005 00:0881: 30 0D                        bmi     NEGATE
  1006 00:0883: 4C 3C 0D                     jmp     NEXT                    ; Done
  1007                        
  1008                        ; MAX
  1009                        ; MIN
  1010                        ; MOD
  1011                        
  1012                        ; NEGATE ( n1 -- n2 )
  1013                        ;
  1014                        ; Negate n1, giving its arithmetic inverse n2.
  1015                        
  1016 00:0886: 78 08 00                     HEADER  NORMAL
  1017 00:0889: 06 4E 45 47                  db      6,"NEGATE"
       00:088D: 41 54 45 
  1018                        NEGATE:
  1019 00:0890: 38                           sec                             ; Negate the top of stack
  1020 00:0891: A9 00 00                     lda     #0
  1021 00:0894: E5 01                        sbc     <1
  1022 00:0896: 85 01                        sta     <1
  1023 00:0898: 4C 3C 0D                     jmp     NEXT                    ; Done
  1024                        
  1025                        ; UMAX ( x1 x2 -- x1|x2 )
  1026                        
  1027 00:089B: 86 08 00                     HEADER  NORMAL
  1028 00:089E: 04 55 4D 41                  db      4,"UMAX"
       00:08A2: 58 
  1029                        UMAX:
  1030 00:08A3: A5 01                        lda     <1                      ; Compare the top values
  1031 00:08A5: C5 03                        cmp     <3
  1032 00:08A7: B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
  1033 00:08A9: 4C 13 07                     jmp     DROP                    ; No, x1 is
  1034 00:08AC: 4C 33 07     UMAX_EXIT:      jmp     NIP
  1035                        
  1036                        ; UMIN ( x1 x2 -- x1|x2 )
  1037                        
  1038 00:08AF: 9B 08 00                     HEADER  NORMAL
  1039 00:08B2: 04 55 4D 49                  db      4,"UMIN"
       00:08B6: 4E 
  1040                        UMIN:
  1041 00:08B7: A5 01                        lda     <1                      ; Compare the top values
  1042 00:08B9: C5 03                        cmp     <3
  1043 00:08BB: 90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
  1044 00:08BD: 4C 13 07                     jmp     DROP                    ; No, x1 is
  1045 00:08C0: 4C 33 07     UMIN_EXIT:      jmp     NIP
  1046                        
  1047                        ;==============================================================================
  1048                        ; Double Precision Arithmetic
  1049                        ;------------------------------------------------------------------------------
  1050                        
  1051                        ; D+
  1052                        ; D-
  1053                        ; DNEGATE
  Thu Feb 11 2016 20:45                                                                                                    Page 22


  1054                        
  1055                        ;==============================================================================
  1056                        ; Mixed Arithmetic
  1057                        ;------------------------------------------------------------------------------
  1058                        
  1059                        
  1060                        ; D>S ( d -- n )
  1061                        ;
  1062                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1063                        ; range of a signed single-cell number.
  1064                        
  1065 00:08C3: AF 08 00                     HEADER  NORMAL
  1066 00:08C6: 03 44 3E 53                  db      3,"D>S"
  1067                        D_TO_S:
  1068 00:08CA: 7B                           tdc
  1069 00:08CB: 1A                           inc     a                       ; Drop the high word
  1070 00:08CC: 1A                           inc     a
  1071 00:08CD: 5B                           tcd
  1072 00:08CE: 4C 3C 0D                     jmp     NEXT
  1073                        
  1074                        ; S>D ( n -- d )
  1075                        ;
  1076                        ; Convert the number n to the double-cell number d with the same numerical
  1077                        ; value.
  1078                        
  1079 00:08D1: C3 08 00                     HEADER  NORMAL
  1080 00:08D4: 03 53 3E 44                  db      3,"S>D"
  1081                        S_TO_D:
  1082 00:08D8: 7B                           tdc
  1083 00:08D9: 3A                           dec     a                       ; Assume n is positive
  1084 00:08DA: 3A                           dec     a
  1085 00:08DB: 5B                           tcd
  1086 00:08DC: 64 01                        stz     <1                      ; .. push a zero value
  1087 00:08DE: A5 03                        lda     <3                      ; Test the number
  1088 00:08E0: 10 02                        bpl     S_TO_D_1
  1089 00:08E2: C6 01                        dec     <1                      ; Make top -1 if negative
  1090 00:08E4: 4C 3C 0D     S_TO_D_1        jmp     NEXT                    ; Done
  1091                        
  1092                        ;==============================================================================
  1093                        ; Comparisons
  1094                        ;------------------------------------------------------------------------------
  1095                        
  1096                        ; 0< ( n -- flag )
  1097                        ;
  1098                        ; flag is true if and only if n is less than zero.
  1099                        
  1100 00:08E7: D1 08 00                     HEADER  NORMAL
  1101 00:08EA: 02 30 3C                     db      2,"0<"
  1102                        ZERO_LESS:
  1103 00:08ED: A5 01                        lda     <1                      ; Test top of stack
  1104 00:08EF: 64 01                        stz     <1                      ; Assume false result
  1105 00:08F1: 10 02                        bpl     ZERO_LT_1               ; Was the value negative?
  1106 00:08F3: C6 01                        dec     <1                      ; Yes, make true result
  1107 00:08F5: 4C 3C 0D     ZERO_LT_1:      jmp     NEXT                    ; Done
  1108                        
  1109                        ; 0<> ( x -- flag )
  1110                        ;
  1111                        ; flag is true if and only if x is not equal to zero.
  Thu Feb 11 2016 20:45                                                                                                    Page 23


  1112                        
  1113 00:08F8: E7 08 00                     HEADER  NORMAL
  1114 00:08FB: 03 30 3C 3E                  db      3,"0<>"
  1115                        ZERO_NOT_EQUAL:
  1116 00:08FF: A5 01                        lda     <1                      ; Test top of stack
  1117 00:0901: 64 01                        stz     <1                      ; Assume false result
  1118 00:0903: F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
  1119 00:0905: C6 01                        dec     <1                      ; Yes, make true result
  1120 00:0907: 4C 3C 0D     ZERO_NE_1:      jmp     NEXT                    ; Done
  1121                        
  1122                        ; 0= ( x -- flag )
  1123                        ;
  1124                        ; flag is true if and only if x is equal to zero.
  1125                        
  1126 00:090A: F8 08 00                     HEADER  NORMAL
  1127 00:090D: 02 30 3D                     db      2,"0="
  1128                        ZERO_EQUAL:
  1129 00:0910: A5 01                        lda     <1                      ; Test top of stack
  1130 00:0912: 64 01                        stz     <1                      ; Assume false result
  1131 00:0914: D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
  1132 00:0916: C6 01                        dec     <1                      ; Yes, make true result
  1133 00:0918: 4C 3C 0D     ZERO_EQ_1:      jmp     NEXT                    ; Done
  1134                        
  1135                        ; 0> ( n -- flag )
  1136                        ;
  1137                        ; flag is true if and only if n is greater than zero.
  1138                        
  1139 00:091B: 0A 09 00                     HEADER  NORMAL
  1140 00:091E: 02 30 3E                     db      2,"0>"
  1141                        ZERO_GREATER:
  1142 00:0921: A5 01                        lda     <1                      ; Test top of stack
  1143 00:0923: 64 01                        stz     <1                      ; Assume false result
  1144 00:0925: 30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
  1145 00:0927: F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
  1146 00:0929: C6 01                        dec     <1                      ; Yes, make true result
  1147 00:092B: 4C 3C 0D     ZERO_GT_EXIT:   jmp     NEXT                    ; Done
  1148                        
  1149                        ; <
  1150                        
  1151                        ; <>
  1152                        
  1153 00:092E: 1B 09 00                     HEADER  NORMAL
  1154 00:0931: 02 3C 3E                     db      2,"<>"
  1155                        NOT_EQUAL:
  1156 00:0934: A6 01                        ldx     <1                      ; Pull x2 from stack
  1157 00:0936: 7B                           tdc
  1158 00:0937: 1A                           inc     a
  1159 00:0938: 1A                           inc     a
  1160 00:0939: 5B                           tcd
  1161 00:093A: E4 01                        cpx     <1                      ; Compare with x1
  1162 00:093C: 64 01                        stz     <1                      ; Assume equal
  1163 00:093E: F0 02                        beq     NE_EXIT                 ; Test flags
  1164 00:0940: C6 01                        dec     <1                      ; Make result true
  1165 00:0942: 4C 3C 0D     NE_EXIT:        jmp     NEXT                    ; Done
  1166                        
  1167                        ; = ( x1 x2 -- flag )
  1168                        ;
  1169                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  Thu Feb 11 2016 20:45                                                                                                    Page 24


  1170                        
  1171 00:0945: 2E 09 00                     HEADER  NORMAL
  1172 00:0948: 01 3D                        db      1,"="
  1173                        EQUAL:
  1174 00:094A: A6 01                        ldx     <1                      ; Pull x2 from stack
  1175 00:094C: 7B                           tdc
  1176 00:094D: 1A                           inc     a
  1177 00:094E: 1A                           inc     a
  1178 00:094F: 5B                           tcd
  1179 00:0950: E4 01                        cpx     <1                      ; Compare with x1
  1180 00:0952: 64 01                        stz     <1                      ; Assume not equal
  1181 00:0954: D0 02                        bne     EQ_EXIT                 ; Test the flags
  1182 00:0956: E6 01                        inc     <1                      ; Make result true
  1183 00:0958: 4C 3C 0D     EQ_EXIT:        jmp     NEXT                    ; Done
  1184                        
  1185                        ; >
  1186                        
  1187                        ; U<
  1188                        ; U>
  1189                        
  1190                        ;==============================================================================
  1191                        ; Logical Operations
  1192                        ;------------------------------------------------------------------------------
  1193                        
  1194                        ; AND ( x1 x2 -- x3 )
  1195                        ;
  1196                        ; x3 is the bit-by-bit logical and of x1 with x2.
  1197                        
  1198 00:095B: 45 09 00                     HEADER  NORMAL
  1199 00:095E: 03 41 4E 44                  db      3,"AND"
  1200                        AND:
  1201 00:0962: A5 01                        lda     <1
  1202 00:0964: 25 03                        and     <3
  1203 00:0966: 85 03                        sta     <3
  1204 00:0968: 7B                           tdc
  1205 00:0969: 1A                           inc     a
  1206 00:096A: 1A                           inc     a
  1207 00:096B: 5B                           tcd
  1208 00:096C: 4C 3C 0D                     jmp     NEXT
  1209                        
  1210                        ; INVERT ( x1 -- x2 )
  1211                        ;
  1212                        ; Invert all bits of x1, giving its logical inverse x2.
  1213                        
  1214 00:096F: 5B 09 00                     HEADER  NORMAL
  1215 00:0972: 06 49 4E 56                  db      6,"INVERT"
       00:0976: 45 52 54 
  1216                        INVERT:
  1217 00:0979: A5 01                        lda     <1                      ; Fetch top value
  1218 00:097B: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1219 00:097E: 85 01                        sta     <1                      ; .. and write back
  1220 00:0980: 4C 3C 0D                     jmp     NEXT                    ; Done
  1221                        
  1222                        ; LSHIFT ( x1 u -- x2 )
  1223                        ;
  1224                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1225                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1226                        ; exists if u is greater than or equal to the number of bits in a cell.
  Thu Feb 11 2016 20:45                                                                                                    Page 25


  1227                        
  1228 00:0983: 6F 09 00                     HEADER  NORMAL
  1229 00:0986: 06 4C 53 48                  db      6,"LSHIFT"
       00:098A: 49 46 54 
  1230                        LSHIFT:
  1231 00:098D: A6 01                        ldx     <1                      ; Pull bit count
  1232 00:098F: 08                           php
  1233 00:0990: 7B                           tdc
  1234 00:0991: 1A                           inc     a                       ; .. from the stack
  1235 00:0992: 1A                           inc     a
  1236 00:0993: 5B                           tcd
  1237 00:0994: 28                           plp
  1238 00:0995: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1239 00:0997: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1240 00:099A: B0 08                        bcs     LSHIFT_2                ; Yes, result will be zero
  1241 00:099C: 06 01        LSHIFT_1        asl     <1                      ; Shift one bit left
  1242 00:099E: CA                           dex                             ; Update count
  1243 00:099F: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  1244 00:09A1: 4C 3C 0D     LSHIFT_0        jmp     NEXT                    ; Done
  1245 00:09A4: 64 01        LSHIFT_2        stz     <1                      ; Clear top value
  1246 00:09A6: 4C 3C 0D                     jmp     NEXT                    ; Done
  1247                        
  1248                        ; OR ( x1 x2 -- x3 )
  1249                        ;
  1250                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1251                        
  1252 00:09A9: 83 09 00                     HEADER  NORMAL
  1253 00:09AC: 02 4F 52                     db      2,"OR"
  1254                        OR:
  1255 00:09AF: A5 01                        lda     <1
  1256 00:09B1: 05 03                        ora     <3
  1257 00:09B3: 85 03                        sta     <3
  1258 00:09B5: 7B                           tdc
  1259 00:09B6: 1A                           inc     a
  1260 00:09B7: 1A                           inc     a
  1261 00:09B8: 5B                           tcd
  1262 00:09B9: 4C 3C 0D                     jmp     NEXT
  1263                        
  1264                        ; RSHIFT ( x1 u -- x2 )
  1265                        ;
  1266                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1267                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1268                        ; exists if u is greater than or equal to the number of bits in a cell.
  1269                        
  1270 00:09BC: A9 09 00                     HEADER  NORMAL
  1271 00:09BF: 06 52 53 48                  db      6,"RSHIFT"
       00:09C3: 49 46 54 
  1272                        RSHIFT:
  1273 00:09C6: A6 01                        ldx     <1                      ; Pull bit count
  1274 00:09C8: 08                           php
  1275 00:09C9: 7B                           tdc
  1276 00:09CA: 1A                           inc     a                       ; .. from the stack
  1277 00:09CB: 1A                           inc     a
  1278 00:09CC: 5B                           tcd
  1279 00:09CD: 28                           plp
  1280 00:09CE: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1281 00:09D0: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1282 00:09D3: B0 08                        bcs     RSHIFT_2                ; Yes, result will be zero
  Thu Feb 11 2016 20:45                                                                                                    Page 26


  1283 00:09D5: 46 01        RSHIFT_1        lsr     <1                      ; Shift one bit left
  1284 00:09D7: CA                           dex                             ; Update count
  1285 00:09D8: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1286 00:09DA: 4C 3C 0D     RSHIFT_0        jmp     NEXT                    ; Done
  1287 00:09DD: 64 01        RSHIFT_2        stz     <1                      ; Clear top value
  1288 00:09DF: 4C 3C 0D                     jmp     NEXT                    ; Done
  1289                        
  1290                        ; XOR ( x1 x2 -- x3 )
  1291                        ;
  1292                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1293                        
  1294 00:09E2: BC 09 00                     HEADER  NORMAL
  1295 00:09E5: 03 58 4F 52                  db      3,"XOR"
  1296                        XOR:
  1297 00:09E9: A5 01                        lda     <1
  1298 00:09EB: 45 03                        eor     <3
  1299 00:09ED: 85 03                        sta     <3
  1300 00:09EF: 7B                           tdc
  1301 00:09F0: 1A                           inc     a
  1302 00:09F1: 1A                           inc     a
  1303 00:09F2: 5B                           tcd
  1304 00:09F3: 4C 3C 0D                     jmp     NEXT
  1305                        
  1306                        ;==============================================================================
  1307                        ; Control Words
  1308                        ;------------------------------------------------------------------------------
  1309                        
  1310                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1311                        ;
  1312                        ; Empty the data stack and perform the function of QUIT, which includes
  1313                        ; emptying the return stack, without displaying a message.
  1314                        
  1315 00:09F6: E2 09 00                     HEADER  NORMAL
  1316 00:09F9: 05 41 42 4F                  db      5,"ABORT"
       00:09FD: 52 54 
  1317 00:09FF: 20 38 0D     ABORT:          jsr     DO_COLON
  1318 00:0A02: 06 0A                        dw      DO_ABORT
  1319 00:0A04: 6C 0A                        dw      QUIT
  1320                        
  1321                        DO_ABORT:
  1322 00:0A06: A9 7F 01                     lda     #DSTACK_END-1
  1323 00:0A09: 5B           		tcd
  1324 00:0A0A: 4C 3C 0D                     jmp     NEXT
  1325                        
  1326                        ; (BUILD) ( dtc-addr -- )
  1327                        ;
  1328                        ; Adds a jump the to exection function for the new word.
  1329                        
  1330 00:0A0D: F6 09 00                     HEADER  NORMAL
  1331 00:0A10: 07 28 42 55                  db      7,"(BUILD)"
       00:0A14: 49 4C 44 29 
  1332 00:0A18: 20 38 0D     BUILD:          jsr     DO_COLON
  1333 00:0A1B: 05 0E 4C 00                  dw      DO_LITERAL,$4c,C_COMMA
       00:0A1F: 10 06 
  1334 00:0A21: 9A 05 60 0A                  dw      COMMA,EXIT
  1335                        
  1336                        ; CREATE ( -- ) [TODO]
  1337                        ;
  Thu Feb 11 2016 20:45                                                                                                    Page 27


  1338                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1339                        ; definition for name with the execution semantics defined below. If the data-
  1340                        ; space pointer is not aligned, reserve enough data space to align it. The new
  1341                        ; data-space pointer defines names data field. CREATE does not allocate data
  1342                        ; space in names data field.
  1343                        
  1344 00:0A25: 0D 0A 00                     HEADER  NORMAL
  1345 00:0A28: 06 43 52 45                  db      6,"CREATE"
       00:0A2C: 41 54 45 
  1346 00:0A2F: 20 38 0D     CREATE:         jsr     DO_COLON
  1347                                        ; parse
  1348 00:0A32: 3C 06 AC 04                  dw      HERE,LATEST,FETCH,COMMA
       00:0A36: DA 05 9A 05 
  1349 00:0A3A: 01 05 10 06                  dw      ZERO,C_COMMA,LATEST,STORE
       00:0A3E: AC 04 72 05 
  1350                                        ; move name
  1351 00:0A42: 60 0A                        dw      EXIT
  1352                        
  1353                        ; EXECUTE
  1354                        
  1355 00:0A44: 25 0A 00                     HEADER  NORMAL
  1356 00:0A47: 07 45 58 45                  db      7,"EXECUTE"
       00:0A4B: 43 55 54 45 
  1357                        EXECUTE:
  1358 00:0A4F: A6 01                        ldx     <1
  1359 00:0A51: 7B                           tdc
  1360 00:0A52: 1A                           inc     a
  1361 00:0A53: 1A                           inc     a
  1362 00:0A54: 5B                           tcd
  1363 00:0A55: CA                           dex
  1364 00:0A56: DA                           phx
  1365 00:0A57: 60                           rts
  1366                        
  1367                        ; EXIT ( -- ) ( R: nest-sys -- )
  1368                        
  1369 00:0A58: 44 0A 00                     HEADER  NORMAL
  1370 00:0A5B: 04 45 58 49                  db      4,"EXIT"
       00:0A5F: 54 
  1371                        EXIT:
  1372 00:0A60: 7A                           ply
  1373 00:0A61: 4C 3C 0D                     jmp     NEXT
  1374                        
  1375                        ; QUIT ( -- ) ( R: i*x -- )
  1376                        ;
  1377                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  1378                        ; user input device the input source, and enter interpretation state. Do not
  1379                        ; display a message. Repeat the following:
  1380                        ;  Accept a line from the input source into the input buffer, set >IN to zero,
  1381                        ;   and interpret.
  1382                        ;  Display the implementation-defined system prompt if in interpretation state,
  1383                        ;   all processing has been completed, and no ambiguous condition exists.
  1384                        ;
  1385                        ; In this implementation it is defined as:
  1386                        ;
  1387                        ;   DO_QUIT 0 STATE !
  1388                        ;   0 (SOURCE-ID) !
  1389                        ;   BEGIN
  1390                        ;       REFILL
  Thu Feb 11 2016 20:45                                                                                                    Page 28


  1391                        ;       WHILE SOURCE EVALUATE
  1392                        ;       STATE @ 0= IF CR S" OK" TYPE THEN
  1393                        ;   AGAIN ;
  1394                        
  1395 00:0A64: 58 0A 00                     HEADER  NORMAL
  1396 00:0A67: 04 51 55 49                  db      4,"QUIT"
       00:0A6B: 54 
  1397 00:0A6C: 20 38 0D     QUIT:           jsr     DO_COLON
  1398 00:0A6F: 9A 0A                        dw      DO_QUIT
  1399 00:0A71: 01 05 EB 04                  dw      ZERO,STATE,STORE
       00:0A75: 72 05 
  1400 00:0A77: 01 05 DD 04                  dw      ZERO,SOURCEID,STORE
       00:0A7B: 72 05 
  1401 00:0A7D: CA 0B D1 0D  QUIT_1:         dw      REFILL,QUERY_BRANCH,QUIT_2
       00:0A81: 85 0A 
  1402 00:0A83: 60 0B                        dw      INTERPRET
  1403 00:0A85: EB 04 DA 05  QUIT_2:         dw      STATE,FETCH,ZERO_EQUAL
       00:0A89: 10 09 
  1404 00:0A8B: D1 0D 96 0A                  dw      QUERY_BRANCH,QUIT_3
  1405 00:0A8F: 99 0E                        dw      DO_S_QUOTE
  1406 00:0A91: 02 4F 6B                     db      2,"Ok"
  1407 00:0A94: 32 0F                        dw      TYPE
  1408 00:0A96: BF 0D 7D 0A  QUIT_3:         dw      BRANCH,QUIT_1
  1409                        
  1410                        DO_QUIT:
  1411 00:0A9A: A9 FF 01                     lda     #RSTACK_END-1           ; Reset the return stack
  1412 00:0A9D: 1B                           tcs
  1413 00:0A9E: 4C 3C 0D                     jmp     NEXT                    ; Done
  1414                        
  1415                        ;==============================================================================
  1416                        ; Parser & Interpreter
  1417                        ;------------------------------------------------------------------------------
  1418                        
  1419                        ; ?NUMBER
  1420                        
  1421 00:0AA1: 64 0A 00                     HEADER  NORMAL
  1422 00:0AA4: 07 3F 4E 55                  db      7,"?NUMBER"
       00:0AA8: 4D 42 45 52 
  1423 00:0AAC: 20 38 0D     QUERY_NUMBER:   jsr     DO_COLON
  1424                        
  1425 00:0AAF: 60 0A                        dw      EXIT
  1426                        
  1427                        ; ACCEPT ( c-addr +n1 -- +n2 )
  1428                        ;
  1429                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  1430                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  1431                        ; received. A program that depends on the presence or absence of non-graphic
  1432                        ; characters in the string has an environmental dependency. The editing
  1433                        ; functions, if any, that the system performs in order to construct the string
  1434                        ; are implementation-defined.
  1435                        ;
  1436                        ; Input terminates when an implementation-defined line terminator is received.
  1437                        ; When input terminates, nothing is appended to the string, and the display is
  1438                        ; maintained in an implementation-defined way.
  1439                        ;
  1440                        ; +n2 is the length of the string stored at c-addr.
  1441                        ;
  1442                        ;   OVER + 1- OVER      -- sa ea a
  Thu Feb 11 2016 20:45                                                                                                    Page 29


  1443                        ;   BEGIN KEY           -- sa ea a c
  1444                        ;   DUP 0D <> WHILE
  1445                        ;       DUP 8 = OVER 127 = OR IF
  1446                        ;             DROP 1-
  1447                        ;             >R OVER R> UMAX
  1448                        ;             8 EMIT SPACE 8 EMIT
  1449                        ;       ELSE
  1450                        ;           DUP EMIT    -- sa ea a c
  1451                        ;           OVER C! 1+ OVER UMIN
  1452                        ;       THEN            -- sa ea a
  1453                        ;   REPEAT              -- sa ea a c
  1454                        ;   DROP NIP SWAP - ;
  1455                        
  1456 00:0AB1: A1 0A 00                     HEADER  NORMAL
  1457 00:0AB4: 06 41 43 43                  db      6,"ACCEPT"
       00:0AB8: 45 50 54 
  1458 00:0ABB: 20 38 0D     ACCEPT:         jsr     DO_COLON
  1459 00:0ABE: 41 07 28 08                  dw      OVER,PLUS,ONE_MINUS,OVER
       00:0AC2: 5A 08 41 07 
  1460 00:0AC6: E7 0E 21 07  ACCEPT_1:       dw      KEY,DUP,DO_LITERAL,$0D,NOT_EQUAL
       00:0ACA: 05 0E 0D 00 
       00:0ACE: 34 09 
  1461 00:0AD0: D1 0D 1A 0B                  dw      QUERY_BRANCH,ACCEPT_4
  1462 00:0AD4: 21 07 05 0E                  dw      DUP,DO_LITERAL,$08,EQUAL
       00:0AD8: 08 00 4A 09 
  1463 00:0ADC: 41 07 05 0E                  dw      OVER,DO_LITERAL,$7f,EQUAL,OR
       00:0AE0: 7F 00 4A 09 
       00:0AE4: AF 09 
  1464 00:0AE6: D1 0D 08 0B                  dw      QUERY_BRANCH,ACCEPT_2
  1465 00:0AEA: 13 07 5A 08                  dw      DROP,ONE_MINUS
  1466 00:0AEE: D0 07 41 07                  dw      TO_R,OVER,R_FROM,UMAX
       00:0AF2: 00 08 A3 08 
  1467 00:0AF6: 05 0E 08 00                  dw      DO_LITERAL,8,EMIT,SPACE
       00:0AFA: D4 0E 00 0F 
  1468 00:0AFE: 05 0E 08 00                  dw      DO_LITERAL,8,EMIT,BRANCH,ACCEPT_3
       00:0B02: D4 0E BF 0D 
       00:0B06: 16 0B 
  1469 00:0B08: 21 07 D4 0E  ACCEPT_2:       dw      DUP,EMIT
  1470 00:0B0C: 41 07 F9 05                  dw      OVER,C_STORE,ONE_PLUS,OVER,UMIN
       00:0B10: 4F 08 41 07 
       00:0B14: B7 08 
  1471 00:0B16: BF 0D C6 0A  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  1472 00:0B1A: 13 07 33 07  ACCEPT_4:       dw      DROP,NIP,SWAP,MINUS,EXIT
       00:0B1E: 54 07 3B 08 
       00:0B22: 60 0A 
  1473                        
  1474                        ; EVALUATE ( i*x c-addr u -- j*x )
  1475                        ;
  1476                        ; Save the current input source specification. Store minus-one (-1) in
  1477                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  1478                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  1479                        ; parse area is empty, restore the prior input source specification. Other
  1480                        ; stack effects are due to the words EVALUATEd.
  1481                        ;
  1482                        ;   >R >R SAVE-INPUT
  1483                        ;   -1 (SOURCE-ID) !
  1484                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  1485                        ;   INTERPRET
  Thu Feb 11 2016 20:45                                                                                                    Page 30


  1486                        ;   RESTORE-INPUT DROP
  1487                        
  1488 00:0B24: B1 0A 00                     HEADER  NORMAL
  1489 00:0B27: 08 45 56 41                  db      8,"EVALUATE"
       00:0B2B: 4C 55 41 54 
       00:0B2F: 45 
  1490 00:0B30: 20 38 0D     EVALUATE:       jsr     DO_COLON
  1491 00:0B33: D0 07 D0 07                  dw      TO_R,TO_R,SAVE_INPUT
       00:0B37: 2D 0C 
  1492 00:0B39: 00 08 00 08                  dw      R_FROM,R_FROM
  1493 00:0B3D: 36 05 DD 04                  dw      TRUE,SOURCEID,STORE
       00:0B41: 72 05 
  1494 00:0B43: 01 05 68 04                  dw      ZERO,TO_IN,STORE
       00:0B47: 72 05 
  1495 00:0B49: BD 04 72 05                  dw      LENGTH,STORE
  1496 00:0B4D: 92 04 72 05                  dw      BUFFER,STORE
  1497 00:0B51: 60 0B                        dw      INTERPRET
  1498 00:0B53: 08 0C 13 07                  dw      RESTORE_INPUT,DROP
  1499 00:0B57: 60 0A                        dw      EXIT
  1500                        
  1501                        ; INTERPRET ( -- )
  1502                        ;
  1503                        ;
  1504                        ;   BEGIN
  1505                        ;   BL WORD DUP C@ WHILE        -- textadr
  1506                        ;       FIND                    -- a 0/1/-1
  1507                        ;       ?DUP IF                 -- xt 1/-1
  1508                        ;           1+ STATE @ 0= OR    immed or interp?
  1509                        ;           IF EXECUTE ELSE ,XT THEN
  1510                        ;       ELSE                    -- textadr
  1511                        ;           ?NUMBER
  1512                        ;           IF POSTPONE LITERAL     converted ok
  1513                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  1514                        ;           THEN
  1515                        ;       THEN
  1516                        ;   REPEAT DROP ;
  1517                        
  1518 00:0B59: 24 0B 60                     HEADER  INTERPRET
  1519 00:0B5C: 09 00 54 45                  dw      9,"INTERPRET"
  1520 00:0B60: 20 38 0D     INTERPRET:      jsr     DO_COLON
  1521 00:0B63: 10 05 77 0C  INTERPRET_1:    dw      BL,WORD,DUP,C_FETCH,QUERY_BRANCH,INTERPRET_7
       00:0B67: 21 07 27 06 
       00:0B6B: D1 0D AF 0B 
  1522 00:0B6F: BB 0B 04 07                  dw      FIND,QUERY_DUP,QUERY_BRANCH,INTERPRET_4
       00:0B73: D1 0D 91 0B 
  1523 00:0B77: 4F 08 EB 04                  dw      ONE_PLUS,STATE,FETCH,ZERO_EQUAL,OR
       00:0B7B: DA 05 10 09 
       00:0B7F: AF 09 
  1524 00:0B81: D1 0D 8B 0B                  dw      QUERY_BRANCH,INTERPRET_2,EXECUTE,BRANCH,INTERPRET_3
       00:0B85: 4F 0A BF 0D 
       00:0B89: 8D 0B 
  1525 00:0B8B: 9A 05        INTERPRET_2:    dw      COMMA
  1526 00:0B8D: BF 0D AB 0B  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  1527 00:0B91: AC 0A D1 0D  INTERPRET_4:    dw      QUERY_NUMBER,QUERY_BRANCH,INTERPRET_5
       00:0B95: 9D 0B 
  1528 00:0B97: EB 0D BF 0D                  dw      LITERAL,BRANCH,INTERPRET_6
       00:0B9B: AB 0B 
  1529 00:0B9D: 5A 00 32 0F  INTERPRET_5:    dw      COUNT,TYPE,DO_LITERAL,$3f,EMIT,CR,ABORT
  Thu Feb 11 2016 20:45                                                                                                    Page 31


       00:0BA1: 05 0E 3F 00 
       00:0BA5: D4 0E BB 0E 
       00:0BA9: FF 09 
  1530 00:0BAB: BF 0D 63 0B  INTERPRET_6     dw      BRANCH,INTERPRET_1
  1531 00:0BAF: 13 07 60 0A  INTERPRET_7:    dw      DROP,EXIT
  1532                        
  1533                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  1534                        ;
  1535                        ; Find the definition named in the counted string at c-addr. If the definition
  1536                        ; is not found, return c-addr and zero. If the definition is found, return its
  1537                        ; execution token xt. If the definition is immediate, also return one (1),
  1538                        ; otherwise also return minus-one (-1). For a given string, the values returned
  1539                        ; by FIND while compiling may differ from those returned while not compiling.
  1540                        ;
  1541                        ;   LATEST @ BEGIN             -- a nfa
  1542                        ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
  1543                        ;       N=                     -- a nfa f
  1544                        ;       DUP IF
  1545                        ;           DROP
  1546                        ;           NFA>LFA H@ DUP     -- a link link
  1547                        ;       THEN
  1548                        ;   0= UNTIL                   -- a nfa  OR  a 0
  1549                        ;   DUP IF
  1550                        ;       NIP DUP NFA>CFA        -- nfa xt
  1551                        ;       SWAP IMMED?            -- xt iflag
  1552                        ;       0= 1 OR                -- xt 1/-1
  1553                        ;   THEN ;
  1554                        
  1555 00:0BB3: 59 0B 00                     HEADER  NORMAL
  1556 00:0BB6: 04 46 49 4E                  db      4,"FIND"
       00:0BBA: 44 
  1557 00:0BBB: 20 38 0D     FIND:           jsr     DO_COLON
  1558                        
  1559                        
  1560                        
  1561 00:0BBE: 60 0A                        dw      EXIT
  1562                        
  1563                        ; REFILL ( -- flag )
  1564                        ;
  1565                        ; Attempt to fill the input buffer from the input source, returning a true flag
  1566                        ; if successful.
  1567                        ;
  1568                        ; When the input source is the user input device, attempt to receive input into
  1569                        ; the terminal input buffer. If successful, make the result the input buffer,
  1570                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  1571                        ; is considered successful. If there is no input available from the current
  1572                        ; input source, return false.
  1573                        ;
  1574                        ; When the input source is a string from EVALUATE, return false and perform no
  1575                        ; other action.
  1576                        ;
  1577                        ;   SOURCE-ID 0= IF
  1578                        ;    TIB DUP #TIB @ ACCEPT SPACE
  1579                        ;    LENGTH ! BUFFER !
  1580                        ;    0 >IN ! TRUE EXIT
  1581                        ;   THEN
  1582                        ;   FALSE
  1583                        
  Thu Feb 11 2016 20:45                                                                                                    Page 32


  1584 00:0BC0: B3 0B 00                     HEADER  NORMAL
  1585 00:0BC3: 06 52 45 46                  db      6,"REFILL"
       00:0BC7: 49 4C 4C 
  1586 00:0BCA: 20 38 0D     REFILL:         jsr     DO_COLON
  1587 00:0BCD: 66 0C 10 09                  dw      SOURCE_ID,ZERO_EQUAL,QUERY_BRANCH,REFILL_1
       00:0BD1: D1 0D F3 0B 
  1588 00:0BD5: F7 04 21 07                  dw      TIB,DUP,HASH_TIB,FETCH,ACCEPT,SPACE
       00:0BD9: 5A 04 DA 05 
       00:0BDD: BB 0A 00 0F 
  1589 00:0BE1: BD 04 72 05                  dw      LENGTH,STORE,BUFFER,STORE
       00:0BE5: 92 04 72 05 
  1590 00:0BE9: 01 05 68 04                  dw      ZERO,TO_IN,STORE,TRUE,EXIT
       00:0BED: 72 05 36 05 
       00:0BF1: 60 0A 
  1591 00:0BF3: 25 05 60 0A  REFILL_1:       dw      FALSE,EXIT
  1592                        
  1593                        ; RESTORE-INPUT
  1594                        
  1595 00:0BF7: C0 0B 00                     HEADER  NORMAL
  1596 00:0BFA: 0D 52 45 53                  db      13,"RESTORE-INPUT"
       00:0BFE: 54 4F 52 45 
       00:0C02: 2D 49 4E 50 
       00:0C06: 55 54 
  1597 00:0C08: 20 38 0D     RESTORE_INPUT   jsr     DO_COLON
  1598 00:0C0B: 68 04 72 05                  dw      TO_IN,STORE
  1599 00:0C0F: BD 04 72 05                  dw      LENGTH,STORE
  1600 00:0C13: 92 04 72 05                  dw      BUFFER,STORE
  1601 00:0C17: DD 04 72 05                  dw      SOURCEID,STORE
  1602 00:0C1B: 36 05 60 0A                  dw      TRUE,EXIT
  1603                        
  1604                        ; SAVE-INPUT
  1605                        
  1606 00:0C1F: F7 0B 00                     HEADER  NORMAL
  1607 00:0C22: 0A 53 41 56                  db      10,"SAVE-INPUT"
       00:0C26: 45 2D 49 4E 
       00:0C2A: 50 55 54 
  1608 00:0C2D: 20 38 0D     SAVE_INPUT:     jsr     DO_COLON
  1609 00:0C30: DD 04 DA 05                  dw      SOURCEID,FETCH
  1610 00:0C34: 92 04 DA 05                  dw      BUFFER,FETCH
  1611 00:0C38: BD 04 DA 05                  dw      LENGTH,FETCH
  1612 00:0C3C: 68 04 DA 05                  dw      TO_IN,FETCH,EXIT
       00:0C40: 60 0A 
  1613                        
  1614                        ; SOURCE ( -- c-addr u )
  1615                        ;
  1616                        ; c-addr is the address of, and u is the number of characters in, the input
  1617                        ; buffer.
  1618                        ;
  1619                        ; In this implementation it is defined as
  1620                        ;
  1621                        ;   BUFFER @ LENGTH @
  1622                        
  1623 00:0C42: 1F 0C 00                     HEADER  NORMAL
  1624 00:0C45: 06 53 4F 55                  db      6,"SOURCE"
       00:0C49: 52 43 45 
  1625 00:0C4C: 20 38 0D     SOURCE:         jsr     DO_COLON
  1626 00:0C4F: 92 04 DA 05                  dw      BUFFER,FETCH
  1627 00:0C53: BD 04 DA 05                  dw      LENGTH,FETCH
  Thu Feb 11 2016 20:45                                                                                                    Page 33


  1628 00:0C57: 60 0A                        dw      EXIT
  1629                        
  1630                        ; SOURCE-ID ( -- 0 | -1 )
  1631                        ;
  1632                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  1633                        ; device.
  1634                        
  1635 00:0C59: 42 0C 00                     HEADER  NORMAL
  1636 00:0C5C: 09 53 4F 55                  db      9,"SOURCE-ID"
       00:0C60: 52 43 45 2D 
       00:0C64: 49 44 
  1637 00:0C66: 20 38 0D     SOURCE_ID:      jsr     DO_COLON
  1638 00:0C69: DD 04 DA 05                  dw      SOURCEID,FETCH
  1639 00:0C6D: 60 0A                        dw      EXIT
  1640                        
  1641                        ; WORD
  1642                        ;
  1643                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  1644                        ;   DUP >R   ROT SKIP           -- c adr' n'
  1645                        ;   OVER >R  ROT SCAN           -- adr" n"
  1646                        ;   DUP IF CHAR- THEN        skip trailing delim.
  1647                        ;   R> R> ROT -   >IN +!        update >IN offset
  1648                        ;   TUCK -                      -- adr' N
  1649                        ;   HERE >counted               --
  1650                        ;   HERE                        -- a
  1651                        ;   BL OVER COUNT + C! ;    append trailing blank
  1652                        
  1653 00:0C6F: 59 0C 00                     HEADER  NORMAL
  1654 00:0C72: 04 57 4F 52                  db      4,"WORD"
       00:0C76: 44 
  1655 00:0C77: 20 38 0D     WORD:           jsr     DO_COLON
  1656 00:0C7A: 21 07 4C 0C                  dw      DUP,SOURCE,TO_IN,FETCH,SLASH_STRING
       00:0C7E: 68 04 DA 05 
       00:0C82: CF 0C 
  1657 00:0C84: 21 07 D0 07                  dw      DUP,TO_R,ROT,SKIP
       00:0C88: 66 07 96 0C 
  1658 00:0C8C: 41 07 D0 07                  dw      OVER,TO_R,ROT,SCAN
       00:0C90: 66 07 AD 0C 
  1659                        
  1660                                        ; TODO
  1661                        
  1662 00:0C94: 60 0A                        dw      EXIT
  1663                        
  1664                        ; SKIP ( c-addr n c == c-addr' n' )
  1665                        
  1666                        SKIP:
  1667 00:0C96: A5 03        SKIP_1:         lda     <3                      ; Any data left to skip over?
  1668 00:0C98: F0 10                        beq     SKIP_2                  ; No.
  1669 00:0C9A: A5 01                        lda     <1                      ; Fetch and compare with skip
  1670 00:0C9C: E2 20                        short_a
  1671 00:0C9E: D2 05                        cmp     (5)
  1672 00:0CA0: C2 20                        long_a
  1673 00:0CA2: D0 06                        bne     SKIP_2                  ; Cannot be skipped
  1674 00:0CA4: E6 05                        inc     <5                      ; Bump data address
  1675 00:0CA6: C6 03                        dec     <3                      ; and update length
  1676 00:0CA8: 80 EC                        bra     SKIP_1                  ; And repeat
  1677                        
  1678                        SKIP_2:
  Thu Feb 11 2016 20:45                                                                                                    Page 34


  1679 00:0CAA: 4C 13 07                     jmp     DROP                    ; Drop the character
  1680                        
  1681                        ; SKIP ( c-addr n c == c-addr' n' )
  1682                        
  1683 00:0CAD: 20 38 0D     SCAN:           jsr     DO_COLON
  1684                        
  1685 00:0CB0: 60 0A                        dw      EXIT
  1686                        
  1687                        ;==============================================================================
  1688                        ; String Words
  1689                        ;------------------------------------------------------------------------------
  1690                        
  1691                        ; -TRAILING
  1692                        
  1693 00:0CB2: 6F 0C 00                     HEADER  NORMAL
  1694 00:0CB5: 09 2D 54 52                  db      9,"-TRAILING"
       00:0CB9: 41 49 4C 49 
       00:0CBD: 4E 47 
  1695 00:0CBF: 20 38 0D     DASH_TRAILING:  jsr     DO_COLON
  1696                        
  1697 00:0CC2: 60 0A                        dw      EXIT
  1698                        
  1699                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  1700                        ;
  1701                        ; Adjust the character string at c-addr1 by n characters. The resulting
  1702                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  1703                        ; characters and is u1 minus n characters long.
  1704                        ;
  1705                        ;   ROT OVER + ROT ROT -
  1706                        
  1707 00:0CC4: B2 0C 00                     HEADER  NORMAL
  1708 00:0CC7: 07 2F 53 54                  db      7,"/STRING"
       00:0CCB: 52 49 4E 47 
  1709 00:0CCF: 20 38 0D     SLASH_STRING:   jsr     DO_COLON
  1710 00:0CD2: 66 07 41 07                  dw      ROT,OVER,PLUS
       00:0CD6: 28 08 
  1711 00:0CD8: 66 07 66 07                  dw      ROT,ROT,MINUS
       00:0CDC: 3B 08 
  1712 00:0CDE: 60 0A                        dw      EXIT
  1713                        
  1714                        ; BLANK
  1715                        
  1716                        ; CMOVE ( c-addr1 c-addr2 u -- )
  1717                        ;
  1718                        ; If u is greater than zero, copy u consecutive characters from the data space
  1719                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  1720                        ; character from lower addresses to higher addresses.
  1721                        
  1722 00:0CE0: C4 0C 00                     HEADER  NORMAL
  1723 00:0CE3: 05 43 4D 4F                  db      5,"CMOVE"
       00:0CE7: 56 45 
  1724                        CMOVE:
  1725 00:0CE9: 5A                           phy                             ; Save IP
  1726 00:0CEA: DA                           phx                             ; Save stack pointer
  1727 00:0CEB: A5 01                        lda     <1                      ; Fetch length and save
  1728 00:0CED: 48                           pha
  1729 00:0CEE: A4 03                        ldy     <3                      ; Fetch target address
  1730 00:0CF0: A5 05                        lda     <5                      ; Fetch source address
  Thu Feb 11 2016 20:45                                                                                                    Page 35


  1731 00:0CF2: AA                           tax
  1732 00:0CF3: 68                           pla                             ; Recover length
  1733 00:0CF4: F0 04                        beq     CMOVE_1                 ; .. No bytes to move
  1734 00:0CF6: 3A                           dec     a                       ; Adjust count for MVN
  1735 00:0CF7: 54 00 00                     mvn     0,0                     ; Perform the move
  1736 00:0CFA: FA           CMOVE_1:        plx
  1737 00:0CFB: E8                           inx                             ; Clean up the stack
  1738 00:0CFC: E8                           inx
  1739 00:0CFD: E8                           inx
  1740 00:0CFE: E8                           inx
  1741 00:0CFF: E8                           inx
  1742 00:0D00: E8                           inx
  1743 00:0D01: 7A                           ply                             ; Restore IP
  1744 00:0D02: 4C 3C 0D                     jmp     NEXT
  1745                        
  1746                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  1747                        ;
  1748                        ; If u is greater than zero, copy u consecutive characters from the data space
  1749                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  1750                        ; character from higher addresses to lower addresses.
  1751                        
  1752 00:0D05: E0 0C 00                     HEADER  NORMAL
  1753 00:0D08: 06 43 4D 4F                  db      6,"CMOVE>"
       00:0D0C: 56 45 3E 
  1754                        CMOVE_GREATER:
  1755 00:0D0F: 4C 3C 0D                     jmp     NEXT
  1756                        
  1757                        ; COMPARE
  1758                        
  1759                        ; SEARCH
  1760                        
  1761                        
  1762                        ;==============================================================================
  1763                        ; Compiling Words
  1764                        ;------------------------------------------------------------------------------
  1765                        
  1766                        ; +LOOP ( -- )
  1767                        
  1768 00:0D12: 05 0D 80                     HEADER  IMMEDIATE
  1769 00:0D15: 05 2B 4C 4F                  db      5,"+LOOP"
       00:0D19: 4F 50 
  1770 00:0D1B: 20 38 0D     PLUS_LOOP:      jsr     DO_COLON
  1771                        
  1772 00:0D1E: 60 0A                        dw      EXIT
  1773                        
  1774                        ; (+LOOP)
  1775                        
  1776 00:0D20: 12 0D 00                     HEADER  NORMAL
  1777 00:0D23: 07 28 2B 4C                  db      7,"(+LOOP)"
       00:0D27: 4F 4F 50 29 
  1778                        DO_PLUS_LOOP:
  1779                        
  1780 00:0D2B: 4C 3C 0D                     jmp     NEXT
  1781                        
  1782                        ; : ( -- )
  1783                        
  1784 00:0D2E: 20 0D 00                     HEADER  NORMAL
  1785 00:0D31: 01 3A                        db      1,":"
  Thu Feb 11 2016 20:45                                                                                                    Page 36


  1786 00:0D33: 20 38 0D     COLON:          jsr     DO_COLON
  1787                        
  1788 00:0D36: 60 0A                        dw      EXIT
  1789                        
  1790                        DO_COLON:
  1791 00:0D38: FA                           plx
  1792 00:0D39: 5A                           phy
  1793 00:0D3A: E8                           inx
  1794 00:0D3B: 9B                           txy
  1795                        
  1796                        NEXT:
  1797 00:0D3C: BB                           tyx                             ; Copy IP to X
  1798 00:0D3D: C8                           iny
  1799 00:0D3E: C8                           iny
  1800 00:0D3F: 7C 00 00                     jmp     (0,x)                   ; Then execute word
  1801                        
  1802                        ; AGAIN
  1803                        
  1804 00:0D42: 2E 0D 80                     HEADER  IMMEDIATE
  1805 00:0D45: 05 00 4E 49                  dw      5,"AGAIN"
  1806 00:0D49: 20 38 0D     AGAIN:          jsr     DO_COLON
  1807                        
  1808 00:0D4C: 60 0A                        dw      EXIT
  1809                        
  1810                        ; BEGIN
  1811                        
  1812 00:0D4E: 42 0D 80                     HEADER  IMMEDIATE
  1813 00:0D51: 05 00 4E 49                  dw      5,"BEGIN"
  1814 00:0D55: 20 38 0D     BEGIN:          jsr     DO_COLON
  1815                        
  1816 00:0D58: 60 0A                        dw      EXIT
  1817                        
  1818                        ; CONSTANT ( x <spaces>name -- )
  1819                        ;
  1820                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1821                        ; definition for name with the execution semantics defined below.
  1822                        
  1823 00:0D5A: 4E 0D 00                     HEADER  NORMAL
  1824 00:0D5D: 08 43 4F 4E                  db      8,"CONSTANT"
       00:0D61: 53 54 41 4E 
       00:0D65: 54 
  1825 00:0D66: 20 38 0D     CONSTANT:       jsr     DO_COLON
  1826 00:0D69: 2F 0A                        dw      CREATE
  1827 00:0D6B: 05 0E 83 0D                  dw      DO_LITERAL,DO_CONSTANT,BUILD
       00:0D6F: 18 0A 
  1828 00:0D71: 9A 05 60 0A                  dw      COMMA,EXIT
  1829                        
  1830                        ; (CONSTANT) ( -- x )
  1831                        
  1832 00:0D75: 5A 0D 00                     HEADER  NORMAL
  1833 00:0D78: 0A 28 43 4F                  db      10,"(CONSTANT)"
       00:0D7C: 4E 53 54 41 
       00:0D80: 4E 54 29 
  1834                        DO_CONSTANT:
  1835 00:0D83: FA                           plx
  1836 00:0D84: 7B                           tdc
  1837 00:0D85: 3A                           dec     a
  1838 00:0D86: 3A                           dec     a
  Thu Feb 11 2016 20:45                                                                                                    Page 37


  1839 00:0D87: 5B                           tcd
  1840 00:0D88: BD 01 00                     lda     !1,x
  1841 00:0D8B: 85 01                        sta     <1
  1842 00:0D8D: 4C 3C 0D                     jmp     NEXT                    ; Done
  1843                        
  1844                        ; DO ( -- )
  1845                        
  1846 00:0D90: 75 0D 80                     HEADER  IMMEDIATE
  1847 00:0D93: 02 44 4F                     db      2,"DO"
  1848 00:0D96: 20 38 0D     DO:             jsr     DO_COLON
  1849                        
  1850 00:0D99: 60 0A                        dw      EXIT
  1851                        
  1852                        ; (DO) ( -- )
  1853                        
  1854 00:0D9B: 90 0D 00                     HEADER  NORMAL
  1855 00:0D9E: 04 28 44 4F                  db      4,"(DO)"
       00:0DA2: 29 
  1856                        DO_DO:
  1857 00:0DA3: A5 03                        lda     <3
  1858 00:0DA5: 48                           pha
  1859 00:0DA6: A5 01                        lda     <1
  1860 00:0DA8: 48                           pha
  1861 00:0DA9: 7B                           tdc
  1862 00:0DAA: 1A                           inc     a
  1863 00:0DAB: 1A                           inc     a
  1864 00:0DAC: 1A                           inc     a
  1865 00:0DAD: 1A                           inc     a
  1866 00:0DAE: 5B                           tcd
  1867 00:0DAF: 4C 3C 0D                     jmp     NEXT
  1868                        
  1869                        ; ELSE
  1870                        
  1871 00:0DB2: 9B 0D 80                     HEADER  IMMEDIATE
  1872 00:0DB5: 04 45 4C 53                  db      4,"ELSE"
       00:0DB9: 45 
  1873 00:0DBA: 20 38 0D     ELSE:           jsr     DO_COLON
  1874                        
  1875 00:0DBD: 60 0A                        dw      EXIT
  1876                        
  1877                        ; (BRANCH) ( -- )
  1878                        ;
  1879                        ; Cause the IP to be loaded with the word following the link to this word.
  1880                        
  1881                        BRANCH:
  1882 00:0DBF: B9 00 00                     lda     !0,y                    ; Load branch address into IP
  1883 00:0DC2: A8                           tay
  1884 00:0DC3: 4C 3C 0D                     jmp     NEXT                    ; Done
  1885                        
  1886                        ; IF
  1887                        
  1888 00:0DC6: B2 0D 80                     HEADER  IMMEDIATE
  1889 00:0DC9: 02 49 46                     db      2,"IF"
  1890 00:0DCC: 20 38 0D     IF:             jsr     DO_COLON
  1891                        
  1892 00:0DCF: 60 0A                        dw      EXIT
  1893                        
  1894                        ; (?BRANCH) ( flag -- )
  Thu Feb 11 2016 20:45                                                                                                    Page 38


  1895                        ;
  1896                        ; If flag is false then cause the IP to be loaded with the word following the
  1897                        ; link to this word, otherwise skip over it.
  1898                        
  1899                        QUERY_BRANCH:
  1900 00:0DD1: A6 01                        ldx     <1                      ; Pull the top of stack value
  1901 00:0DD3: 08                           php                             ; Save the flags
  1902 00:0DD4: 7B                           tdc
  1903 00:0DD5: 1A                           inc     a                       ; Drop top item
  1904 00:0DD6: 1A                           inc     a
  1905 00:0DD7: 5B                           tcd
  1906 00:0DD8: 28                           plp
  1907 00:0DD9: F0 E4                        beq     BRANCH                  ; Branch if top was zero
  1908 00:0DDB: C8                           iny                             ; Otherwise skip address
  1909 00:0DDC: C8                           iny
  1910 00:0DDD: 4C 3C 0D                     jmp     NEXT                    ; Done
  1911                        
  1912                        ; LITERAL ( x -- )
  1913                        ;
  1914                        ; Append the run-time semantics given below to the current definition.
  1915                        
  1916 00:0DE0: C6 0D 80                     HEADER  IMMEDIATE
  1917 00:0DE3: 07 4C 49 54                  db      7,"LITERAL"
       00:0DE7: 45 52 41 4C 
  1918 00:0DEB: 20 38 0D     LITERAL:        jsr     DO_COLON
  1919 00:0DEE: 05 0E 05 0E                  dw      DO_LITERAL,DO_LITERAL,COMMA
       00:0DF2: 9A 05 
  1920 00:0DF4: 9A 05 60 0A                  dw      COMMA,EXIT
  1921                        
  1922                        ; (LITERAL) ( -- x )
  1923                        ;
  1924                        ; Place x on the stack.
  1925                        
  1926 00:0DF8: E0 0D 00                     HEADER  NORMAL
  1927 00:0DFB: 0A 28 4C 49                  db      10,"(LITERAL)"
       00:0DFF: 54 45 52 41 
       00:0E03: 4C 29 
  1928                        DO_LITERAL:
  1929 00:0E05: 7B                           tdc
  1930 00:0E06: 3A                           dec     a
  1931 00:0E07: 3A                           dec     a
  1932 00:0E08: 5B                           tcd
  1933 00:0E09: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  1934 00:0E0C: C8                           iny
  1935 00:0E0D: C8                           iny
  1936 00:0E0E: 85 01                        sta     <1
  1937 00:0E10: 4C 3C 0D                     jmp     NEXT                    ; Done
  1938                        
  1939                        ; LOOP
  1940                        
  1941 00:0E13: F8 0D 80                     HEADER  IMMEDIATE
  1942 00:0E16: 04 4C 4F 4F                  db      4,"LOOP"
       00:0E1A: 50 
  1943 00:0E1B: 20 38 0D     LOOP:           jsr     DO_COLON
  1944                        
  1945 00:0E1E: 60 0A                        dw      EXIT
  1946                        
  1947                        ; (LOOP)
  Thu Feb 11 2016 20:45                                                                                                    Page 39


  1948                        
  1949 00:0E20: 13 0E 00                     HEADER  NORMAL
  1950 00:0E23: 06 28 4C 4F                  db      6,"(LOOP)"
       00:0E27: 4F 50 29 
  1951                        DO_LOOP
  1952 00:0E2A: A3 01                        lda     1,s                     ; Add one to loop counter
  1953 00:0E2C: 1A                           inc     a
  1954 00:0E2D: 83 01                        sta     1,s
  1955 00:0E2F: C3 03                        cmp     3,s                     ; Reached limit?
  1956 00:0E31: B0 07                        bcs     DO_LOOP_END             ; Yes
  1957 00:0E33: B9 00 00                     lda     !0,y                    ; No, branch back to start
  1958 00:0E36: A8                           tay
  1959 00:0E37: 4C 3C 0D                     jmp     NEXT                    ; Done
  1960 00:0E3A: C8           DO_LOOP_END:    iny                             ; Skip over address
  1961 00:0E3B: C8                           iny
  1962 00:0E3C: 68                           pla                             ; Drop loop variables
  1963 00:0E3D: 68                           pla
  1964 00:0E3E: 4C 3C 0D                     jmp     NEXT                    ; Done
  1965                        
  1966                        ; USER
  1967                        
  1968 00:0E41: 20 0E 00                     HEADER  NORMAL
  1969 00:0E44: 04 55 53 45                  db      4,"USER"
       00:0E48: 52 
  1970 00:0E49: 20 38 0D     USER:           jsr     DO_COLON
  1971                        
  1972 00:0E4C: 60 0A                        dw      EXIT
  1973                        
  1974 00:0E4E: 41 0E 00                     HEADER  NORMAL
  1975 00:0E51: 06 28 55 53                  db      6,"(USER)"
       00:0E55: 45 52 29 
  1976                        DO_USER:
  1977 00:0E58: 7B                           tdc
  1978 00:0E59: 3A                           dec     a                       ; Push on data stack
  1979 00:0E5A: 3A                           dec     a
  1980 00:0E5B: 5B                           tcd
  1981 00:0E5C: FA                           plx
  1982 00:0E5D: 18                           clc
  1983 00:0E5E: BD 01 00                     lda     !1,x
  1984 00:0E61: 69 00 00                     adc     #USER_AREA
  1985 00:0E64: 85 01                        sta     <1
  1986 00:0E66: 4C 3C 0D                     jmp     NEXT                    ; Done
  1987                        
  1988                        ; VARIABLE
  1989                        
  1990 00:0E69: 4E 0E 00                     HEADER  NORMAL
  1991 00:0E6C: 08 56 41 52                  db      8,"VARIABLE"
       00:0E70: 49 41 42 4C 
       00:0E74: 45 
  1992 00:0E75: 20 38 0D     VARIABLE:       jsr     DO_COLON
  1993                        
  1994 00:0E78: 60 0A                        dw      EXIT
  1995                        
  1996 00:0E7A: 69 0E 00                     HEADER  NORMAL
  1997 00:0E7D: 0A 28 56 41                  db      10,"(VARIABLE)"
       00:0E81: 52 49 41 42 
       00:0E85: 4C 45 29 
  1998                        DO_VARIABLE:
  Thu Feb 11 2016 20:45                                                                                                    Page 40


  1999 00:0E88: 7B                           tdc
  2000 00:0E89: 3A                           dec     a
  2001 00:0E8A: 3A                           dec     a
  2002 00:0E8B: 5B                           tcd
  2003 00:0E8C: 68                           pla
  2004 00:0E8D: 1A                           inc     a
  2005 00:0E8E: 85 01                        sta     <1
  2006 00:0E90: 4C 3C 0D                     jmp     NEXT
  2007                        
  2008                        ; S"
  2009                        
  2010 00:0E93: 7A 0E 80                     HEADER  IMMEDIATE
  2011 00:0E96: 02 53 22                     db      2,"S",'"'
  2012                        S_QUOTE:
  2013                        
  2014                        ; (S") ( -- c-addr u )
  2015                        
  2016                        DO_S_QUOTE:
  2017 00:0E99: 7B                           tdc
  2018 00:0E9A: 3A                           dec     a                       ; Reserve space for values
  2019 00:0E9B: 3A                           dec     a
  2020 00:0E9C: 3A                           dec     a
  2021 00:0E9D: 3A                           dec     a
  2022 00:0E9E: 5B                           tcd
  2023 00:0E9F: E2 20                        short_a
  2024 00:0EA1: B9 00 00                     lda     !0,y                    ; Fetch the length
  2025 00:0EA4: 85 01                        sta     <1
  2026 00:0EA6: 64 02                        stz     <2
  2027 00:0EA8: C2 20                        long_a
  2028 00:0EAA: C8                           iny
  2029 00:0EAB: 98                           tya                             ; Save the text address
  2030 00:0EAC: 85 03                        sta     <3
  2031 00:0EAE: 18                           clc                             ; And update IP
  2032 00:0EAF: 65 01                        adc     <1
  2033 00:0EB1: A8                           tay
  2034 00:0EB2: 4C 3C 0D                     jmp     NEXT                    ; Done
  2035                        
  2036                        ;==============================================================================
  2037                        ; I/O Operations
  2038                        ;------------------------------------------------------------------------------
  2039                        
  2040                        ; CR ( -- )
  2041                        ;
  2042                        ; Cause subsequent output to appear at the beginning of the next line.
  2043                        ;
  2044                        ; In this implementation it is defined as
  2045                        ;
  2046                        ;   13 EMIT 10 EMIT
  2047                        
  2048 00:0EB5: 93 0E 00                     HEADER  NORMAL
  2049 00:0EB8: 02 43 52                     db      2,"CR"
  2050 00:0EBB: 20 38 0D     CR:             jsr     DO_COLON
  2051 00:0EBE: 05 0E 0D 00                  dw      DO_LITERAL,13,EMIT
       00:0EC2: D4 0E 
  2052 00:0EC4: 05 0E 0A 00                  dw      DO_LITERAL,10,EMIT
       00:0EC8: D4 0E 
  2053 00:0ECA: 60 0A                        dw      EXIT
  2054                        
  Thu Feb 11 2016 20:45                                                                                                    Page 41


  2055                        ; EMIT ( x -- )
  2056                        ;
  2057                        ; If x is a graphic character in the implementation-defined character set,
  2058                        ; display x. The effect of EMIT for all other values of x is implementation
  2059                        ; -defined.
  2060                        
  2061 00:0ECC: B5 0E 00                     HEADER  NORMAL
  2062 00:0ECF: 04 45 4D 49                  db      4,"EMIT"
       00:0ED3: 54 
  2063                                        extern  UartTx
  2064                        EMIT:
  2065 00:0ED4: A5 01                        lda     <1                      ; Fetch character from stack
  2066 00:0ED6: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  2067 00:0ED9: 7B                           tdc
  2068 00:0EDA: 1A                           inc     a                       ; Drop the character
  2069 00:0EDB: 1A                           inc     a
  2070 00:0EDC: 5B                           tcd
  2071 00:0EDD: 4C 3C 0D                     jmp     NEXT                    ; Done
  2072                        
  2073                        ; KEY ( -- char )
  2074                        ;
  2075                        ; Receive one character char, a member of the implementation-defined character
  2076                        ; set. Keyboard events that do not correspond to such characters are discarded
  2077                        ; until a valid character is received, and those events are subsequently
  2078                        ; unavailable.
  2079                        ;
  2080                        ; All standard characters can be received. Characters received by KEY are not
  2081                        ; displayed.
  2082                        
  2083 00:0EE0: CC 0E 00                     HEADER  NORMAL
  2084 00:0EE3: 03 4B 45 59                  db      3,"KEY"
  2085                                        extern  UartRx
  2086                        KEY:
  2087 00:0EE7: 20 xx xx                     jsr     UartRx                  ; Receive a character
  2088 00:0EEA: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  2089 00:0EED: AA                           tax
  2090 00:0EEE: 7B                           tdc
  2091 00:0EEF: 3A                           dec     a                       ; And push to stack
  2092 00:0EF0: 3A                           dec     a
  2093 00:0EF1: 5B                           tcd
  2094 00:0EF2: 86 01                        stx     <1
  2095 00:0EF4: 4C 3C 0D                     jmp     NEXT                    ; Done
  2096                        
  2097                        ; SPACE ( -- )
  2098                        ;
  2099                        ; Display one space.
  2100                        ;
  2101                        ; In this implementation it is defined as
  2102                        ;
  2103                        ;   SPACE EMIT
  2104                        
  2105 00:0EF7: E0 0E 00                     HEADER  NORMAL
  2106 00:0EFA: 05 53 50 41                  db      5,"SPACE"
       00:0EFE: 43 45 
  2107 00:0F00: 20 38 0D     SPACE:          jsr     DO_COLON
  2108 00:0F03: 10 05                        dw      BL
  2109 00:0F05: D4 0E                        dw      EMIT
  2110 00:0F07: 60 0A                        dw      EXIT
  Thu Feb 11 2016 20:45                                                                                                    Page 42


  2111                        
  2112                        ; SPACES ( n -- )
  2113                        ;
  2114                        ; If n is greater than zero, display n spaces.
  2115                        ;
  2116                        ; In this implementation it is defined as
  2117                        ;
  2118                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  2119                        
  2120 00:0F09: F7 0E 00                     HEADER  NORMAL
  2121 00:0F0C: 06 53 50 41                  db      6,"SPACES"
       00:0F10: 43 45 53 
  2122 00:0F13: 20 38 0D     SPACES:         jsr     DO_COLON
  2123 00:0F16: 21 07 21 09  SPACES_1:       dw      DUP,ZERO_GREATER,QUERY_BRANCH,SPACES_2
       00:0F1A: D1 0D 26 0F 
  2124 00:0F1E: 00 0F 5A 08                  dw      SPACE,ONE_MINUS,BRANCH,SPACES_1
       00:0F22: BF 0D 16 0F 
  2125 00:0F26: 13 07 60 0A  SPACES_2:       dw      DROP,EXIT
  2126                        
  2127                        ; TYPE ( c-addr u -- )
  2128                        ;
  2129                        ; If u is greater than zero, display the character string specified by c-addr
  2130                        ; and u.
  2131                        ;
  2132                        ; In this implementation it is defined as
  2133                        ;
  2134                        ;   ?DUP IF
  2135                        ;     OVER + SWAP DO I C@ EMIT LOOP
  2136                        ;   ELSE DROP THEN
  2137                        
  2138 00:0F2A: 09 0F 00                     HEADER  NORMAL
  2139 00:0F2D: 04 54 59 50                  db      4,"TYPE"
       00:0F31: 45 
  2140 00:0F32: 20 38 0D     TYPE:           jsr     DO_COLON
  2141 00:0F35: 04 07 D1 0D                  dw      QUERY_DUP,QUERY_BRANCH,TYPE_2
       00:0F39: 51 0F 
  2142 00:0F3B: 41 07 28 08                  dw      OVER,PLUS,SWAP,DO_DO
       00:0F3F: 54 07 A3 0D 
  2143 00:0F43: DF 07 27 06  TYPE_1:         dw      I,C_FETCH,EMIT,DO_LOOP,TYPE_1
       00:0F47: D4 0E 2A 0E 
       00:0F4B: 43 0F 
  2144 00:0F4D: BF 0D 53 0F                  dw      BRANCH,TYPE_3
  2145 00:0F51: 13 07        TYPE_2          dw      DROP
  2146 00:0F53: 60 0A        TYPE_3          dw      EXIT
  2147                        
  2148                        ;================================================================================
  2149                        ;--------------------------------------------------------------------------------
  2150                        
  2151                        ; #
  2152                        ; #>
  2153                        ; #S
  2154                        ; SIGN
  2155                        
  2156                        ;================================================================================
  2157                        ;--------------------------------------------------------------------------------
  2158                        
  2159                                        TRAILER
  2160                        NEXT_WORD:
  Thu Feb 11 2016 20:45                                                                                                    Page 43


  2161                        
  2162                                        end


      Lines assembled: 2802
      Errors: 0
