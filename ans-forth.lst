  Sun Apr 17 2016  0:51                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The Forth data stack is DP
    27                        ;
    28                        ; The Y register holds the forth instruction pointer and the direct page
    29                        ; register is used to access the word address pointer and user variables.
    30                        ;
    31                        ; Some of the high-level definitions are based on Bradford J. Rodriguez's
    32                        ; CamelForth implementations.
    33                        ;
    34                        ;------------------------------------------------------------------------------
    35                        
    36                                        pw      132
    37                                        inclist on
    38                                        maclist off
    39                        
    40                                        chip    65816
    41                                        longi   off
    42                                        longa   off
    43                        
    44                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
     7                        ;
     8                        ; Western Design Center W65C816 device definitions                                          
  Sun Apr 17 2016  0:51                                                                                                    Page 2


     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;===============================================================================
    25                        ; Revision History:
    26                        ;
    27                        ; 2015-12-18 AJ Initial version
    28                        ;-------------------------------------------------------------------------------
    29                        ; $Id$
    30                        ;-------------------------------------------------------------------------------
    31                        
    32                        ;==============================================================================
    33                        ; Status Register Bits
    34                        ;------------------------------------------------------------------------------
    35                        
    36             00000080   N_FLAG          equ     1<<7
    37             00000040   V_FLAG          equ     1<<6
    38             00000020   M_FLAG          equ     1<<5
    39             00000010   X_FLAG          equ     1<<4
    40             00000010   B_FLAG          equ     1<<4
    41             00000008   D_FLAG          equ     1<<3
    42             00000004   I_FLAG          equ     1<<2
    43             00000002   Z_FLAG          equ     1<<1
    44             00000001   C_FLAG          equ     1<<0
    45                        
    46                        ;==============================================================================
    47                        ; Macros
    48                        ;------------------------------------------------------------------------------
    49                        
    50                        ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
    51                        ; is fixed at $0100-$01ff. 
    52                        
    53                        emulate         macro
    54                                        sec
    55                                        xce
    56                                        endm
    57                        
    58                        ; Puts the processor in native mode. The size of the memory and index register
    59                        ; operations is not controlled by the M & X bits in the status register.
    60                        
    61                        native          macro
    62                                        clc
    63                                        xce
    64                                        endm
    65                        
    66                        ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
  Sun Apr 17 2016  0:51                                                                                                    Page 3


    67                         
    68                        long_a          macro
    69                                        rep     #M_FLAG
    70                                        longa   on
    71                                        endm
    72                        
    73                        ; Resets the X bit making the index registers 16-bits wide
    74                        
    75                        long_i          macro
    76                                        rep     #X_FLAG
    77                                        longi   on
    78                                        endm
    79                        
    80                        ; Resets the M and X bits making the accumulator, memory accesses and index
    81                        ; registers 16-bits wide.
    82                                        
    83                        long_ai         macro
    84                                        rep     #M_FLAG|X_FLAG
    85                                        longa   on
    86                                        longi   on
    87                                        endm
    88                        
    89                        ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
    90                        
    91                        short_a         macro
    92                                        sep     #M_FLAG
    93                                        longa   off
    94                                        endm
    95                        
    96                        ; Sets the X bit making the index registers 8-bits wide.
    97                        
    98                        short_i         macro
    99                                        sep     #X_FLAG
   100                                        longi   off
   101                                        endm
   102                                        
   103                        ; Sets the M & X bits making the accumulator, memory accesses and index
   104                        ; registers 8-bits wide.
   105                        
   106                        short_ai        macro
   107                                        sep     #M_FLAG|X_FLAG
   108                                        longa   off
   109                                        longi   off
   110                                        endm
    45                        
    46                        ;==============================================================================
    47                        ; Macros
    48                        ;------------------------------------------------------------------------------
    49                        
    50                        ; The LINK macro deposits the link section of a word header automatically
    51                        ; linking the new word to the last.
    52                        
    53             00000000   WORDZ           set     0                       ; Word counter
    54             00000000   WORD0           equ     0                       ; Null address for first word
    55                        
    56                        LINK            macro   TYPE
    57                                        dw      WORD@<WORDZ>            ; Link
    58                                        db      TYPE                    ; Type
  Sun Apr 17 2016  0:51                                                                                                    Page 4


    59                        WORDZ           set     WORDZ+1
    60                        WORD@<WORDZ>:
    61                                        endm
    62                        
    63                        ; Deposits a word header containing the name which is linked back to the
    64                        ; previous word.
    65                        ;
    66                        ; The WDC assembler does not handle string parameters to macros very well,
    67                        ; stopping at the first comma or space in them, so some headers must be
    68                        ; manually constructed.
    69                        
    70             00000000   NORMAL          equ     $00
    71             00000080   IMMEDIATE       equ     $80
    72                        
    73                        HEADER          macro   LEN,NAME,TYPE
    74                                        LINK    TYPE
    75                                        db      LEN,NAME
    76                                        endm
    77                        
    78                        ; The CONTINUE macro is used at the end of a native word to invoke the next
    79                        ; word pointer.
    80                        
    81                        CONTINUE        macro
    82                                        tyx                             ; Copy IP to X
    83                                        iny
    84                                        iny
    85                                        jmp     (0,x)                   ; Then execute word
    86                                        endm
    87                        
    88                        TRAILER         macro
    89                        LAST_WORD       equ     WORD@<WORDZ>
    90                                        endm
    91                        
    92                        ;==============================================================================
    93                        ; Definitions
    94                        ;------------------------------------------------------------------------------
    95                        
    96             00000014   USER_SIZE       equ     20
    97             00000080   DSTACK_SIZE     equ     128
    98             00000080   RSTACK_SIZE     equ     128
    99                        
   100             00000000   TO_IN_OFFSET    equ     0
   101             00000002   BASE_OFFSET     equ     2
   102             00000004   BLK_OFFSET      equ     4
   103             00000006   DP_OFFSET       equ     6
   104             00000008   LATEST_OFFSET   equ     8
   105             0000000A   SCR_OFFSET      equ     10
   106             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
   107             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
   108             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
   109             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
   110                        
   111             00000080   TIB_SIZE        equ     128
   112                        
   113                        ;==============================================================================
   114                        ; Data Areas
   115                        ;------------------------------------------------------------------------------
   116                        
  Sun Apr 17 2016  0:51                                                                                                    Page 5


   117                                        page0
   118                                        org     $00
   119                        
   120 00:0000:              USER_AREA       ds      USER_SIZE               ; User Variables
   121                        
   122                        
   123             00000100   DSTACK_START    equ     $0100
   124             00000180   DSTACK_END      equ     DSTACK_START+DSTACK_SIZE
   125                        
   126             00000180   RSTACK_START    equ     $0180
   127             00000200   RSTACK_END      equ     RSTACK_START+RSTACK_SIZE
   128                        
   129                        
   130                                        data
   131                                        org     $0200
   132                        
   133 00:0200:              TIB_AREA        ds      TIB_SIZE                ; Terminal Input Buffer
   134                        
   135                        ;==============================================================================
   136                        ; Forth Entry Point
   137                        ;------------------------------------------------------------------------------
   138                        
   139                        FORTH           section OFFSET $0400
   140                        
   141                                        public  Start
   142                        Start:
   143 00:0400: 18 FB                        native                          ; Go to native mode
   144 00:0402: C2 30                        long_ai                         ; And all 16-bit registers
   145 00:0404: A9 FF 01                     lda     #RSTACK_END-1           ; Initialise return stack
   146 00:0407: 1B                           tcs
   147 00:0408: A9 7F 01                     lda     #DSTACK_END-1           ; .. and data stack
   148 00:040B: 5B                           tcd
   149                        
   150 00:040C: A0 15 04                     ldy     #COLD                   ; Then perform COLD start
   151 00:040F: BB C8 C8 7C                  CONTINUE
       00:0413: 00 00 
   152                        
   153                        COLD:
   154 00:0415: 47 05                        dw      DECIMAL
   155 00:0417: F0 04                        dw      ZERO
   156 00:0419: 70 04                        dw      BLK
   157 00:041B: 6D 05                        dw      STORE
   158 00:041D: 1A 05                        dw      FALSE
   159 00:041F: DA 04                        dw      STATE
   160 00:0421: 6D 05                        dw      STORE
   161 00:0423: BA 13                        dw      DO_LITERAL
   162 00:0425: B1 17                        dw      NEXT_WORD
   163 00:0427: 8C 04                        dw      DP
   164 00:0429: 6D 05                        dw      STORE
   165 00:042B: BA 13                        dw      DO_LITERAL
   166 00:042D: 59 17                        dw      LAST_WORD
   167 00:042F: 9B 04                        dw      LATEST
   168 00:0431: 6D 05                        dw      STORE
   169 00:0433: 26 15                        dw      CR
   170 00:0435: 26 15                        dw      CR
   171 00:0437: 7C 16                        dw      TITLE
   172 00:0439: A3 15                        dw      TYPE
   173 00:043B: 26 15                        dw      CR
  Sun Apr 17 2016  0:51                                                                                                    Page 6


   174 00:043D: 26 15                        dw      CR
   175 00:043F: AC 0C                        dw      ABORT
   176                        
   177                        ;==============================================================================
   178                        ; System/User Variables
   179                        ;------------------------------------------------------------------------------
   180                        
   181                        ; #TIB ( -- a-addr )
   182                        ;
   183                        ; a-addr is the address of a cell containing the number of characters in the
   184                        ; terminal input buffer.
   185                        
   186 00:0441: 00 00 00 04                  HEADER  4,"#TIB",NORMAL
       00:0445: 23 54 49 42 
   187 00:0449: 20 21 13     HASH_TIB:       jsr     DO_CONSTANT
   188 00:044C: 4E 04                        dw      $+2
   189 00:044E: 7E 00                        dw      TIB_SIZE-2
   190                        
   191                        ; >IN ( -- a-addr )
   192                        ;
   193                        ; a-addr is the address of a cell containing the offset in characters from the
   194                        ; start of the input buffer to the start of the parse area.
   195                        
   196 00:0450: 44 04 00 03                  HEADER  3,">IN",NORMAL
       00:0454: 3E 49 4E 
   197 00:0457: 20 93 14     TO_IN:          jsr     DO_USER
   198 00:045A: 00 00                        dw      TO_IN_OFFSET
   199                        
   200                        ; BASE ( -- a-addr )
   201                        ;
   202                        ; a-addr is the address of a cell containing the current number-conversion
   203                        ; radix {{2...36}}.
   204                        
   205 00:045C: 53 04 00 04                  HEADER  4,"BASE",NORMAL
       00:0460: 42 41 53 45 
   206 00:0464: 20 93 14     BASE:           jsr     DO_USER
   207 00:0467: 02 00                        dw      BASE_OFFSET
   208                        
   209                        ; BLK ( -- a-addr )
   210                        ;
   211                        ; a-addr is the address of a cell containing zero or the number of the mass-
   212                        ; storage block being interpreted. If BLK contains zero, the input source is
   213                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   214                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   215                        
   216 00:0469: 5F 04 00 03                  HEADER  3,"BLK",NORMAL
       00:046D: 42 4C 4B 
   217 00:0470: 20 93 14     BLK:            jsr     DO_USER
   218 00:0473: 04 00                        dw      BLK_OFFSET
   219                        
   220                        ; (BUFFER)
   221                        
   222 00:0475: 6C 04 00 08                  HEADER  8,"(BUFFER)",NORMAL
       00:0479: 28 42 55 46 
       00:047D: 46 45 52 29 
   223 00:0481: 20 93 14     BUFFER:         jsr     DO_USER
   224 00:0484: 10 00                        dw      BUFFER_OFFSET
   225                        
  Sun Apr 17 2016  0:51                                                                                                    Page 7


   226                        ; DP ( -- a-addr )
   227                        ;
   228                        ; Dictionary Pointer
   229                        
   230 00:0486: 78 04 00 02                  HEADER  2,"DP",NORMAL
       00:048A: 44 50 
   231 00:048C: 20 93 14     DP:             jsr     DO_USER
   232 00:048F: 06 00                        dw      DP_OFFSET
   233                        
   234                        ; LATEST ( -- a-addr )
   235                        
   236 00:0491: 89 04 00 06                  HEADER  6,"LATEST",NORMAL
       00:0495: 4C 41 54 45 
       00:0499: 53 54 
   237 00:049B: 20 93 14     LATEST:         jsr     DO_USER
   238 00:049E: 08 00                        dw      LATEST_OFFSET
   239                        
   240                        ; (LENGTH)
   241                        
   242 00:04A0: 94 04 00 08                  HEADER  8,"(LENGTH)",NORMAL
       00:04A4: 28 4C 45 4E 
       00:04A8: 47 54 48 29 
   243 00:04AC: 20 93 14     LENGTH:         jsr     DO_USER
   244 00:04AF: 12 00                        dw      LENGTH_OFFSET
   245                        
   246                        ; SCR ( -- a-addr )
   247                        ;
   248                        ; a-addr is the address of a cell containing the block number of the block most
   249                        ; recently LISTed.
   250                        
   251 00:04B1: A3 04 00 03                  HEADER  3,"SCR",NORMAL
       00:04B5: 53 43 52 
   252 00:04B8: 20 93 14     SCR:            jsr     DO_USER
   253 00:04BB: 0A 00                        dw      SCR_OFFSET
   254                        
   255                        ; (SOURCE-ID)
   256                        
   257 00:04BD: B4 04 00 0B                  HEADER  11,"(SOURCE-ID)",NORMAL
       00:04C1: 28 53 4F 55 
       00:04C5: 52 43 45 2D 
       00:04C9: 49 44 29 
   258 00:04CC: 20 93 14     SOURCEID:       jsr     DO_USER
   259 00:04CF: 0C 00                        dw      SOURCEID_OFFSET
   260                        
   261                        ; STATE ( -- a-addr )
   262                        ;
   263                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   264                        ; is true when in compilation state, false otherwise. The true value in STATE
   265                        ; is non-zero, but is otherwise implementation-defined.
   266                        
   267 00:04D1: C0 04 00 05                  HEADER  5,"STATE",NORMAL
       00:04D5: 53 54 41 54 
       00:04D9: 45 
   268 00:04DA: 20 93 14     STATE:          jsr     DO_USER
   269 00:04DD: 0E 00                        dw      STATE_OFFSET
   270                        
   271                        ; TIB ( -- c-addr )
   272                        ;
  Sun Apr 17 2016  0:51                                                                                                    Page 8


   273                        ; c-addr is the address of the terminal input buffer.
   274                        
   275 00:04DF: D4 04 00 03                  HEADER  3,"TIB",NORMAL
       00:04E3: 54 49 42 
   276 00:04E6: 20 21 13     TIB:            jsr     DO_CONSTANT
   277 00:04E9: 00 02                        dw      TIB_AREA
   278                        
   279                        ;==============================================================================
   280                        ; Constants
   281                        ;------------------------------------------------------------------------------
   282                        
   283                        ; 0 ( -- 0 )
   284                        ;
   285                        ; Push the constant value zero on the stack
   286                        
   287 00:04EB: E2 04 00 01                  HEADER  1,"0",NORMAL
       00:04EF: 30 
   288                        ZERO:
   289 00:04F0: 7B                           tdc
   290 00:04F1: 3A                           dec     a                       ; Make space on the stack
   291 00:04F2: 3A                           dec     a
   292 00:04F3: 5B                           tcd
   293 00:04F4: 64 01                        stz     <1                      ; And create a zero value
   294 00:04F6: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04FA: 00 00 
   295                        
   296                        ; BL ( -- char )
   297                        ;
   298                        ; char is the character value for a space.
   299                        
   300 00:04FC: EE 04 00 02                  HEADER  2,"BL",NORMAL
       00:0500: 42 4C 
   301                        BL:
   302 00:0502: 7B                           tdc
   303 00:0503: 3A                           dec     a                       ; Make space on the stack
   304 00:0504: 3A                           dec     a
   305 00:0505: 5B                           tcd
   306 00:0506: A9 20 00                     lda     #' '                    ; And save a space value
   307 00:0509: 85 01                        sta     <1
   308 00:050B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:050F: 00 00 
   309                        
   310                        ; FALSE ( -- false )
   311                        ;
   312                        ; Return a false flag.
   313                        
   314 00:0511: FF 04 00 05                  HEADER  5,"FALSE",NORMAL
       00:0515: 46 41 4C 53 
       00:0519: 45 
   315                        FALSE:
   316 00:051A: 7B                           tdc
   317 00:051B: 3A                           dec     a                       ; Make space on the stack
   318 00:051C: 3A                           dec     a
   319 00:051D: 5B                           tcd
   320 00:051E: 64 01                        stz     <1                      ; And create a false value
   321 00:0520: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0524: 00 00 
   322                        
  Sun Apr 17 2016  0:51                                                                                                    Page 9


   323                        ; TRUE ( -- true )
   324                        ;
   325                        ; Return a true flag, a single-cell value with all bits set.
   326                        
   327 00:0526: 14 05 00 04                  HEADER  4,"TRUE",NORMAL
       00:052A: 54 52 55 45 
   328                        TRUE:
   329 00:052E: 7B                           tdc
   330 00:052F: 3A                           dec     a                       ; Make space on the stack
   331 00:0530: 3A                           dec     a
   332 00:0531: 5B                           tcd
   333 00:0532: 64 01                        stz     <1                      ; And create a true value
   334 00:0534: C6 01                        dec     <1
   335 00:0536: BB C8 C8 7C                  CONTINUE                        ; Done
       00:053A: 00 00 
   336                        
   337                        ;==============================================================================
   338                        ; Radix
   339                        ;------------------------------------------------------------------------------
   340                        
   341                        ; DECIMAL ( -- )
   342                        ;
   343                        ; Set the numeric conversion radix to ten (decimal).
   344                        
   345 00:053C: 29 05 00 07                  HEADER  7,"DECIMAL",NORMAL
       00:0540: 44 45 43 49 
       00:0544: 4D 41 4C 
   346 00:0547: 20 B6 12     DECIMAL:        jsr     DO_COLON
   347 00:054A: BA 13 0A 00                  dw      DO_LITERAL,10
   348 00:054E: 64 04                        dw      BASE
   349 00:0550: 6D 05                        dw      STORE
   350 00:0552: 1A 0D                        dw      EXIT
   351                        
   352                        ; HEX ( -- )
   353                        ;
   354                        ; Set contents of BASE to sixteen.
   355                        
   356 00:0554: 3F 05 00 03                  HEADER  3,"HEX",NORMAL
       00:0558: 48 45 58 
   357 00:055B: 20 B6 12     HEX:            jsr     DO_COLON
   358 00:055E: BA 13 10 00                  dw      DO_LITERAL,16
   359 00:0562: 64 04                        dw      BASE
   360 00:0564: 6D 05                        dw      STORE
   361 00:0566: 1A 0D                        dw      EXIT
   362                        
   363                        ;==============================================================================
   364                        ; Memory Operations
   365                        ;------------------------------------------------------------------------------
   366                        
   367                        ; ! ( x a-addr -- )
   368                        ;
   369                        ; Store x at a-addr.
   370                        
   371 00:0568: 57 05 00 01                  HEADER  1,"!",NORMAL
       00:056C: 21 
   372                        STORE:
   373 00:056D: A5 03                        lda     <3                      ; Fetch data value
   374 00:056F: 92 01                        sta     (1)                     ; .. and store
  Sun Apr 17 2016  0:51                                                                                                    Page 10


   375 00:0571: 7B                           tdc                             ; Clean up data stack
   376 00:0572: 1A                           inc     a
   377 00:0573: 1A                           inc     a
   378 00:0574: 1A                           inc     a
   379 00:0575: 1A                           inc     a
   380 00:0576: 5B                           tcd
   381 00:0577: BB C8 C8 7C                  CONTINUE                        ; Done
       00:057B: 00 00 
   382                        
   383                        ; +! ( n|u a-addr -- )
   384                        ;
   385                        ; Add n|u to the single-cell number at a-addr.
   386                        
   387 00:057D: 6B 05 00 02                  HEADER  2,"+!",NORMAL
       00:0581: 2B 21 
   388                        PLUS_STORE:
   389 00:0583: 18                           clc
   390 00:0584: A5 03                        lda     <3                      ; Fetch data value
   391 00:0586: 72 01                        adc     (1)
   392 00:0588: 92 01                        sta     (1)
   393 00:058A: 7B                           tdc                             ; Clean up data stack
   394 00:058B: 1A                           inc     a
   395 00:058C: 1A                           inc     a
   396 00:058D: 1A                           inc     a
   397 00:058E: 1A                           inc     a
   398 00:058F: 5B                           tcd
   399 00:0590: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0594: 00 00 
   400                        
   401                        ; , ( x -- )
   402                        ;
   403                        ; Reserve one cell of data space and store x in the cell. If the data-space
   404                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   405                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   406                        ; is not aligned prior to execution of ,.
   407                        ;
   408                        ;   HERE ! 1 CELLS ALLOT
   409                        
   410 00:0596: 80 05 00                     LINK    NORMAL
   411 00:0599: 01 2C                        db      1,","
   412 00:059B: 20 B6 12     COMMA:          jsr     DO_COLON
   413 00:059E: 46 06                        dw      HERE
   414 00:05A0: 6D 05                        dw      STORE
   415 00:05A2: BA 13 01 00                  dw      DO_LITERAL,1
   416 00:05A6: 8B 06                        dw      CELLS
   417 00:05A8: EE 05                        dw      ALLOT
   418 00:05AA: 1A 0D                        dw      EXIT
   419                        
   420                        ; 2! ( x1 x2 a-addr -- )
   421                        ;
   422                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   423                        ; consecutive cell. It is equivalent to the sequence SWAP OVER ! CELL+ !.
   424                        
   425 00:05AC: 99 05 00 02                  HEADER  2,"2!",NORMAL
       00:05B0: 32 21 
   426 00:05B2: 20 B6 12     TWO_STORE:      jsr     DO_COLON
   427 00:05B5: D4 07                        dw      SWAP
   428 00:05B7: B0 07                        dw      OVER
  Sun Apr 17 2016  0:51                                                                                                    Page 11


   429 00:05B9: 6D 05                        dw      STORE
   430 00:05BB: 78 06                        dw      CELL_PLUS
   431 00:05BD: 6D 05                        dw      STORE
   432 00:05BF: 1A 0D                        dw      EXIT
   433                        
   434                        ; 2@ ( a-addr -- x1 x2 )
   435                        ;
   436                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   437                        ; the next consecutive cell. It is equivalent to the sequence DUP CELL+ @ SWAP
   438                        ; @.
   439                        
   440 00:05C1: AF 05 00 02                  HEADER  2,"2@",NORMAL
       00:05C5: 32 40 
   441 00:05C7: 20 B6 12     TWO_FETCH:      jsr     DO_COLON
   442 00:05CA: 8D 07                        dw      DUP
   443 00:05CC: 78 06                        dw      CELL_PLUS
   444 00:05CE: DB 05                        dw      FETCH
   445 00:05D0: D4 07                        dw      SWAP
   446 00:05D2: DB 05                        dw      FETCH
   447 00:05D4: 1A 0D                        dw      EXIT
   448                        
   449                        ; @ ( a-addr -- x )
   450                        ;
   451                        ; x is the value stored at a-addr.
   452                        
   453 00:05D6: C4 05 00 01                  HEADER  1,"@",NORMAL
       00:05DA: 40 
   454                        FETCH:
   455 00:05DB: B2 01                        lda     (1)                     ; Fetch from memory
   456 00:05DD: 85 01                        sta     <1                      ; .. and replace top value
   457 00:05DF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05E3: 00 00 
   458                        
   459                        ; ALLOT ( n -- )
   460                        ;
   461                        ; If n is greater than zero, reserve n address units of data space. If n is
   462                        ; less than zero, release |n| address units of data space. If n is zero, leave
   463                        ; the data-space pointer unchanged.
   464                        ;
   465                        ; In this implementation its is defined as:
   466                        ;
   467                        ;   DP +!
   468                        
   469 00:05E5: D9 05 00 05                  HEADER  5,"ALLOT",NORMAL
       00:05E9: 41 4C 4C 4F 
       00:05ED: 54 
   470 00:05EE: 20 B6 12     ALLOT:          jsr     DO_COLON
   471 00:05F1: 8C 04                        dw      DP
   472 00:05F3: 83 05                        dw      PLUS_STORE
   473 00:05F5: 1A 0D                        dw      EXIT
   474                        
   475                        ; C! ( char c-addr -- )
   476                        ;
   477                        ; Store char at c-addr. When character size is smaller than cell size, only the
   478                        ; number of low-order bits corresponding to character size are transferred.
   479                        
   480 00:05F7: E8 05 00 02                  HEADER  2,"C!",NORMAL
       00:05FB: 43 21 
  Sun Apr 17 2016  0:51                                                                                                    Page 12


   481                        C_STORE:
   482 00:05FD: A5 03                        lda     <3                      ; Fetch the data value
   483 00:05FF: E2 20                        short_a
   484 00:0601: 92 01                        sta     (1)                     ; And store it
   485 00:0603: C2 20                        long_a
   486 00:0605: 7B                           tdc                             ; Clean up the stack
   487 00:0606: 1A                           inc     a
   488 00:0607: 1A                           inc     a
   489 00:0608: 1A                           inc     a
   490 00:0609: 1A                           inc     a
   491 00:060A: 5B                           tcd
   492 00:060B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:060F: 00 00 
   493                        
   494                        ; C, ( char -- )
   495                        ;
   496                        ; Reserve space for one character in the data space and store char in the
   497                        ; space. If the data-space pointer is character aligned when C, begins
   498                        ; execution, it will remain character aligned when C, finishes execution.
   499                        ; An ambiguous condition exists if the data-space pointer is not character-
   500                        ; aligned prior to execution of C,
   501                        ;
   502                        ;   HERE C! 1 CHARS ALLOT
   503                        
   504 00:0611: FA 05 00                     LINK    NORMAL
   505 00:0614: 02 43 2C                     db      2,"C,"
   506 00:0617: 20 B6 12     C_COMMA:        jsr     DO_COLON
   507 00:061A: 46 06                        dw      HERE
   508 00:061C: FD 05                        dw      C_STORE
   509 00:061E: BA 13 01 00                  dw      DO_LITERAL,1
   510 00:0622: BE 06                        dw      CHARS
   511 00:0624: EE 05                        dw      ALLOT
   512 00:0626: 1A 0D                        dw      EXIT
   513                        
   514                        ; C@ ( c-addr -- char )
   515                        ;
   516                        ; Fetch the character stored at c-addr. When the cell size is greater than
   517                        ; character size, the unused high-order bits are all zeroes.
   518                        
   519 00:0628: 14 06 00 02                  HEADER  2,"C@",NORMAL
       00:062C: 43 40 
   520                        C_FETCH:
   521 00:062E: E2 20                        short_a
   522 00:0630: B2 01                        lda     (1)                     ; Fetch the data byte
   523 00:0632: 85 01                        sta     <1                      ; .. and replace stack value
   524 00:0634: 64 02                        stz     <2
   525 00:0636: C2 20                        long_a
   526 00:0638: BB C8 C8 7C                  CONTINUE                        ; Done
       00:063C: 00 00 
   527                        
   528                        ; HERE ( -- addr )
   529                        ;
   530                        ; addr is the data-space pointer.
   531                        
   532 00:063E: 2B 06 00 04                  HEADER  4,"HERE",NORMAL
       00:0642: 48 45 52 45 
   533 00:0646: 20 B6 12     HERE:           jsr     DO_COLON
   534 00:0649: 8C 04                        dw      DP
  Sun Apr 17 2016  0:51                                                                                                    Page 13


   535 00:064B: DB 05                        dw      FETCH
   536 00:064D: 1A 0D                        dw      EXIT
   537                        
   538                        ;==============================================================================
   539                        ; Alignment
   540                        ;------------------------------------------------------------------------------
   541                        
   542                        ; ALIGN ( -- )
   543                        ;
   544                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   545                        
   546 00:064F: 41 06 00 05                  HEADER  5,"ALIGN",NORMAL
       00:0653: 41 4C 49 47 
       00:0657: 4E 
   547                        ALIGN:
   548 00:0658: BB C8 C8 7C                  CONTINUE                        ; Done
       00:065C: 00 00 
   549                        
   550                        ; ALIGNED ( addr -- a-addr )
   551                        ;
   552                        ; a-addr is the first aligned address greater than or equal to addr.
   553                        
   554 00:065E: 52 06 00 07                  HEADER  7,"ALIGNED",NORMAL
       00:0662: 41 4C 49 47 
       00:0666: 4E 45 44 
   555                        ALIGNED:
   556 00:0669: BB C8 C8 7C                  CONTINUE                        ; Done
       00:066D: 00 00 
   557                        
   558                        ; CELL+ ( a-addr1 -- a-addr2 )
   559                        ;
   560                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   561                        
   562 00:066F: 61 06 00 05                  HEADER  5,"CELL+",NORMAL
       00:0673: 43 45 4C 4C 
       00:0677: 2B 
   563                        CELL_PLUS:
   564 00:0678: E6 01                        inc     <1                      ; Bump the address by two
   565 00:067A: E6 01                        inc     <1
   566 00:067C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0680: 00 00 
   567                        
   568                        ; CELLS ( n1 -- n2 )
   569                        ;
   570                        ; n2 is the size in address units of n1 cells.
   571                        
   572 00:0682: 72 06 00 05                  HEADER  5,"CELLS",NORMAL
       00:0686: 43 45 4C 4C 
       00:068A: 53 
   573                        CELLS:
   574 00:068B: 06 01                        asl     <1                      ; Two bytes per cell
   575 00:068D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0691: 00 00 
   576                        
   577                        ; CHAR+ ( c-addr1 -- c-addr2 )
   578                        ;
   579                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
   580                        
  Sun Apr 17 2016  0:51                                                                                                    Page 14


   581 00:0693: 85 06 00 05                  HEADER  5,"CHAR+",NORMAL
       00:0697: 43 48 41 52 
       00:069B: 2B 
   582                        CHAR_PLUS:
   583 00:069C: E6 01                        inc     <1                      ; Bump the address by one
   584 00:069E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06A2: 00 00 
   585                        
   586                        ; CHAR- ( c-addr1 -- c-addr2 )
   587                        ;
   588                        ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
   589                        
   590 00:06A4: 96 06 00 05                  HEADER  5,"CHAR-",NORMAL
       00:06A8: 43 48 41 52 
       00:06AC: 2D 
   591                        CHAR_MINUS:
   592 00:06AD: C6 01                        dec     <1
   593 00:06AF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06B3: 00 00 
   594                        
   595                        ; CHARS ( n1 -- n2 )
   596                        ;
   597                        ; n2 is the size in address units of n1 characters.
   598                        
   599 00:06B5: A7 06 00 05                  HEADER  5,"CHARS",NORMAL
       00:06B9: 43 48 41 52 
       00:06BD: 53 
   600                        CHARS:
   601 00:06BE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06C2: 00 00 
   602                        
   603                        ;==============================================================================
   604                        ; Stack Operations
   605                        ;------------------------------------------------------------------------------
   606                        
   607                        ; 2DROP ( x1 x2 -- )
   608                        ;
   609                        ; Drop cell pair x1 x2 from the stack.
   610                        
   611 00:06C4: B8 06 00 05                  HEADER  5,"2DROP",NORMAL
       00:06C8: 32 44 52 4F 
       00:06CC: 50 
   612                        TWO_DROP:
   613 00:06CD: 7B                           tdc                             ; Removed two words from stack
   614 00:06CE: 1A                           inc     a
   615 00:06CF: 1A                           inc     a
   616 00:06D0: 1A                           inc     a
   617 00:06D1: 1A                           inc     a
   618 00:06D2: 5B                           tcd
   619 00:06D3: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06D7: 00 00 
   620                        
   621                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   622                        ;
   623                        ; Duplicate cell pair x1 x2.
   624                        
   625 00:06D9: C7 06 00 04                  HEADER  4,"2DUP",NORMAL
       00:06DD: 32 44 55 50 
  Sun Apr 17 2016  0:51                                                                                                    Page 15


   626                        TWO_DUP:
   627 00:06E1: 7B                           tdc                             ; Make space for new value
   628 00:06E2: 3A                           dec     a
   629 00:06E3: 3A                           dec     a
   630 00:06E4: 3A                           dec     a
   631 00:06E5: 3A                           dec     a
   632 00:06E6: 5B                           tcd
   633 00:06E7: A5 05                        lda     <5                      ; Copy top two values
   634 00:06E9: 85 01                        sta     <1
   635 00:06EB: A5 07                        lda     <7
   636 00:06ED: 85 03                        sta     <3
   637 00:06EF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06F3: 00 00 
   638                        
   639                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   640                        ;
   641                        ; Copy cell pair x1 x2 to the top of the stack.
   642                        
   643 00:06F5: DC 06 00 05                  HEADER  5,"2OVER",NORMAL
       00:06F9: 32 4F 56 45 
       00:06FD: 52 
   644                        TWO_OVER:
   645 00:06FE: 7B                           tdc                             ; Make space for new value
   646 00:06FF: 3A                           dec     a
   647 00:0700: 3A                           dec     a
   648 00:0701: 3A                           dec     a
   649 00:0702: 3A                           dec     a
   650 00:0703: 5B                           tcd
   651 00:0704: A5 09                        lda     <9                      ; Ciopy top two values
   652 00:0706: 85 01                        sta     <1
   653 00:0708: A5 0B                        lda     <11
   654 00:070A: 85 03                        sta     <3
   655 00:070C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0710: 00 00 
   656                        
   657                        ; 2ROT ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
   658                        ;
   659                        ; Rotate the top three cell pairs on the stack bringing cell pair x1 x2 to
   660                        ; the top of the stack.
   661                        
   662 00:0712: F8 06 00 04                  HEADER  4,"2ROT",NORMAL
       00:0716: 32 52 4F 54 
   663 00:071A: 20 B6 12     TWO_ROT:        jsr     DO_COLON
   664 00:071D: A5 0B                        lda     <11                     ; Save x1
   665 00:071F: 48                           pha
   666 00:0720: A5 09                        lda     <9                      ; Save x2
   667 00:0722: 48                           pha
   668 00:0723: A5 07                        lda     <7                      ; Move x3
   669 00:0725: 85 0B                        sta     <11
   670 00:0727: A5 05                        lda     <5                      ; Move x4
   671 00:0729: 85 09                        sta     <9
   672 00:072B: A5 03                        lda     <3                      ; Move x5
   673 00:072D: 85 07                        sta     <7
   674 00:072F: A5 01                        lda     <1                      ; Move x6
   675 00:0731: 85 05                        sta     <5
   676 00:0733: 68                           pla                             ; Restore x2
   677 00:0734: 85 01                        sta     <1
   678 00:0736: 68                           pla                             ; Restore x1
  Sun Apr 17 2016  0:51                                                                                                    Page 16


   679 00:0737: 85 03                        sta     <3
   680 00:0739: BB C8 C8 7C                  CONTINUE                        ; Done
       00:073D: 00 00 
   681                        
   682                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   683                        ;
   684                        ; Exchange the top two cell pairs.
   685                        
   686 00:073F: 15 07 00 05                  HEADER  5,"2SWAP",NORMAL
       00:0743: 32 53 57 41 
       00:0747: 50 
   687                        TWO_SWAP:
   688 00:0748: A5 03                        lda     <3                      ; Save x3
   689 00:074A: 48                           pha
   690 00:074B: A5 01                        lda     <1                      ; Save x4
   691 00:074D: 48                           pha
   692 00:074E: A5 07                        lda     <7                      ; Move x1
   693 00:0750: 85 03                        sta     <3
   694 00:0752: A5 05                        lda     <5                      ; Move x2
   695 00:0754: 85 01                        sta     <1
   696 00:0756: 68                           pla                             ; Move x4
   697 00:0757: 85 05                        sta     <5
   698 00:0759: 68                           pla                             ; Move x3
   699 00:075A: 85 07                        sta     <7
   700 00:075C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0760: 00 00 
   701                        
   702                        ; ?DUP ( x -- 0 | x x )
   703                        ;
   704                        ; Duplicate x if it is non-zero.
   705                        
   706 00:0762: 42 07 00 04                  HEADER  4,"?DUP",NORMAL
       00:0766: 3F 44 55 50 
   707                        QUERY_DUP:
   708 00:076A: A5 01                        lda     <1                      ; Fetch top value
   709 00:076C: D0 1F                        bne     DUP                     ; Non-zero value?
   710 00:076E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0772: 00 00 
   711                        
   712                        ; DROP ( x -- )
   713                        ;
   714                        ; Remove x from the stack.
   715                        
   716 00:0774: 65 07 00 04                  HEADER  4,"DROP",NORMAL
       00:0778: 44 52 4F 50 
   717                        DROP:
   718 00:077C: 7B                           tdc                             ; Drop the top value
   719 00:077D: 1A                           inc     a
   720 00:077E: 1A                           inc     a
   721 00:077F: 5B                           tcd
   722 00:0780: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0784: 00 00 
   723                        
   724                        ; DUP ( x -- x x )
   725                        ;
   726                        ; Duplicate x.
   727                        
   728 00:0786: 77 07 00 03                  HEADER  3,"DUP",NORMAL
  Sun Apr 17 2016  0:51                                                                                                    Page 17


       00:078A: 44 55 50 
   729                        DUP:
   730 00:078D: 7B                           tdc
   731 00:078E: 3A                           dec     a
   732 00:078F: 3A                           dec     a
   733 00:0790: 5B                           tcd
   734 00:0791: A5 03                        lda     <3                      ; Fetch top value
   735 00:0793: 85 01                        sta     <1                      ; And make a copy
   736 00:0795: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0799: 00 00 
   737                        
   738                        ; NIP ( x1 x2 -- x2 )
   739                        ;
   740                        ; Drop the first item below the top of stack.
   741                        
   742 00:079B: 89 07 00 03                  HEADER  3,"NIP",NORMAL
       00:079F: 4E 49 50 
   743                        NIP:
   744 00:07A2: A5 01                        lda     <1                      ; Copy x2 over x1
   745 00:07A4: 85 03                        sta     <3
   746 00:07A6: 80 D4                        bra     DROP
   747                        
   748                        ; OVER ( x1 x2 -- x1 x2 x1 )
   749                        ;
   750                        ; Place a copy of x1 on top of the stack.
   751                        
   752 00:07A8: 9E 07 00 04                  HEADER  4,"OVER",NORMAL
       00:07AC: 4F 56 45 52 
   753                        OVER:
   754 00:07B0: 7B                           tdc
   755 00:07B1: 3A                           dec     a
   756 00:07B2: 3A                           dec     a
   757 00:07B3: 5B                           tcd
   758 00:07B4: A5 05                        lda     <5                      ; Fetch second value
   759 00:07B6: 85 01                        sta     <1                      ; And make a copy
   760 00:07B8: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07BC: 00 00 
   761                        
   762                        ; PICK ( xu ... x1 x0 u -- xu ... x1 x0 xu )
   763                        ;
   764                        ; Remove u. Copy the xu to the top of the stack. An ambiguous condition exists
   765                        ; if there are less than u+2 items on the stack before PICK is executed.
   766                        
   767                        ; TODO
   768 00:07BE: AB 07 00 04                  HEADER  4,"PICK",NORMAL
       00:07C2: 50 49 43 4B 
   769                        PICK:
   770 00:07C6: BB C8 C8 7C                  CONTINUE
       00:07CA: 00 00 
   771                        
   772                        ; SWAP ( x1 x2 -- x2 x1 )
   773                        ;
   774                        ; Exchange the top two stack items.
   775                        
   776 00:07CC: C1 07 00 04                  HEADER  4,"SWAP",NORMAL
       00:07D0: 53 57 41 50 
   777                        SWAP:
   778 00:07D4: A5 01                        lda     <1                      ; Switch top two words
  Sun Apr 17 2016  0:51                                                                                                    Page 18


   779 00:07D6: A6 03                        ldx     <3
   780 00:07D8: 85 03                        sta     <3
   781 00:07DA: 86 01                        stx     <1
   782 00:07DC: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07E0: 00 00 
   783                        
   784                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   785                        ;
   786                        ; Rotate the top three stack entries.
   787                        
   788 00:07E2: CF 07 00 03                  HEADER  3,"ROT",NORMAL
       00:07E6: 52 4F 54 
   789                        ROT:
   790 00:07E9: A6 05                        ldx     <5                      ; Save x1
   791 00:07EB: A5 03                        lda     <3                      ; Move x2
   792 00:07ED: 85 05                        sta     <5
   793 00:07EF: A5 01                        lda     <1                      ; Move x3
   794 00:07F1: 85 03                        sta     <3
   795 00:07F3: 86 01                        stx     <1                      ; Restore x1
   796 00:07F5: BB C8 C8 7C                  CONTINUE
       00:07F9: 00 00 
   797                        
   798                        ; ROLL ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
   799                        ;
   800                        ; Remove u. Rotate u+1 items on the top of the stack. An ambiguous condition
   801                        ; exists if there are less than u+2 items on the stack before ROLL is executed.
   802                        
   803                        ; TODO
   804                        
   805 00:07FB: E5 07 00 04                  HEADER  4,"ROLL",NORMAL
       00:07FF: 52 4F 4C 4C 
   806                        ROLL:
   807 00:0803: BB C8 C8 7C                  CONTINUE
       00:0807: 00 00 
   808                        
   809                        ; TUCK ( x1 x2 -- x2 x1 x2 )
   810                        ;
   811                        ; Copy the first (top) stack item below the second stack item.
   812                        
   813 00:0809: FE 07 00 04                  HEADER  4,"TUCK",NORMAL
       00:080D: 54 55 43 4B 
   814 00:0811: 20 B6 12     TUCK:           jsr     DO_COLON
   815 00:0814: D4 07                        dw      SWAP
   816 00:0816: B0 07                        dw      OVER
   817 00:0818: 1A 0D                        dw      EXIT
   818                        
   819                        ;==============================================================================
   820                        ; Return Stack Operations
   821                        ;------------------------------------------------------------------------------
   822                        
   823                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   824                        ;
   825                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   826                        ; SWAP >R >R.
   827                        
   828 00:081A: 0C 08 00 03                  HEADER  3,"2>R",NORMAL
       00:081E: 32 3E 52 
   829                        TWO_TO_R:
  Sun Apr 17 2016  0:51                                                                                                    Page 19


   830 00:0821: A5 03                        lda     <3                      ; Transfer x1
   831 00:0823: 48                           pha
   832 00:0824: A5 01                        lda     <1                      ; Transfer x2
   833 00:0826: 48                           pha
   834 00:0827: 7B                           tdc
   835 00:0828: 1A                           inc     a                       ; Clean up data stack
   836 00:0829: 1A                           inc     a
   837 00:082A: 1A                           inc     a
   838 00:082B: 1A                           inc     a
   839 00:082C: 5B                           tcd
   840 00:082D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0831: 00 00 
   841                        
   842                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   843                        ;
   844                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   845                        ; R> SWAP.
   846                        
   847 00:0833: 1D 08 00 03                  HEADER  3,"2R>",NORMAL
       00:0837: 32 52 3E 
   848                        TWO_R_FROM:
   849 00:083A: 7B                           tdc
   850 00:083B: 3A                           dec     a                       ; Make space for values
   851 00:083C: 3A                           dec     a
   852 00:083D: 3A                           dec     a
   853 00:083E: 3A                           dec     a
   854 00:083F: 5B                           tcd
   855 00:0840: 68                           pla                             ; Transfer x2
   856 00:0841: 85 01                        sta     <1
   857 00:0843: 68                           pla                             ; Transfer x1
   858 00:0844: 85 03                        sta     <3
   859 00:0846: BB C8 C8 7C                  CONTINUE                        ; Done
       00:084A: 00 00 
   860                        
   861                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
   862                        ;
   863                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   864                        ; 2DUP >R >R SWAP.
   865                        
   866 00:084C: 36 08 00 03                  HEADER  3,"2R@",NORMAL
       00:0850: 32 52 40 
   867                        TWO_R_FETCH:
   868 00:0853: 7B                           tdc
   869 00:0854: 3A                           dec     a                       ; Make space for values
   870 00:0855: 3A                           dec     a
   871 00:0856: 3A                           dec     a
   872 00:0857: 3A                           dec     a
   873 00:0858: 5B                           tcd
   874 00:0859: A3 01                        lda     1,s                     ; Transfer x2
   875 00:085B: 85 01                        sta     <1
   876 00:085D: A3 03                        lda     3,s                     ; Transfer x1
   877 00:085F: 85 03                        sta     <3
   878 00:0861: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0865: 00 00 
   879                        
   880                        ; >R ( x -- ) ( R: -- x )
   881                        ;
   882                        ; Move x to the return stack.
  Sun Apr 17 2016  0:51                                                                                                    Page 20


   883                        
   884 00:0867: 4F 08 00 02                  HEADER  2,">R",NORMAL
       00:086B: 3E 52 
   885                        TO_R:
   886 00:086D: A5 01                        lda     <1                      ; Transfer top value
   887 00:086F: 48                           pha                             ; .. to return stack
   888 00:0870: 7B                           tdc
   889 00:0871: 1A                           inc     a
   890 00:0872: 1A                           inc     a
   891 00:0873: 5B                           tcd
   892 00:0874: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0878: 00 00 
   893                        
   894                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   895                        ;
   896                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   897                        ; exists if the loop control parameters are unavailable.
   898                        
   899 00:087A: 6A 08 00 01                  HEADER  1,"I",NORMAL
       00:087E: 49 
   900                        I:
   901 00:087F: 7B                           tdc
   902 00:0880: 3A                           dec     a
   903 00:0881: 3A                           dec     a
   904 00:0882: 5B                           tcd
   905 00:0883: A3 01                        lda     1,s
   906 00:0885: 85 01                        sta     <1
   907 00:0887: BB C8 C8 7C                  CONTINUE
       00:088B: 00 00 
   908                        
   909                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   910                        ;
   911                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   912                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   913                        ; unavailable.
   914                        
   915 00:088D: 7D 08 00 01                  HEADER  1,"J",NORMAL
       00:0891: 4A 
   916                        J:
   917 00:0892: 7B                           tdc
   918 00:0893: 3A                           dec     a
   919 00:0894: 3A                           dec     a
   920 00:0895: 5B                           tcd
   921 00:0896: A3 05                        lda     5,s
   922 00:0898: 85 01                        sta     <1
   923 00:089A: BB C8 C8 7C                  CONTINUE
       00:089E: 00 00 
   924                        
   925                        ; R> ( -- x ) ( R: x -- )
   926                        ;
   927                        ; Move x from the return stack to the data stack.
   928                        
   929 00:08A0: 90 08 00 02                  HEADER  2,"R>",NORMAL
       00:08A4: 52 3E 
   930                        R_FROM:
   931 00:08A6: 7B                           tdc
   932 00:08A7: 3A                           dec     a
   933 00:08A8: 3A                           dec     a
  Sun Apr 17 2016  0:51                                                                                                    Page 21


   934 00:08A9: 5B                           tcd
   935 00:08AA: 68                           pla                             ; Fetch return stack value
   936 00:08AB: 85 01                        sta     <1
   937 00:08AD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08B1: 00 00 
   938                        
   939                        ; R@ ( -- x ) ( R: x -- x )
   940                        ;
   941                        ; Copy x from the return stack to the data stack.
   942                        
   943 00:08B3: A3 08 00 02                  HEADER  2,"R@",NORMAL
       00:08B7: 52 40 
   944                        R_FETCH:
   945 00:08B9: 7B                           tdc
   946 00:08BA: 3A                           dec     a
   947 00:08BB: 3A                           dec     a
   948 00:08BC: 5B                           tcd
   949 00:08BD: A3 01                        lda     1,s
   950 00:08BF: 85 01                        sta     <1
   951 00:08C1: BB C8 C8 7C                  CONTINUE
       00:08C5: 00 00 
   952                        
   953                        ;==============================================================================
   954                        ; Single Precision Arithmetic
   955                        ;------------------------------------------------------------------------------
   956                        
   957                        ; * ( n1|u1 n2|u2 -- n3|u3 )
   958                        ;
   959                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
   960                        
   961 00:08C7: B6 08 00 01                  HEADER  1,"*",NORMAL
       00:08CB: 2A 
   962                        STAR:
   963 00:08CC: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08D0: 00 00 
   964                        
   965                        ; */
   966                        
   967 00:08D2: CA 08 00 02                  HEADER  2,"*/",NORMAL
       00:08D6: 2A 2F 
   968                        STAR_SLASH:
   969 00:08D8: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08DC: 00 00 
   970                        
   971                        ; */MOD
   972                        
   973 00:08DE: D5 08 00 05                  HEADER  5,"*/MOD",NORMAL
       00:08E2: 2A 2F 4D 4F 
       00:08E6: 44 
   974                        STAR_SLASH_MOD:
   975 00:08E7: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08EB: 00 00 
   976                        
   977                        ; + ( n1|u1 n2|u2 -- n3|u3 )
   978                        ;
   979                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
   980                        
   981 00:08ED: E1 08 00 01                  HEADER  1,"+",NORMAL
  Sun Apr 17 2016  0:51                                                                                                    Page 22


       00:08F1: 2B 
   982                        PLUS:
   983 00:08F2: 18                           clc                             ; Add top two values
   984 00:08F3: A5 03                        lda     <3
   985 00:08F5: 65 01                        adc     <1
   986 00:08F7: 85 03                        sta     <3                      ; Save result
   987 00:08F9: 7B                           tdc
   988 00:08FA: 1A                           inc     a                       ; Clean up data stack
   989 00:08FB: 1A                           inc     a
   990 00:08FC: 5B                           tcd
   991 00:08FD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0901: 00 00 
   992                        
   993                        ; - ( n1|u1 n2|u2 -- n3|u3 )
   994                        ;
   995                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
   996                        
   997 00:0903: F0 08 00 01                  HEADER  1,"-",NORMAL
       00:0907: 2D 
   998                        MINUS:
   999 00:0908: 38                           sec                             ; Subtract top two values
  1000 00:0909: A5 03                        lda     <3
  1001 00:090B: E5 01                        sbc     <1
  1002 00:090D: 85 03                        sta     <3                      ; Save result
  1003 00:090F: 7B                           tdc
  1004 00:0910: 1A                           inc     a                       ; Clean up data stack
  1005 00:0911: 1A                           inc     a
  1006 00:0912: 5B                           tcd
  1007 00:0913: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0917: 00 00 
  1008                        
  1009                        ; /
  1010                        
  1011 00:0919: 06 09 00 01                  HEADER  1,"/",NORMAL
       00:091D: 2F 
  1012 00:091E: 20 B6 12     SLASH:          jsr     DO_COLON
  1013 00:0921: 2F 09                        dw      SLASH_MOD
  1014 00:0923: A2 07                        dw      NIP
  1015 00:0925: 1A 0D                        dw      EXIT
  1016                        
  1017                        ; /MOD
  1018                        
  1019 00:0927: 1C 09 00 04                  HEADER  4,"/MOD",NORMAL
       00:092B: 2F 4D 4F 44 
  1020                        SLASH_MOD:
  1021 00:092F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0933: 00 00 
  1022                        
  1023                        ; 1+ ( n1|u1 -- n2|u2 )
  1024                        ;
  1025                        ; Add one (1) to n1|u1 giving the sum n2|u2.
  1026                        
  1027 00:0935: 2A 09 00 02                  HEADER  2,"1+",NORMAL
       00:0939: 31 2B 
  1028                        ONE_PLUS:
  1029 00:093B: E6 01                        inc     <1                      ; Increment top of stack
  1030 00:093D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0941: 00 00 
  Sun Apr 17 2016  0:51                                                                                                    Page 23


  1031                        
  1032                        ; 1- ( n1|u1 -- n2|u2 )
  1033                        ;
  1034                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
  1035                        
  1036 00:0943: 38 09 00 02                  HEADER  2,"1-",NORMAL
       00:0947: 31 2D 
  1037                        ONE_MINUS:
  1038 00:0949: C6 01                        dec     <1                      ; Decrement top of stack
  1039 00:094B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:094F: 00 00 
  1040                        
  1041                        ; 2* ( x1 -- x2 )
  1042                        ;
  1043                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
  1044                        ; filling the vacated least-significant bit with zero.
  1045                        
  1046 00:0951: 46 09 00 02                  HEADER  2,"2*",NORMAL
       00:0955: 32 2A 
  1047                        TWO_STAR:
  1048 00:0957: 06 01                        asl     <1                      ; Multiply top value by two
  1049 00:0959: BB C8 C8 7C                  CONTINUE                        ; Done
       00:095D: 00 00 
  1050                        
  1051                        ; 2/ ( x1 -- x2 )
  1052                        ;
  1053                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
  1054                        ; leaving the most-significant bit unchanged.
  1055                        
  1056 00:095F: 54 09 00 02                  HEADER  2,"2/",NORMAL
       00:0963: 32 2F 
  1057                        TWO_SLASH:
  1058 00:0965: A5 01                        lda     <1                      ; Load the top value
  1059 00:0967: 2A                           rol     a                       ; Extract the top bit
  1060 00:0968: 66 01                        ror     <1                      ; And shift back into value
  1061 00:096A: BB C8 C8 7C                  CONTINUE
       00:096E: 00 00 
  1062                        
  1063                        ; ABS ( n -- u )
  1064                        ;
  1065                        ; u is the absolute value of n.
  1066                        
  1067 00:0970: 62 09 00 03                  HEADER  3,"ABS",NORMAL
       00:0974: 41 42 53 
  1068                        ABS:
  1069 00:0977: A5 01                        lda     <1
  1070 00:0979: 30 50                        bmi     NEGATE
  1071 00:097B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:097F: 00 00 
  1072                        
  1073                        ; MAX
  1074                        
  1075 00:0981: 73 09 00 03                  HEADER  3,"MAX",NORMAL
       00:0985: 4D 41 58 
  1076 00:0988: 20 B6 12     MAX:            jsr     DO_COLON
  1077 00:098B: E1 06                        dw      TWO_DUP
  1078 00:098D: 68 0B                        dw      LESS
  1079 00:098F: 8B 12 95 09                  dw      QUERY_BRANCH,MAX_1
  Sun Apr 17 2016  0:51                                                                                                    Page 24


  1080 00:0993: D4 07                        dw      SWAP
  1081 00:0995: 7C 07        MAX_1:          dw      DROP
  1082 00:0997: 1A 0D                        dw      EXIT
  1083                        
  1084                        ; MIN
  1085                        
  1086 00:0999: 84 09 00 03                  HEADER  3,"MIN",NORMAL
       00:099D: 4D 49 4E 
  1087 00:09A0: 20 B6 12     MIN:            jsr     DO_COLON
  1088 00:09A3: E1 06                        dw      TWO_DUP
  1089 00:09A5: BC 0B                        dw      GREATER
  1090 00:09A7: 8B 12 AD 09                  dw      QUERY_BRANCH,MIN_1
  1091 00:09AB: D4 07                        dw      SWAP
  1092 00:09AD: 7C 07        MIN_1:          dw      DROP
  1093 00:09AF: 1A 0D                        dw      EXIT
  1094                        
  1095                        ; MOD
  1096                        
  1097 00:09B1: 9C 09 00 03                  HEADER  3,"MOD",NORMAL
       00:09B5: 4D 4F 44 
  1098 00:09B8: 20 B6 12     MOD:            jsr     DO_COLON
  1099 00:09BB: 2F 09                        dw      SLASH_MOD
  1100 00:09BD: 7C 07                        dw      DROP
  1101 00:09BF: 1A 0D                        dw      EXIT
  1102                        
  1103                        ; NEGATE ( n1 -- n2 )
  1104                        ;
  1105                        ; Negate n1, giving its arithmetic inverse n2.
  1106                        
  1107 00:09C1: B4 09 00 06                  HEADER  6,"NEGATE",NORMAL
       00:09C5: 4E 45 47 41 
       00:09C9: 54 45 
  1108                        NEGATE:
  1109 00:09CB: 38                           sec                             ; Negate the top of stack
  1110 00:09CC: A9 00 00                     lda     #0
  1111 00:09CF: E5 01                        sbc     <1
  1112 00:09D1: 85 01                        sta     <1
  1113 00:09D3: BB C8 C8 7C                  CONTINUE                        ; Done
       00:09D7: 00 00 
  1114                        
  1115                        ; UMAX ( x1 x2 -- x1|x2 )
  1116                        
  1117 00:09D9: C4 09 00 04                  HEADER  4,"UMAX",NORMAL
       00:09DD: 55 4D 41 58 
  1118                        UMAX:
  1119 00:09E1: A5 01                        lda     <1                      ; Compare the top values
  1120 00:09E3: C5 03                        cmp     <3
  1121 00:09E5: B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
  1122 00:09E7: 4C 7C 07                     jmp     DROP                    ; No, x1 is
  1123 00:09EA: 4C A2 07     UMAX_EXIT:      jmp     NIP
  1124                        
  1125                        ; UMIN ( x1 x2 -- x1|x2 )
  1126                        
  1127 00:09ED: DC 09 00 04                  HEADER  4,"UMIN",NORMAL
       00:09F1: 55 4D 49 4E 
  1128                        UMIN:
  1129 00:09F5: A5 01                        lda     <1                      ; Compare the top values
  1130 00:09F7: C5 03                        cmp     <3
  Sun Apr 17 2016  0:51                                                                                                    Page 25


  1131 00:09F9: 90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
  1132 00:09FB: 4C 7C 07                     jmp     DROP                    ; No, x1 is
  1133 00:09FE: 4C A2 07     UMIN_EXIT:      jmp     NIP
  1134                        
  1135                        ;==============================================================================
  1136                        ; Double Precision Arithmetic
  1137                        ;------------------------------------------------------------------------------
  1138                        
  1139                        ; D+ ( d1|ud1 d2|ud2 -- d3|ud3 )
  1140                        ;
  1141                        ; Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
  1142                        
  1143 00:0A01: F0 09 00 02                  HEADER  2,"D+",NORMAL
       00:0A05: 44 2B 
  1144                        D_PLUS:
  1145 00:0A07: 18                           clc
  1146 00:0A08: A5 07                        lda     <7                      ; Add low words
  1147 00:0A0A: 65 03                        adc     <3
  1148 00:0A0C: 85 07                        sta     <7
  1149 00:0A0E: A5 05                        lda     <5                      ; Then the high words
  1150 00:0A10: 65 01                        adc     <1
  1151 00:0A12: 85 05                        sta     <5
  1152 00:0A14: 7B                           tdc                             ; Drop top double
  1153 00:0A15: 1A                           inc     a
  1154 00:0A16: 1A                           inc     a
  1155 00:0A17: 1A                           inc     a
  1156 00:0A18: 1A                           inc     a
  1157 00:0A19: 5B                           tcd
  1158 00:0A1A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A1E: 00 00 
  1159                        
  1160                        ; D- ( d1|ud1 d2|ud2 -- d3|ud3 )
  1161                        ;
  1162                        ; Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
  1163                        
  1164 00:0A20: 04 0A 00 02                  HEADER  2,"D-",NORMAL
       00:0A24: 44 2D 
  1165                        D_MINUS:
  1166 00:0A26: 38                           sec
  1167 00:0A27: A5 07                        lda     <7                      ; Subtract low words
  1168 00:0A29: E5 03                        sbc     <3
  1169 00:0A2B: 85 07                        sta     <7
  1170 00:0A2D: A5 05                        lda     <5                      ; Then the high words
  1171 00:0A2F: E5 01                        sbc     <1
  1172 00:0A31: 85 05                        sta     <5
  1173 00:0A33: 7B                           tdc                             ; Drop top double
  1174 00:0A34: 1A                           inc     a
  1175 00:0A35: 1A                           inc     a
  1176 00:0A36: 1A                           inc     a
  1177 00:0A37: 1A                           inc     a
  1178 00:0A38: 5B                           tcd
  1179 00:0A39: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A3D: 00 00 
  1180                        
  1181                        ; D2* ( xd1 -- xd2 )
  1182                        ;
  1183                        ; xd2 is the result of shifting xd1 one bit toward the most-significant bit,
  1184                        ; filling the vacated least-significant bit with zero.
  Sun Apr 17 2016  0:51                                                                                                    Page 26


  1185                        
  1186 00:0A3F: 23 0A 00 03                  HEADER  3,"D2*",NORMAL
       00:0A43: 44 32 2A 
  1187                        D_TWO_STAR:
  1188 00:0A46: 06 03                        asl     <3
  1189 00:0A48: 26 01                        rol     <1
  1190 00:0A4A: BB C8 C8 7C                  CONTINUE
       00:0A4E: 00 00 
  1191                        
  1192                        ; D2/ ( xd1 -- xd2 )
  1193                        ;
  1194                        ; xd2 is the result of shifting xd1 one bit toward the least-significant bit,
  1195                        ; leaving the most-significant bit unchanged.
  1196                        
  1197 00:0A50: 42 0A 00 03                  HEADER  3,"D2/",NORMAL
       00:0A54: 44 32 2F 
  1198                        D_TWO_SLASH:
  1199 00:0A57: A5 01                        lda     <1
  1200 00:0A59: 2A                           rol     a
  1201 00:0A5A: 66 01                        ror     <1
  1202 00:0A5C: 66 03                        ror     <3
  1203 00:0A5E: BB C8 C8 7C                  CONTINUE
       00:0A62: 00 00 
  1204                        
  1205                        ; DABS
  1206                        ; DMAX
  1207                        ; DMIN
  1208                        
  1209                        ; DNEGATE ( d1 -- d2 )
  1210                        ;
  1211                        ; d2 is the negation of d1.
  1212                        
  1213 00:0A64: 53 0A 00 07                  HEADER  7,"DNEGATE",NORMAL
       00:0A68: 44 4E 45 47 
       00:0A6C: 41 54 45 
  1214                        DNEGATE:
  1215 00:0A6F: 38                           sec
  1216 00:0A70: A9 00 00                     lda     #0                      ; Subtract low word from zero
  1217 00:0A73: E5 03                        sbc     <3
  1218 00:0A75: 85 03                        sta     <3
  1219 00:0A77: A9 00 00                     lda     #0                      ; Then the high word
  1220 00:0A7A: E5 01                        sbc     <1
  1221 00:0A7C: 85 01                        sta     <1
  1222 00:0A7E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A82: 00 00 
  1223                        
  1224                        ; UD* ( ud1 d2 -- ud3)
  1225                        ;
  1226                        ; 32*16->32 multiply
  1227                        ;
  1228                        ;   DUP >R UM* DROP  SWAP R> UM* ROT + ;
  1229                        
  1230 00:0A84: 67 0A 00 03                  HEADER  3,"UD*",NORMAL
       00:0A88: 55 44 2A 
  1231 00:0A8B: 20 B6 12     UD_STAR:        jsr     DO_COLON
  1232 00:0A8E: 8D 07                        dw      DUP
  1233 00:0A90: 6D 08                        dw      TO_R
  1234 00:0A92: EE 0A                        dw      UM_STAR
  Sun Apr 17 2016  0:51                                                                                                    Page 27


  1235 00:0A94: 7C 07                        dw      DROP
  1236 00:0A96: D4 07                        dw      SWAP
  1237 00:0A98: A6 08                        dw      R_FROM
  1238 00:0A9A: EE 0A                        dw      UM_STAR
  1239 00:0A9C: E9 07                        dw      ROT
  1240 00:0A9E: F2 08                        dw      PLUS
  1241 00:0AA0: 1A 0D                        dw      EXIT
  1242                        
  1243                        ;==============================================================================
  1244                        ; Mixed Arithmetic
  1245                        ;------------------------------------------------------------------------------
  1246                        
  1247                        
  1248                        ; D>S ( d -- n )
  1249                        ;
  1250                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1251                        ; range of a signed single-cell number.
  1252                        
  1253 00:0AA2: 87 0A 00 03                  HEADER  3,"D>S",NORMAL
       00:0AA6: 44 3E 53 
  1254                        D_TO_S:
  1255 00:0AA9: 7B                           tdc
  1256 00:0AAA: 1A                           inc     a                       ; Drop the high word
  1257 00:0AAB: 1A                           inc     a
  1258 00:0AAC: 5B                           tcd
  1259 00:0AAD: BB C8 C8 7C                  CONTINUE
       00:0AB1: 00 00 
  1260                        
  1261                        ; M*/
  1262                        
  1263                        ; M+ ( d1|ud1 n -- d2|ud2 )
  1264                        ;
  1265                        ; Add n to d1|ud1, giving the sum d2|ud2.
  1266                        
  1267 00:0AB3: A5 0A 00 02                  HEADER  2,"M+",NORMAL
       00:0AB7: 4D 2B 
  1268                        M_PLUS:
  1269 00:0AB9: 18                           clc
  1270 00:0ABA: A5 01                        lda     <1
  1271 00:0ABC: 65 05                        adc     <5
  1272 00:0ABE: 85 05                        sta     <5
  1273 00:0AC0: 90 02                        bcc     $+4
  1274 00:0AC2: E6 03                        inc     <3
  1275 00:0AC4: 7B                           tdc
  1276 00:0AC5: 1A                           inc     a
  1277 00:0AC6: 1A                           inc     a
  1278 00:0AC7: 5B                           tcd
  1279 00:0AC8: BB C8 C8 7C                  CONTINUE
       00:0ACC: 00 00 
  1280                        
  1281                        ; S>D ( n -- d )
  1282                        ;
  1283                        ; Convert the number n to the double-cell number d with the same numerical
  1284                        ; value.
  1285                        
  1286 00:0ACE: B6 0A 00 03                  HEADER  3,"S>D",NORMAL
       00:0AD2: 53 3E 44 
  1287                        S_TO_D:
  Sun Apr 17 2016  0:51                                                                                                    Page 28


  1288 00:0AD5: 7B                           tdc
  1289 00:0AD6: 3A                           dec     a                       ; Assume n is positive
  1290 00:0AD7: 3A                           dec     a
  1291 00:0AD8: 5B                           tcd
  1292 00:0AD9: 64 01                        stz     <1                      ; .. push a zero value
  1293 00:0ADB: A5 03                        lda     <3                      ; Test the number
  1294 00:0ADD: 10 02                        bpl     S_TO_D_1
  1295 00:0ADF: C6 01                        dec     <1                      ; Make top -1 if negative
  1296 00:0AE1: BB C8 C8 7C  S_TO_D_1        CONTINUE                        ; Done
       00:0AE5: 00 00 
  1297                        
  1298                        ; UM* ( n1 n2 -- d )
  1299                        
  1300 00:0AE7: D1 0A 00 03                  HEADER  3,"UM*",NORMAL
       00:0AEB: 55 4D 2A 
  1301                        UM_STAR:
  1302 00:0AEE: A5 01                        lda     <1                      ; Fetch multiplier
  1303 00:0AF0: 48                           pha
  1304 00:0AF1: 64 01                        stz     <1                      ; Clear the result
  1305 00:0AF3: A2 10 00                     ldx     #16
  1306 00:0AF6: A5 03        UM_STAR_1:      lda     <3                      ; Shift multiplier one bit
  1307 00:0AF8: 4A                           lsr     a
  1308 00:0AF9: 90 07                        bcc     UM_STAR_2               ; Not set, no add
  1309 00:0AFB: A3 01                        lda     1,s                     ; Fetch multiplicand
  1310 00:0AFD: 18                           clc
  1311 00:0AFE: 65 01                        adc     <1
  1312 00:0B00: 85 01                        sta     <1
  1313 00:0B02: 66 01        UM_STAR_2:      ror     <1                      ; Rotate high word down
  1314 00:0B04: 66 03                        ror     <3
  1315 00:0B06: CA                           dex
  1316 00:0B07: D0 ED                        bne     UM_STAR_1
  1317 00:0B09: 68                           pla
  1318 00:0B0A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0B0E: 00 00 
  1319                        
  1320                        ;==============================================================================
  1321                        ; Comparisons
  1322                        ;------------------------------------------------------------------------------
  1323                        
  1324                        ; 0< ( n -- flag )
  1325                        ;
  1326                        ; flag is true if and only if n is less than zero.
  1327                        
  1328 00:0B10: EA 0A 00 02                  HEADER  2,"0<",NORMAL
       00:0B14: 30 3C 
  1329                        ZERO_LESS:
  1330 00:0B16: A5 01                        lda     <1                      ; Test top of stack
  1331 00:0B18: 64 01                        stz     <1                      ; Assume false result
  1332 00:0B1A: 10 02                        bpl     ZERO_LT_1               ; Was the value negative?
  1333 00:0B1C: C6 01                        dec     <1                      ; Yes, make true result
  1334 00:0B1E: BB C8 C8 7C  ZERO_LT_1:      CONTINUE                        ; Done
       00:0B22: 00 00 
  1335                        
  1336                        ; 0<> ( x -- flag )
  1337                        ;
  1338                        ; flag is true if and only if x is not equal to zero.
  1339                        
  1340 00:0B24: 13 0B 00 03                  HEADER  3,"0<>",NORMAL
  Sun Apr 17 2016  0:51                                                                                                    Page 29


       00:0B28: 30 3C 3E 
  1341                        ZERO_NOT_EQUAL:
  1342 00:0B2B: A5 01                        lda     <1                      ; Test top of stack
  1343 00:0B2D: 64 01                        stz     <1                      ; Assume false result
  1344 00:0B2F: F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
  1345 00:0B31: C6 01                        dec     <1                      ; Yes, make true result
  1346 00:0B33: BB C8 C8 7C  ZERO_NE_1:      CONTINUE                        ; Done
       00:0B37: 00 00 
  1347                        
  1348                        ; 0= ( x -- flag )
  1349                        ;
  1350                        ; flag is true if and only if x is equal to zero.
  1351                        
  1352 00:0B39: 27 0B 00 02                  HEADER  2,"0=",NORMAL
       00:0B3D: 30 3D 
  1353                        ZERO_EQUAL:
  1354 00:0B3F: A5 01                        lda     <1                      ; Test top of stack
  1355 00:0B41: 64 01                        stz     <1                      ; Assume false result
  1356 00:0B43: D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
  1357 00:0B45: C6 01                        dec     <1                      ; Yes, make true result
  1358 00:0B47: BB C8 C8 7C  ZERO_EQ_1:      CONTINUE                        ; Done
       00:0B4B: 00 00 
  1359                        
  1360                        ; 0> ( n -- flag )
  1361                        ;
  1362                        ; flag is true if and only if n is greater than zero.
  1363                        
  1364 00:0B4D: 3C 0B 00 02                  HEADER  2,"0>",NORMAL
       00:0B51: 30 3E 
  1365                        ZERO_GREATER:
  1366 00:0B53: A5 01                        lda     <1                      ; Test top of stack
  1367 00:0B55: 64 01                        stz     <1                      ; Assume false result
  1368 00:0B57: 30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
  1369 00:0B59: F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
  1370 00:0B5B: C6 01                        dec     <1                      ; Yes, make true result
  1371 00:0B5D: BB C8 C8 7C  ZERO_GT_EXIT:   CONTINUE                        ; Done
       00:0B61: 00 00 
  1372                        
  1373                        ; <
  1374                        
  1375 00:0B63: 50 0B 00 01                  HEADER  1,"<",NORMAL
       00:0B67: 3C 
  1376                        LESS:
  1377 00:0B68: A6 01                        ldx     <1                      ; Pull x2 from stack
  1378 00:0B6A: 7B                           tdc
  1379 00:0B6B: 1A                           inc     a
  1380 00:0B6C: 1A                           inc     a
  1381 00:0B6D: 5B                           tcd
  1382 00:0B6E: 8A                           txa
  1383 00:0B6F: 38                           sec                             ; Compare with x1
  1384 00:0B70: E5 01                        sbc     <1
  1385 00:0B72: 64 01                        stz     <1                      ; Assume false result
  1386 00:0B74: 70 04                        bvs     LESS_1
  1387 00:0B76: 10 04                        bpl     LESS_2                  ; V == 0 && N == 0
  1388 00:0B78: 80 04                        bra     LESS_3
  1389 00:0B7A: 10 02        LESS_1:         bpl     LESS_3                  ; V == 1 && N == 1
  1390 00:0B7C: C6 01        LESS_2:         dec     <1
  1391 00:0B7E: BB C8 C8 7C  LESS_3:         CONTINUE
  Sun Apr 17 2016  0:51                                                                                                    Page 30


       00:0B82: 00 00 
  1392                        
  1393                        ; <>
  1394                        
  1395 00:0B84: 66 0B 00 02                  HEADER  2,"<>",NORMAL
       00:0B88: 3C 3E 
  1396                        NOT_EQUAL:
  1397 00:0B8A: A6 01                        ldx     <1                      ; Pull x2 from stack
  1398 00:0B8C: 7B                           tdc
  1399 00:0B8D: 1A                           inc     a
  1400 00:0B8E: 1A                           inc     a
  1401 00:0B8F: 5B                           tcd
  1402 00:0B90: E4 01                        cpx     <1                      ; Compare with x1
  1403 00:0B92: 64 01                        stz     <1                      ; Assume equal
  1404 00:0B94: F0 02                        beq     NE_EXIT                 ; Test flags
  1405 00:0B96: C6 01                        dec     <1                      ; Make result true
  1406 00:0B98: BB C8 C8 7C  NE_EXIT:        CONTINUE                        ; Done
       00:0B9C: 00 00 
  1407                        
  1408                        ; = ( x1 x2 -- flag )
  1409                        ;
  1410                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  1411                        
  1412 00:0B9E: 87 0B 00 01                  HEADER  1,"=",NORMAL
       00:0BA2: 3D 
  1413                        EQUAL:
  1414 00:0BA3: A6 01                        ldx     <1                      ; Pull x2 from stack
  1415 00:0BA5: 7B                           tdc
  1416 00:0BA6: 1A                           inc     a
  1417 00:0BA7: 1A                           inc     a
  1418 00:0BA8: 5B                           tcd
  1419 00:0BA9: E4 01                        cpx     <1                      ; Compare with x1
  1420 00:0BAB: 64 01                        stz     <1                      ; Assume not equal
  1421 00:0BAD: D0 02                        bne     EQ_EXIT                 ; Test the flags
  1422 00:0BAF: C6 01                        dec     <1                      ; Make result true
  1423 00:0BB1: BB C8 C8 7C  EQ_EXIT:        CONTINUE                        ; Done
       00:0BB5: 00 00 
  1424                        
  1425                        ; >
  1426                        
  1427 00:0BB7: A1 0B 00 01                  HEADER  1,">",NORMAL
       00:0BBB: 3E 
  1428 00:0BBC: 20 B6 12     GREATER:        jsr     DO_COLON
  1429 00:0BBF: D4 07                        dw      SWAP
  1430 00:0BC1: 68 0B                        dw      LESS
  1431 00:0BC3: 1A 0D                        dw      EXIT
  1432                        
  1433                        ; U<
  1434                        
  1435 00:0BC5: BA 0B 00 02                  HEADER  2,"U<",NORMAL
       00:0BC9: 55 3C 
  1436                        U_LESS:
  1437 00:0BCB: A6 01                        ldx     <1                      ; Pull x2
  1438 00:0BCD: 7B                           tdc                             ; Drop from stack
  1439 00:0BCE: 1A                           inc     a
  1440 00:0BCF: 1A                           inc     a
  1441 00:0BD0: 5B                           tcd
  1442 00:0BD1: E4 01                        cpx     <1                      ; Compare with x1
  Sun Apr 17 2016  0:51                                                                                                    Page 31


  1443 00:0BD3: 64 01                        stz     <1                      ; Assume false
  1444 00:0BD5: F0 04                        beq     U_LESS_1                ; Equal
  1445 00:0BD7: 90 02                        bcc     U_LESS_1                ; Less
  1446 00:0BD9: C6 01                        dec     <1
  1447 00:0BDB: BB C8 C8 7C  U_LESS_1:       CONTINUE
       00:0BDF: 00 00 
  1448                        
  1449                        ; U>
  1450                        
  1451 00:0BE1: C8 0B 00 02                  HEADER  2,"U>",NORMAL
       00:0BE5: 55 3E 
  1452 00:0BE7: 20 B6 12     U_GREATER:      jsr     DO_COLON
  1453 00:0BEA: D4 07                        dw      SWAP
  1454 00:0BEC: CB 0B                        dw      U_LESS
  1455 00:0BEE: 1A 0D                        dw      EXIT
  1456                        
  1457                        ;==============================================================================
  1458                        ; Logical Operations
  1459                        ;------------------------------------------------------------------------------
  1460                        
  1461                        ; AND ( x1 x2 -- x3 )
  1462                        ;
  1463                        ; x3 is the bit-by-bit logical and of x1 with x2.
  1464                        
  1465 00:0BF0: E4 0B 00 03                  HEADER  3,"AND",NORMAL
       00:0BF4: 41 4E 44 
  1466                        AND:
  1467 00:0BF7: A5 01                        lda     <1
  1468 00:0BF9: 25 03                        and     <3
  1469 00:0BFB: 85 03                        sta     <3
  1470 00:0BFD: 7B                           tdc
  1471 00:0BFE: 1A                           inc     a
  1472 00:0BFF: 1A                           inc     a
  1473 00:0C00: 5B                           tcd
  1474 00:0C01: BB C8 C8 7C                  CONTINUE
       00:0C05: 00 00 
  1475                        
  1476                        ; INVERT ( x1 -- x2 )
  1477                        ;
  1478                        ; Invert all bits of x1, giving its logical inverse x2.
  1479                        
  1480 00:0C07: F3 0B 00 06                  HEADER  6,"INVERT",NORMAL
       00:0C0B: 49 4E 56 45 
       00:0C0F: 52 54 
  1481                        INVERT:
  1482 00:0C11: A5 01                        lda     <1                      ; Fetch top value
  1483 00:0C13: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1484 00:0C16: 85 01                        sta     <1                      ; .. and write back
  1485 00:0C18: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0C1C: 00 00 
  1486                        
  1487                        ; LSHIFT ( x1 u -- x2 )
  1488                        ;
  1489                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1490                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1491                        ; exists if u is greater than or equal to the number of bits in a cell.
  1492                        
  1493 00:0C1E: 0A 0C 00 06                  HEADER  6,"LSHIFT",NORMAL
  Sun Apr 17 2016  0:51                                                                                                    Page 32


       00:0C22: 4C 53 48 49 
       00:0C26: 46 54 
  1494                        LSHIFT:
  1495 00:0C28: A6 01                        ldx     <1                      ; Pull bit count
  1496 00:0C2A: 08                           php
  1497 00:0C2B: 7B                           tdc
  1498 00:0C2C: 1A                           inc     a                       ; .. from the stack
  1499 00:0C2D: 1A                           inc     a
  1500 00:0C2E: 5B                           tcd
  1501 00:0C2F: 28                           plp
  1502 00:0C30: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1503 00:0C32: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1504 00:0C35: B0 0B                        bcs     LSHIFT_2                ; Yes, result will be zero
  1505 00:0C37: 06 01        LSHIFT_1        asl     <1                      ; Shift one bit left
  1506 00:0C39: CA                           dex                             ; Update count
  1507 00:0C3A: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  1508 00:0C3C: BB C8 C8 7C  LSHIFT_0        CONTINUE                        ; Done
       00:0C40: 00 00 
  1509 00:0C42: 64 01        LSHIFT_2        stz     <1                      ; Clear top value
  1510 00:0C44: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0C48: 00 00 
  1511                        
  1512                        ; OR ( x1 x2 -- x3 )
  1513                        ;
  1514                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1515                        
  1516 00:0C4A: 21 0C 00 02                  HEADER  2,"OR",NORMAL
       00:0C4E: 4F 52 
  1517                        OR:
  1518 00:0C50: A5 01                        lda     <1
  1519 00:0C52: 05 03                        ora     <3
  1520 00:0C54: 85 03                        sta     <3
  1521 00:0C56: 7B                           tdc
  1522 00:0C57: 1A                           inc     a
  1523 00:0C58: 1A                           inc     a
  1524 00:0C59: 5B                           tcd
  1525 00:0C5A: BB C8 C8 7C                  CONTINUE
       00:0C5E: 00 00 
  1526                        
  1527                        ; RSHIFT ( x1 u -- x2 )
  1528                        ;
  1529                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1530                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1531                        ; exists if u is greater than or equal to the number of bits in a cell.
  1532                        
  1533 00:0C60: 4D 0C 00 06                  HEADER  6,"RSHIFT",NORMAL
       00:0C64: 52 53 48 49 
       00:0C68: 46 54 
  1534                        RSHIFT:
  1535 00:0C6A: A6 01                        ldx     <1                      ; Pull bit count
  1536 00:0C6C: 08                           php
  1537 00:0C6D: 7B                           tdc
  1538 00:0C6E: 1A                           inc     a                       ; .. from the stack
  1539 00:0C6F: 1A                           inc     a
  1540 00:0C70: 5B                           tcd
  1541 00:0C71: 28                           plp
  1542 00:0C72: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1543 00:0C74: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  Sun Apr 17 2016  0:51                                                                                                    Page 33


  1544 00:0C77: B0 0B                        bcs     RSHIFT_2                ; Yes, result will be zero
  1545 00:0C79: 46 01        RSHIFT_1        lsr     <1                      ; Shift one bit left
  1546 00:0C7B: CA                           dex                             ; Update count
  1547 00:0C7C: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1548 00:0C7E: BB C8 C8 7C  RSHIFT_0        CONTINUE                        ; Done
       00:0C82: 00 00 
  1549 00:0C84: 64 01        RSHIFT_2        stz     <1                      ; Clear top value
  1550 00:0C86: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0C8A: 00 00 
  1551                        
  1552                        ; XOR ( x1 x2 -- x3 )
  1553                        ;
  1554                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1555                        
  1556 00:0C8C: 63 0C 00 03                  HEADER  3,"XOR",NORMAL
       00:0C90: 58 4F 52 
  1557                        XOR:
  1558 00:0C93: A5 01                        lda     <1
  1559 00:0C95: 45 03                        eor     <3
  1560 00:0C97: 85 03                        sta     <3
  1561 00:0C99: 7B                           tdc
  1562 00:0C9A: 1A                           inc     a
  1563 00:0C9B: 1A                           inc     a
  1564 00:0C9C: 5B                           tcd
  1565 00:0C9D: BB C8 C8 7C                  CONTINUE
       00:0CA1: 00 00 
  1566                        
  1567                        ;==============================================================================
  1568                        ; Control Words
  1569                        ;------------------------------------------------------------------------------
  1570                        
  1571                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1572                        ;
  1573                        ; Empty the data stack and perform the function of QUIT, which includes
  1574                        ; emptying the return stack, without displaying a message.
  1575                        
  1576 00:0CA3: 8F 0C 00 05                  HEADER  5,"ABORT",NORMAL
       00:0CA7: 41 42 4F 52 
       00:0CAB: 54 
  1577 00:0CAC: 20 B6 12     ABORT:          jsr     DO_COLON
  1578 00:0CAF: B3 0C                        dw      DO_ABORT
  1579 00:0CB1: 29 0D                        dw      QUIT
  1580                        
  1581                        DO_ABORT:
  1582 00:0CB3: A9 7F 01                     lda     #DSTACK_END-1
  1583 00:0CB6: 5B                           tcd
  1584 00:0CB7: BB C8 C8 7C                  CONTINUE
       00:0CBB: 00 00 
  1585                        
  1586                        ; (BUILD) ( dtc-addr -- )
  1587                        ;
  1588                        ; Adds a jump the to exection function for the new word.
  1589                        
  1590 00:0CBD: A6 0C 00 07                  HEADER  7,"(BUILD)",NORMAL
       00:0CC1: 28 42 55 49 
       00:0CC5: 4C 44 29 
  1591 00:0CC8: 20 B6 12     BUILD:          jsr     DO_COLON
  1592 00:0CCB: BA 13 20 00                  dw      DO_LITERAL,$20
  Sun Apr 17 2016  0:51                                                                                                    Page 34


  1593 00:0CCF: 17 06                        dw      C_COMMA
  1594 00:0CD1: 9B 05                        dw      COMMA
  1595 00:0CD3: 1A 0D                        dw      EXIT
  1596                        
  1597                        ; CREATE ( -- ) [TODO]
  1598                        ;
  1599                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1600                        ; definition for name with the execution semantics defined below. If the data-
  1601                        ; space pointer is not aligned, reserve enough data space to align it. The new
  1602                        ; data-space pointer defines names data field. CREATE does not allocate data
  1603                        ; space in names data field.
  1604                        
  1605 00:0CD5: C0 0C 00 06                  HEADER  6,"CREATE",NORMAL
       00:0CD9: 43 52 45 41 
       00:0CDD: 54 45 
  1606 00:0CDF: 20 B6 12     CREATE:         jsr     DO_COLON
  1607 00:0CE2: 9B 04                        dw      LATEST
  1608 00:0CE4: DB 05                        dw      FETCH
  1609 00:0CE6: 9B 05                        dw      COMMA
  1610 00:0CE8: F0 04                        dw      ZERO
  1611 00:0CEA: 17 06                        dw      C_COMMA
  1612 00:0CEC: 46 06                        dw      HERE
  1613 00:0CEE: 9B 04                        dw      LATEST
  1614 00:0CF0: 6D 05                        dw      STORE
  1615 00:0CF2: 02 05                        dw      BL
  1616 00:0CF4: 08 11                        dw      WORD
  1617 00:0CF6: 2E 06                        dw      C_FETCH
  1618 00:0CF8: 3B 09                        dw      ONE_PLUS
  1619 00:0CFA: EE 05                        dw      ALLOT
  1620 00:0CFC: 1A 0D                        dw      EXIT
  1621                        
  1622                        ; EXECUTE ( i*x xt -- j*x )
  1623                        ;
  1624                        ; Remove xt from the stack and perform the semantics identified by it. Other
  1625                        ; stack effects are due to the word EXECUTEd.
  1626                        
  1627 00:0CFE: D8 0C 00 07                  HEADER  7,"EXECUTE",NORMAL
       00:0D02: 45 58 45 43 
       00:0D06: 55 54 45 
  1628                        EXECUTE:
  1629 00:0D09: A6 01                        ldx     <1
  1630 00:0D0B: 7B                           tdc
  1631 00:0D0C: 1A                           inc     a
  1632 00:0D0D: 1A                           inc     a
  1633 00:0D0E: 5B                           tcd
  1634 00:0D0F: CA                           dex
  1635 00:0D10: DA                           phx
  1636 00:0D11: 60                           rts
  1637                        
  1638                        ; EXIT ( -- ) ( R: nest-sys -- )
  1639                        ;
  1640                        ; Return control to the calling definition specified by nest-sys. Before
  1641                        ; executing EXIT within a do-loop, a program shall discard the loop-control
  1642                        ; parameters by executing UNLOOP.
  1643                        
  1644 00:0D12: 01 0D 00 04                  HEADER  4,"EXIT",NORMAL
       00:0D16: 45 58 49 54 
  1645                        EXIT:
  Sun Apr 17 2016  0:51                                                                                                    Page 35


  1646 00:0D1A: 7A                           ply
  1647 00:0D1B: BB C8 C8 7C                  CONTINUE
       00:0D1F: 00 00 
  1648                        
  1649                        ; QUIT ( -- ) ( R: i*x -- )
  1650                        ;
  1651                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  1652                        ; user input device the input source, and enter interpretation state. Do not
  1653                        ; display a message. Repeat the following:
  1654                        ;  Accept a line from the input source into the input buffer, set >IN to zero,
  1655                        ;   and interpret.
  1656                        ;  Display the implementation-defined system prompt if in interpretation state,
  1657                        ;   all processing has been completed, and no ambiguous condition exists.
  1658                        ;
  1659                        ; In this implementation it is defined as:
  1660                        ;
  1661                        ;   DO_QUIT 0 STATE !
  1662                        ;   0 (SOURCE-ID) !
  1663                        ;   BEGIN
  1664                        ;     REFILL
  1665                        ;     WHILE SOURCE EVALUATE
  1666                        ;     STATE @ 0= IF S" Ok" CR TYPE THEN
  1667                        ;   AGAIN ;
  1668                        
  1669 00:0D21: 15 0D 00 04                  HEADER  4,"QUIT",NORMAL
       00:0D25: 51 55 49 54 
  1670 00:0D29: 20 B6 12     QUIT:           jsr     DO_COLON
  1671 00:0D2C: 59 0D                        dw      DO_QUIT
  1672 00:0D2E: F0 04                        dw      ZERO
  1673 00:0D30: DA 04                        dw      STATE
  1674 00:0D32: 6D 05                        dw      STORE
  1675 00:0D34: F0 04                        dw      ZERO
  1676 00:0D36: CC 04                        dw      SOURCEID
  1677 00:0D38: 6D 05                        dw      STORE
  1678 00:0D3A: 03 10        QUIT_1:         dw      REFILL
  1679 00:0D3C: 8B 12 42 0D                  dw      QUERY_BRANCH,QUIT_2
  1680 00:0D40: 1A 0F                        dw      INTERPRET
  1681 00:0D42: DA 04        QUIT_2:         dw      STATE
  1682 00:0D44: DB 05                        dw      FETCH
  1683 00:0D46: 3F 0B                        dw      ZERO_EQUAL
  1684 00:0D48: 8B 12 55 0D                  dw      QUERY_BRANCH,QUIT_3
  1685 00:0D4C: 2A 14                        dw      DO_S_QUOTE
  1686 00:0D4E: 02 4F 6B                     db      2,"Ok"
  1687 00:0D51: A3 15                        dw      TYPE
  1688 00:0D53: 26 15                        dw      CR
  1689 00:0D55: 74 12 3A 0D  QUIT_3:         dw      BRANCH,QUIT_1
  1690                        
  1691                        DO_QUIT:
  1692 00:0D59: A9 FF 01                     lda     #RSTACK_END-1           ; Reset the return stack
  1693 00:0D5C: 1B                           tcs
  1694 00:0D5D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0D61: 00 00 
  1695                        
  1696                        ;==============================================================================
  1697                        ; Parser & Interpreter
  1698                        ;------------------------------------------------------------------------------
  1699                        
  1700                        ; ?NUMBER
  Sun Apr 17 2016  0:51                                                                                                    Page 36


  1701                        ;
  1702                        ;   DUP  0 0 ROT COUNT      -- ca ud adr n
  1703                        ;   ?SIGN >R  >NUMBER       -- ca ud adr' n'
  1704                        ;   IF   R> 2DROP 2DROP 0   -- ca 0   (error)
  1705                        ;   ELSE 2DROP NIP R>
  1706                        ;       IF NEGATE THEN  -1  -- n -1   (ok)
  1707                        ;   THEN ;
  1708                        
  1709 00:0D63: 24 0D 00 07                  HEADER  7,"?NUMBER",NORMAL
       00:0D67: 3F 4E 55 4D 
       00:0D6B: 42 45 52 
  1710 00:0D6E: 20 B6 12     QUERY_NUMBER:   jsr     DO_COLON
  1711 00:0D71: 8D 07                        dw      DUP
  1712 00:0D73: F0 04                        dw      ZERO
  1713 00:0D75: F0 04                        dw      ZERO
  1714 00:0D77: E9 07                        dw      ROT
  1715 00:0D79: 17 12                        dw      COUNT
  1716 00:0D7B: AC 0D                        dw      QUERY_SIGN
  1717 00:0D7D: 6D 08                        dw      TO_R
  1718 00:0D7F: F3 0D                        dw      TO_NUMBER
  1719 00:0D81: 8B 12 91 0D                  dw      QUERY_BRANCH,QNUM_1
  1720 00:0D85: A6 08                        dw      R_FROM
  1721 00:0D87: CD 06                        dw      TWO_DROP
  1722 00:0D89: CD 06                        dw      TWO_DROP
  1723 00:0D8B: F0 04                        dw      ZERO
  1724 00:0D8D: 74 12 A1 0D                  dw      BRANCH,QNUM_3
  1725 00:0D91: CD 06        QNUM_1:         dw      TWO_DROP
  1726 00:0D93: A2 07                        dw      NIP
  1727 00:0D95: A6 08                        dw      R_FROM
  1728 00:0D97: 8B 12 9D 0D                  dw      QUERY_BRANCH,QNUM_2
  1729 00:0D9B: CB 09                        dw      NEGATE
  1730 00:0D9D: BA 13 FF FF  QNUM_2:         dw      DO_LITERAL,-1
  1731 00:0DA1: 1A 0D        QNUM_3:         dw      EXIT
  1732                        
  1733                        ; ?SIGN ( c-addr n -- adr' n' f )
  1734                        ;
  1735                        ;   OVER C@                 -- adr n c
  1736                        ;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else 0
  1737                        ;   DUP IF 1+               -- +=0, -=+2
  1738                        ;       >R 1 /STRING R>     -- adr' n' f
  1739                        ;   THEN ;
  1740                        
  1741 00:0DA3: 66 0D 00 05                  HEADER  5,"?SIGN",NORMAL
       00:0DA7: 3F 53 49 47 
       00:0DAB: 4E 
  1742 00:0DAC: 20 B6 12     QUERY_SIGN:     jsr     DO_COLON
  1743 00:0DAF: B0 07                        dw      OVER
  1744 00:0DB1: 2E 06                        dw      C_FETCH
  1745 00:0DB3: BA 13 2D 00                  dw      DO_LITERAL,'-'
  1746 00:0DB7: 08 09                        dw      MINUS
  1747 00:0DB9: 8D 07                        dw      DUP
  1748 00:0DBB: 77 09                        dw      ABS
  1749 00:0DBD: BA 13 01 00                  dw      DO_LITERAL,1
  1750 00:0DC1: A3 0B                        dw      EQUAL
  1751 00:0DC3: F7 0B                        dw      AND
  1752 00:0DC5: 8D 07                        dw      DUP
  1753 00:0DC7: 8B 12 D7 0D                  dw      QUERY_BRANCH,QSIGN_1
  1754 00:0DCB: 3B 09                        dw      ONE_PLUS
  Sun Apr 17 2016  0:51                                                                                                    Page 37


  1755 00:0DCD: 6D 08                        dw      TO_R
  1756 00:0DCF: BA 13 01 00                  dw      DO_LITERAL,1
  1757 00:0DD3: 6C 11                        dw      SLASH_STRING
  1758 00:0DD5: A6 08                        dw      R_FROM
  1759 00:0DD7: 1A 0D        QSIGN_1:        dw      EXIT
  1760                        
  1761                        ; >COUNTED ( c-addr n -- )
  1762                        ;
  1763                        ;   2DUP C! CHAR+ SWAP CMOVE
  1764                        
  1765 00:0DD9: 20 B6 12     TO_COUNTED:     jsr     DO_COLON
  1766 00:0DDC: E1 06                        dw      TWO_DUP
  1767 00:0DDE: FD 05                        dw      C_STORE
  1768 00:0DE0: 9C 06                        dw      CHAR_PLUS
  1769 00:0DE2: D4 07                        dw      SWAP
  1770 00:0DE4: B0 11                        dw      CMOVE
  1771 00:0DE6: 1A 0D                        dw      EXIT
  1772                        
  1773                        ; >NUMBER ( ud adr u -- ud' adr' u' )
  1774                        ;
  1775                        ;
  1776                        ;   BEGIN
  1777                        ;   DUP WHILE
  1778                        ;       OVER C@ DIGIT?
  1779                        ;       0= IF DROP EXIT THEN
  1780                        ;       >R 2SWAP BASE @ UD*
  1781                        ;       R> M+ 2SWAP
  1782                        ;       1 /STRING
  1783                        ;   REPEAT ;
  1784                        
  1785 00:0DE8: A6 0D 00 07                  HEADER  7,">NUMBER",NORMAL
       00:0DEC: 3E 4E 55 4D 
       00:0DF0: 42 45 52 
  1786 00:0DF3: 20 B6 12     TO_NUMBER:      jsr     DO_COLON
  1787 00:0DF6: 8D 07        TO_NUM_1:       dw      DUP
  1788 00:0DF8: 8B 12 26 0E                  dw      QUERY_BRANCH,TO_NUM_3
  1789 00:0DFC: B0 07                        dw      OVER
  1790 00:0DFE: 2E 06                        dw      C_FETCH
  1791 00:0E00: A5 0E                        dw      DIGIT_QUERY
  1792 00:0E02: 3F 0B                        dw      ZERO_EQUAL
  1793 00:0E04: 8B 12 0C 0E                  dw      QUERY_BRANCH,TO_NUM_2
  1794 00:0E08: 7C 07                        dw      DROP
  1795 00:0E0A: 1A 0D                        dw      EXIT
  1796 00:0E0C: 6D 08        TO_NUM_2:       dw      TO_R
  1797 00:0E0E: 48 07                        dw      TWO_SWAP
  1798 00:0E10: 64 04                        dw      BASE
  1799 00:0E12: DB 05                        dw      FETCH
  1800 00:0E14: 8B 0A                        dw      UD_STAR
  1801 00:0E16: A6 08                        dw      R_FROM
  1802 00:0E18: B9 0A                        dw      M_PLUS
  1803 00:0E1A: 48 07                        dw      TWO_SWAP
  1804 00:0E1C: BA 13 01 00                  dw      DO_LITERAL,1
  1805 00:0E20: 6C 11                        dw      SLASH_STRING
  1806 00:0E22: 74 12 F6 0D                  dw      BRANCH,TO_NUM_1
  1807 00:0E26: 1A 0D        TO_NUM_3:       dw      EXIT
  1808                        
  1809                        ; ACCEPT ( c-addr +n1 -- +n2 )
  1810                        ;
  Sun Apr 17 2016  0:51                                                                                                    Page 38


  1811                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  1812                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  1813                        ; received. A program that depends on the presence or absence of non-graphic
  1814                        ; characters in the string has an environmental dependency. The editing
  1815                        ; functions, if any, that the system performs in order to construct the string
  1816                        ; are implementation-defined.
  1817                        ;
  1818                        ; Input terminates when an implementation-defined line terminator is received.
  1819                        ; When input terminates, nothing is appended to the string, and the display is
  1820                        ; maintained in an implementation-defined way.
  1821                        ;
  1822                        ; +n2 is the length of the string stored at c-addr.
  1823                        ;
  1824                        ;   OVER + 1- OVER      -- sa ea a
  1825                        ;   BEGIN KEY           -- sa ea a c
  1826                        ;   DUP 0D <> WHILE
  1827                        ;     DUP 8 = OVER 127 = OR IF
  1828                        ;       DROP 1-
  1829                        ;       >R OVER R> UMAX
  1830                        ;       8 EMIT SPACE 8 EMIT
  1831                        ;     ELSE
  1832                        ;       DUP EMIT        -- sa ea a c
  1833                        ;       OVER C! 1+ OVER UMIN
  1834                        ;     THEN              -- sa ea a
  1835                        ;   REPEAT              -- sa ea a c
  1836                        ;   DROP NIP SWAP - ;
  1837                        
  1838 00:0E28: EB 0D 00 06                  HEADER  6,"ACCEPT",NORMAL
       00:0E2C: 41 43 43 45 
       00:0E30: 50 54 
  1839 00:0E32: 20 B6 12     ACCEPT:         jsr     DO_COLON
  1840 00:0E35: B0 07                        dw      OVER
  1841 00:0E37: F2 08                        dw      PLUS
  1842 00:0E39: 49 09                        dw      ONE_MINUS
  1843 00:0E3B: B0 07                        dw      OVER
  1844 00:0E3D: 55 15        ACCEPT_1:       dw      KEY
  1845 00:0E3F: 8D 07                        dw      DUP
  1846 00:0E41: BA 13 0D 00                  dw      DO_LITERAL,$0D
  1847 00:0E45: 8A 0B                        dw      NOT_EQUAL
  1848 00:0E47: 8B 12 91 0E                  dw      QUERY_BRANCH,ACCEPT_4
  1849 00:0E4B: 8D 07                        dw      DUP
  1850 00:0E4D: BA 13 08 00                  dw      DO_LITERAL,$08
  1851 00:0E51: A3 0B                        dw      EQUAL
  1852 00:0E53: B0 07                        dw      OVER
  1853 00:0E55: BA 13 7F 00                  dw      DO_LITERAL,$7f
  1854 00:0E59: A3 0B                        dw      EQUAL
  1855 00:0E5B: 50 0C                        dw      OR
  1856 00:0E5D: 8B 12 7F 0E                  dw      QUERY_BRANCH,ACCEPT_2
  1857 00:0E61: 7C 07                        dw      DROP
  1858 00:0E63: 49 09                        dw      ONE_MINUS
  1859 00:0E65: 6D 08                        dw      TO_R
  1860 00:0E67: B0 07                        dw      OVER
  1861 00:0E69: A6 08                        dw      R_FROM
  1862 00:0E6B: E1 09                        dw      UMAX
  1863 00:0E6D: BA 13 08 00                  dw      DO_LITERAL,8
  1864 00:0E71: 3F 15                        dw      EMIT
  1865 00:0E73: 71 15                        dw      SPACE
  1866 00:0E75: BA 13 08 00                  dw      DO_LITERAL,8
  Sun Apr 17 2016  0:51                                                                                                    Page 39


  1867 00:0E79: 3F 15                        dw      EMIT
  1868 00:0E7B: 74 12 8D 0E                  dw      BRANCH,ACCEPT_3
  1869 00:0E7F: 8D 07        ACCEPT_2:       dw      DUP
  1870 00:0E81: 3F 15                        dw      EMIT
  1871 00:0E83: B0 07                        dw      OVER
  1872 00:0E85: FD 05                        dw      C_STORE
  1873 00:0E87: 3B 09                        dw      ONE_PLUS
  1874 00:0E89: B0 07                        dw      OVER
  1875 00:0E8B: F5 09                        dw      UMIN
  1876 00:0E8D: 74 12 3D 0E  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  1877 00:0E91: 7C 07        ACCEPT_4:       dw      DROP
  1878 00:0E93: A2 07                        dw      NIP
  1879 00:0E95: D4 07                        dw      SWAP
  1880 00:0E97: 08 09                        dw      MINUS
  1881 00:0E99: 1A 0D                        dw      EXIT
  1882                        
  1883                        ; DIGIT?
  1884                        ;
  1885                        ;   [ HEX ] DUP 39 > 100 AND +     silly looking
  1886                        ;   DUP 140 > 107 AND -   30 -     but it works!
  1887                        ;   DUP BASE @ U< ;
  1888                        
  1889 00:0E9B: 2B 0E 00 06                  HEADER  6,"DIGIT?",NORMAL
       00:0E9F: 44 49 47 49 
       00:0EA3: 54 3F 
  1890 00:0EA5: 20 B6 12     DIGIT_QUERY:    jsr     DO_COLON
  1891 00:0EA8: 8D 07                        dw      DUP
  1892 00:0EAA: BA 13 39 00                  dw      DO_LITERAL,'9'
  1893 00:0EAE: BC 0B                        dw      GREATER
  1894 00:0EB0: BA 13 00 01                  dw      DO_LITERAL,$100
  1895 00:0EB4: F7 0B                        dw      AND
  1896 00:0EB6: F2 08                        dw      PLUS
  1897 00:0EB8: 8D 07                        dw      DUP
  1898 00:0EBA: BA 13 40 01                  dw      DO_LITERAL,$140
  1899 00:0EBE: BC 0B                        dw      GREATER
  1900 00:0EC0: BA 13 07 01                  dw      DO_LITERAL,$107
  1901 00:0EC4: F7 0B                        dw      AND
  1902 00:0EC6: 08 09                        dw      MINUS
  1903 00:0EC8: BA 13 30 00                  dw      DO_LITERAL,'0'
  1904 00:0ECC: 08 09                        dw      MINUS
  1905 00:0ECE: 8D 07                        dw      DUP
  1906 00:0ED0: 64 04                        dw      BASE
  1907 00:0ED2: DB 05                        dw      FETCH
  1908 00:0ED4: CB 0B                        dw      U_LESS
  1909 00:0ED6: 1A 0D                        dw      EXIT
  1910                        
  1911                        ; EVALUATE ( i*x c-addr u -- j*x )
  1912                        ;
  1913                        ; Save the current input source specification. Store minus-one (-1) in
  1914                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  1915                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  1916                        ; parse area is empty, restore the prior input source specification. Other
  1917                        ; stack effects are due to the words EVALUATEd.
  1918                        ;
  1919                        ;   >R >R SAVE-INPUT
  1920                        ;   -1 (SOURCE-ID) !
  1921                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  1922                        ;   INTERPRET
  Sun Apr 17 2016  0:51                                                                                                    Page 40


  1923                        ;   RESTORE-INPUT DROP
  1924                        
  1925 00:0ED8: 9E 0E 00 08                  HEADER  8,"EVALUATE",NORMAL
       00:0EDC: 45 56 41 4C 
       00:0EE0: 55 41 54 45 
  1926 00:0EE4: 20 B6 12     EVALUATE:       jsr     DO_COLON
  1927 00:0EE7: 6D 08                        dw      TO_R
  1928 00:0EE9: 6D 08                        dw      TO_R
  1929 00:0EEB: 90 10                        dw      SAVE_INPUT
  1930 00:0EED: A6 08                        dw      R_FROM
  1931 00:0EEF: A6 08                        dw      R_FROM
  1932 00:0EF1: 2E 05                        dw      TRUE
  1933 00:0EF3: CC 04                        dw      SOURCEID
  1934 00:0EF5: 6D 05                        dw      STORE
  1935 00:0EF7: F0 04                        dw      ZERO
  1936 00:0EF9: 57 04                        dw      TO_IN
  1937 00:0EFB: 6D 05                        dw      STORE
  1938 00:0EFD: AC 04                        dw      LENGTH
  1939 00:0EFF: 6D 05                        dw      STORE
  1940 00:0F01: 81 04                        dw      BUFFER
  1941 00:0F03: 6D 05                        dw      STORE
  1942 00:0F05: 1A 0F                        dw      INTERPRET
  1943 00:0F07: 41 10                        dw      RESTORE_INPUT
  1944 00:0F09: 7C 07                        dw      DROP
  1945 00:0F0B: 1A 0D                        dw      EXIT
  1946                        
  1947                        ; INTERPRET ( -- )
  1948                        ;
  1949                        ;
  1950                        ;   BEGIN
  1951                        ;   BL WORD DUP C@ WHILE        -- textadr
  1952                        ;       FIND                    -- a 0/1/-1
  1953                        ;       ?DUP IF                 -- xt 1/-1
  1954                        ;           1+ STATE @ 0= OR    immed or interp?
  1955                        ;           IF EXECUTE ELSE , THEN
  1956                        ;       ELSE                    -- textadr
  1957                        ;           ?NUMBER
  1958                        ;           IF STATE @
  1959                        ;               IF POSTPONE LITERAL THEN     converted ok
  1960                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  1961                        ;           THEN
  1962                        ;       THEN
  1963                        ;   REPEAT DROP ;
  1964                        
  1965 00:0F0D: DB 0E 00 09                  HEADER  9,"INTERPRET",NORMAL
       00:0F11: 49 4E 54 45 
       00:0F15: 52 50 52 45 
       00:0F19: 54 
  1966 00:0F1A: 20 B6 12     INTERPRET:      jsr     DO_COLON
  1967 00:0F1D: 02 05        INTERPRET_1:    dw      BL
  1968 00:0F1F: 08 11                        dw      WORD
  1969 00:0F21: 8D 07                        dw      DUP
  1970 00:0F23: 2E 06                        dw      C_FETCH
  1971 00:0F25: 8B 12 71 0F                  dw      QUERY_BRANCH,INTERPRET_7
  1972 00:0F29: 7D 0F                        dw      FIND
  1973 00:0F2B: 6A 07                        dw      QUERY_DUP
  1974 00:0F2D: 8B 12 4B 0F                  dw      QUERY_BRANCH,INTERPRET_4
  1975 00:0F31: 3B 09                        dw      ONE_PLUS
  Sun Apr 17 2016  0:51                                                                                                    Page 41


  1976 00:0F33: DA 04                        dw      STATE
  1977 00:0F35: DB 05                        dw      FETCH
  1978 00:0F37: 3F 0B                        dw      ZERO_EQUAL
  1979 00:0F39: 50 0C                        dw      OR
  1980 00:0F3B: 8B 12 45 0F                  dw      QUERY_BRANCH,INTERPRET_2
  1981 00:0F3F: 09 0D                        dw      EXECUTE
  1982 00:0F41: 74 12 47 0F                  dw      BRANCH,INTERPRET_3
  1983 00:0F45: 9B 05        INTERPRET_2:    dw      COMMA
  1984 00:0F47: 74 12 6D 0F  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  1985 00:0F4B: 6E 0D        INTERPRET_4:    dw      QUERY_NUMBER
  1986 00:0F4D: 8B 12 5F 0F                  dw      QUERY_BRANCH,INTERPRET_5
  1987 00:0F51: DA 04                        dw      STATE
  1988 00:0F53: DB 05                        dw      FETCH
  1989 00:0F55: 8B 12 6D 0F                  dw      QUERY_BRANCH,INTERPRET_6
  1990 00:0F59: A0 13                        dw      LITERAL
  1991 00:0F5B: 74 12 6D 0F                  dw      BRANCH,INTERPRET_6
  1992 00:0F5F: 17 12        INTERPRET_5:    dw      COUNT
  1993 00:0F61: A3 15                        dw      TYPE
  1994 00:0F63: BA 13 3F 00                  dw      DO_LITERAL,$3f
  1995 00:0F67: 3F 15                        dw      EMIT
  1996 00:0F69: 26 15                        dw      CR
  1997 00:0F6B: AC 0C                        dw      ABORT
  1998 00:0F6D: 74 12 1D 0F  INTERPRET_6     dw      BRANCH,INTERPRET_1
  1999 00:0F71: 7C 07        INTERPRET_7:    dw      DROP
  2000 00:0F73: 1A 0D                        dw      EXIT
  2001                        
  2002                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  2003                        ;
  2004                        ; Find the definition named in the counted string at c-addr. If the definition
  2005                        ; is not found, return c-addr and zero. If the definition is found, return its
  2006                        ; execution token xt. If the definition is immediate, also return one (1),
  2007                        ; otherwise also return minus-one (-1). For a given string, the values returned
  2008                        ; by FIND while compiling may differ from those returned while not compiling.
  2009                        ;
  2010                        ;   LATEST @ BEGIN             -- a nfa
  2011                        ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
  2012                        ;       S=                     -- a nfa f
  2013                        ;       DUP IF
  2014                        ;           DROP
  2015                        ;           NFA>LFA @ DUP      -- a link link
  2016                        ;       THEN
  2017                        ;   0= UNTIL                   -- a nfa  OR  a 0
  2018                        ;   DUP IF
  2019                        ;       NIP DUP NFA>CFA        -- nfa xt
  2020                        ;       SWAP IMMED?            -- xt iflag
  2021                        ;       0= 1 OR                -- xt 1/-1
  2022                        ;   THEN ;
  2023                        
  2024 00:0F75: 10 0F 00 04                  HEADER  4,"FIND",NORMAL
       00:0F79: 46 49 4E 44 
  2025 00:0F7D: 20 B6 12     FIND:           jsr     DO_COLON
  2026 00:0F80: 9B 04                        dw      LATEST
  2027 00:0F82: DB 05                        dw      FETCH
  2028 00:0F84: E1 06        FIND1:          dw      TWO_DUP
  2029 00:0F86: B0 07                        dw      OVER
  2030 00:0F88: 2E 06                        dw      C_FETCH
  2031 00:0F8A: 9C 06                        dw      CHAR_PLUS
  2032 00:0F8C: 58 10                        dw      S_EQUAL
  Sun Apr 17 2016  0:51                                                                                                    Page 42


  2033 00:0F8E: 8D 07                        dw      DUP
  2034 00:0F90: 8B 12 9C 0F                  dw      QUERY_BRANCH,FIND2
  2035 00:0F94: 7C 07                        dw      DROP
  2036 00:0F96: EE 0F                        dw      NFA_TO_LFA
  2037 00:0F98: DB 05                        dw      FETCH
  2038 00:0F9A: 8D 07                        dw      DUP
  2039 00:0F9C: 3F 0B        FIND2:          dw      ZERO_EQUAL
  2040 00:0F9E: 8B 12 84 0F                  dw      QUERY_BRANCH,FIND1
  2041 00:0FA2: 8D 07                        dw      DUP
  2042 00:0FA4: 8B 12 BA 0F                  dw      QUERY_BRANCH,FIND3
  2043 00:0FA8: A2 07                        dw      NIP
  2044 00:0FAA: 8D 07                        dw      DUP
  2045 00:0FAC: DA 0F                        dw      NFA_TO_CFA
  2046 00:0FAE: D4 07                        dw      SWAP
  2047 00:0FB0: C6 0F                        dw      IMMED_QUERY
  2048 00:0FB2: 3F 0B                        dw      ZERO_EQUAL
  2049 00:0FB4: BA 13 01 00                  dw      DO_LITERAL,1
  2050 00:0FB8: 50 0C                        dw      OR
  2051 00:0FBA: 1A 0D        FIND3:          dw      EXIT
  2052                        
  2053                        ; IMMED? ( nfa -- f )
  2054                        
  2055 00:0FBC: 78 0F 00 06                  HEADER  6,"IMMED?",NORMAL
       00:0FC0: 49 4D 4D 45 
       00:0FC4: 44 3F 
  2056 00:0FC6: 20 B6 12     IMMED_QUERY:    jsr     DO_COLON
  2057 00:0FC9: 49 09                        dw      ONE_MINUS
  2058 00:0FCB: 2E 06                        dw      C_FETCH
  2059 00:0FCD: 1A 0D                        dw      EXIT
  2060                        
  2061                        ; NFA>CFA ( nfa -- cfa )
  2062                        
  2063 00:0FCF: BF 0F 00 07                  HEADER  7,"NFA>CFA",NORMAL
       00:0FD3: 4E 46 41 3E 
       00:0FD7: 43 46 41 
  2064 00:0FDA: 20 B6 12     NFA_TO_CFA:     jsr     DO_COLON
  2065 00:0FDD: 17 12                        dw      COUNT
  2066 00:0FDF: F2 08                        dw      PLUS
  2067 00:0FE1: 1A 0D                        dw      EXIT
  2068                        
  2069                        ; NFA>LFA ( nfa -- lfa )
  2070                        
  2071 00:0FE3: D2 0F 00 07                  HEADER  7,"NFA>LFA",NORMAL
       00:0FE7: 4E 46 41 3E 
       00:0FEB: 4C 46 41 
  2072 00:0FEE: 20 B6 12     NFA_TO_LFA:     jsr     DO_COLON
  2073 00:0FF1: BA 13 03 00                  dw      DO_LITERAL,3
  2074 00:0FF5: 08 09                        dw      MINUS
  2075 00:0FF7: 1A 0D                        dw      EXIT
  2076                        
  2077                        ; REFILL ( -- flag )
  2078                        ;
  2079                        ; Attempt to fill the input buffer from the input source, returning a true flag
  2080                        ; if successful.
  2081                        ;
  2082                        ; When the input source is the user input device, attempt to receive input into
  2083                        ; the terminal input buffer. If successful, make the result the input buffer,
  2084                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  Sun Apr 17 2016  0:51                                                                                                    Page 43


  2085                        ; is considered successful. If there is no input available from the current
  2086                        ; input source, return false.
  2087                        ;
  2088                        ; When the input source is a string from EVALUATE, return false and perform no
  2089                        ; other action.
  2090                        ;
  2091                        ; In this implementation it is defined as:
  2092                        ;
  2093                        ;   SOURCE-ID 0= IF
  2094                        ;     TIB DUP #TIB @ ACCEPT SPACE
  2095                        ;     LENGTH ! BUFFER !
  2096                        ;     0 >IN ! TRUE EXIT
  2097                        ;   THEN
  2098                        ;   FALSE
  2099                        
  2100 00:0FF9: E6 0F 00 06                  HEADER  6,"REFILL",NORMAL
       00:0FFD: 52 45 46 49 
       00:1001: 4C 4C 
  2101 00:1003: 20 B6 12     REFILL:         jsr     DO_COLON
  2102 00:1006: F7 10                        dw      SOURCE_ID
  2103 00:1008: 3F 0B                        dw      ZERO_EQUAL
  2104 00:100A: 8B 12 2C 10                  dw      QUERY_BRANCH,REFILL_1
  2105 00:100E: E6 04                        dw      TIB
  2106 00:1010: 8D 07                        dw      DUP
  2107 00:1012: 49 04                        dw      HASH_TIB
  2108 00:1014: DB 05                        dw      FETCH
  2109 00:1016: 32 0E                        dw      ACCEPT
  2110 00:1018: 71 15                        dw      SPACE
  2111 00:101A: AC 04                        dw      LENGTH
  2112 00:101C: 6D 05                        dw      STORE
  2113 00:101E: 81 04                        dw      BUFFER
  2114 00:1020: 6D 05                        dw      STORE
  2115 00:1022: F0 04                        dw      ZERO
  2116 00:1024: 57 04                        dw      TO_IN
  2117 00:1026: 6D 05                        dw      STORE
  2118 00:1028: 2E 05                        dw      TRUE
  2119 00:102A: 1A 0D                        dw      EXIT
  2120 00:102C: 1A 05        REFILL_1:       dw      FALSE
  2121 00:102E: 1A 0D                        dw      EXIT
  2122                        
  2123                        ; RESTORE-INPUT ( xn ... x1 n -- flag )
  2124                        ;
  2125                        ; Attempt to restore the input source specification to the state described by
  2126                        ; x1 through xn. flag is true if the input source specification cannot be so
  2127                        ; restored.
  2128                        ;
  2129                        ; An ambiguous condition exists if the input source represented by the
  2130                        ; arguments is not the same as the current input source.
  2131                        ;
  2132                        ; In this implementation it is defined as:
  2133                        ;
  2134                        ;   >IN ! (LENGTH) ! BUFFER !
  2135                        ;   SOURCEID !
  2136                        ;   TRUE
  2137                        
  2138 00:1030: FC 0F 00 0D                  HEADER  13,"RESTORE-INPUT",NORMAL
       00:1034: 52 45 53 54 
       00:1038: 4F 52 45 2D 
  Sun Apr 17 2016  0:51                                                                                                    Page 44


       00:103C: 49 4E 50 55 
       00:1040: 54 
  2139 00:1041: 20 B6 12     RESTORE_INPUT   jsr     DO_COLON
  2140 00:1044: 57 04                        dw      TO_IN
  2141 00:1046: 6D 05                        dw      STORE
  2142 00:1048: AC 04                        dw      LENGTH
  2143 00:104A: 6D 05                        dw      STORE
  2144 00:104C: 81 04                        dw      BUFFER
  2145 00:104E: 6D 05                        dw      STORE
  2146 00:1050: CC 04                        dw      SOURCEID
  2147 00:1052: 6D 05                        dw      STORE
  2148 00:1054: 2E 05                        dw      TRUE
  2149 00:1056: 1A 0D                        dw      EXIT
  2150                        
  2151                        ; S= ( c-addr1 caddr2 u -- n)
  2152                        ;
  2153                        ; Misnamed, more like C's strncmp. Note that counted length bytes are compared!
  2154                        
  2155                        S_EQUAL:
  2156 00:1058: 5A                           phy
  2157 00:1059: A6 01                        ldx     <1                      ; Fetch maximum length
  2158 00:105B: F0 14                        beq     S_EQUAL_3
  2159 00:105D: A0 00 00                     ldy     #0
  2160 00:1060: E2 20                        short_a
  2161                        S_EQUAL_1:
  2162 00:1062: B1 05                        lda     (5),y                   ; Compare bytes
  2163 00:1064: D1 03                        cmp     (3),y
  2164 00:1066: D0 06                        bne     S_EQUAL_2
  2165 00:1068: C8                           iny
  2166 00:1069: CA                           dex                             ; End of strings?
  2167 00:106A: D0 F6                        bne     S_EQUAL_1               ; No
  2168 00:106C: 80 03                        bra     S_EQUAL_3               ; Yes. must be the same
  2169                        S_EQUAL_2:
  2170 00:106E: A2 FF FF                     ldx     #$ffff                  ; Difference found
  2171                        S_EQUAL_3:
  2172 00:1071: C2 20                        long_a
  2173 00:1073: 7B                           tdc                             ; Clean up the stack
  2174 00:1074: 1A                           inc     a
  2175 00:1075: 1A                           inc     a
  2176 00:1076: 1A                           inc     a
  2177 00:1077: 1A                           inc     a
  2178 00:1078: 5B                           tcd
  2179 00:1079: 86 01                        stx     <1                      ; Save the flag
  2180 00:107B: 7A                           ply
  2181 00:107C: BB C8 C8 7C                  CONTINUE
       00:1080: 00 00 
  2182                        
  2183                        ; SAVE-INPUT ( -- xn ... x1 n )
  2184                        ;
  2185                        ; x1 through xn describe the current state of the input source specification
  2186                        ; for later use by RESTORE-INPUT.
  2187                        
  2188 00:1082: 33 10 00 0A                  HEADER  10,"SAVE-INPUT",NORMAL
       00:1086: 53 41 56 45 
       00:108A: 2D 49 4E 50 
       00:108E: 55 54 
  2189 00:1090: 20 B6 12     SAVE_INPUT:     jsr     DO_COLON
  2190 00:1093: CC 04                        dw      SOURCEID
  Sun Apr 17 2016  0:51                                                                                                    Page 45


  2191 00:1095: DB 05                        dw      FETCH
  2192 00:1097: 81 04                        dw      BUFFER
  2193 00:1099: DB 05                        dw      FETCH
  2194 00:109B: AC 04                        dw      LENGTH
  2195 00:109D: DB 05                        dw      FETCH
  2196 00:109F: 57 04                        dw      TO_IN
  2197 00:10A1: DB 05                        dw      FETCH
  2198 00:10A3: 1A 0D                        dw      EXIT
  2199                        
  2200                        ; SCAN ( c-addr n c == c-addr' n' )
  2201                        
  2202                        SCAN:
  2203                        SCAN_1:
  2204 00:10A5: A5 03                        lda     <3                      ; Any data left to scan?
  2205 00:10A7: F0 10                        beq     SCAN_2                  ; No.
  2206 00:10A9: A5 01                        lda     <1                      ; Fetch and compare with scan
  2207 00:10AB: E2 20                        short_a
  2208 00:10AD: D2 05                        cmp     (5)
  2209 00:10AF: C2 20                        long_a
  2210 00:10B1: F0 06                        beq     SCAN_2
  2211 00:10B3: E6 05                        inc     <5
  2212 00:10B5: C6 03                        dec     <3
  2213 00:10B7: 80 EC                        bra     SCAN_1
  2214                        SCAN_2:
  2215 00:10B9: 4C 7C 07                     jmp     DROP                    ; Drop the character
  2216                        
  2217                        ; SKIP ( c-addr n c == c-addr' n' )
  2218                        ;
  2219                        
  2220                        SKIP:
  2221 00:10BC: A5 03        SKIP_1:         lda     <3                      ; Any data left to skip over?
  2222 00:10BE: F0 10                        beq     SKIP_2                  ; No.
  2223 00:10C0: A5 01                        lda     <1                      ; Fetch and compare with skip
  2224 00:10C2: E2 20                        short_a
  2225 00:10C4: D2 05                        cmp     (5)
  2226 00:10C6: C2 20                        long_a
  2227 00:10C8: D0 06                        bne     SKIP_2                  ; Cannot be skipped
  2228 00:10CA: E6 05                        inc     <5                      ; Bump data address
  2229 00:10CC: C6 03                        dec     <3                      ; and update length
  2230 00:10CE: 80 EC                        bra     SKIP_1                  ; And repeat
  2231                        SKIP_2:
  2232 00:10D0: 4C 7C 07                     jmp     DROP                    ; Drop the character
  2233                        
  2234                        ; SOURCE ( -- c-addr u )
  2235                        ;
  2236                        ; c-addr is the address of, and u is the number of characters in, the input
  2237                        ; buffer.
  2238                        ;
  2239                        ; In this implementation it is defined as
  2240                        ;
  2241                        ;   BUFFER @ LENGTH @
  2242                        
  2243 00:10D3: 85 10 00 06                  HEADER  6,"SOURCE",NORMAL
       00:10D7: 53 4F 55 52 
       00:10DB: 43 45 
  2244 00:10DD: 20 B6 12     SOURCE:         jsr     DO_COLON
  2245 00:10E0: 81 04                        dw      BUFFER
  2246 00:10E2: DB 05                        dw      FETCH
  Sun Apr 17 2016  0:51                                                                                                    Page 46


  2247 00:10E4: AC 04                        dw      LENGTH
  2248 00:10E6: DB 05                        dw      FETCH
  2249 00:10E8: 1A 0D                        dw      EXIT
  2250                        
  2251                        ; SOURCE-ID ( -- 0 | -1 )
  2252                        ;
  2253                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  2254                        ; device.
  2255                        
  2256 00:10EA: D6 10 00 09                  HEADER  9,"SOURCE-ID",NORMAL
       00:10EE: 53 4F 55 52 
       00:10F2: 43 45 2D 49 
       00:10F6: 44 
  2257 00:10F7: 20 B6 12     SOURCE_ID:      jsr     DO_COLON
  2258 00:10FA: CC 04                        dw      SOURCEID
  2259 00:10FC: DB 05                        dw      FETCH
  2260 00:10FE: 1A 0D                        dw      EXIT
  2261                        
  2262                        ; WORD ( char <chars>ccc<char> -- c-addr )
  2263                        ;
  2264                        ; Skip leading delimiters. Parse characters ccc delimited by char. An
  2265                        ; ambiguous condition exists if the length of the parsed string is greater
  2266                        ; than the implementation-defined length of a counted string.
  2267                        ;
  2268                        ; c-addr is the address of a transient region containing the parsed word as
  2269                        ; a counted string. If the parse area was empty or contained no characters
  2270                        ; other than the delimiter, the resulting string has a zero length. A space,
  2271                        ; not included in the length, follows the string. A program may replace
  2272                        ; characters within the string.
  2273                        ;
  2274                        ; In this implementation it is defined as:
  2275                        ;
  2276                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  2277                        ;   DUP >R   ROT SKIP           -- c adr' n'
  2278                        ;   OVER >R  ROT SCAN           -- adr" n"
  2279                        ;   DUP IF CHAR- THEN        skip trailing delim.
  2280                        ;   R> R> ROT -   >IN +!        update >IN offset
  2281                        ;   TUCK -                      -- adr' N
  2282                        ;   HERE >counted               --
  2283                        ;   HERE                        -- a
  2284                        ;   BL OVER COUNT + C! ;    append trailing blank
  2285                        
  2286 00:1100: ED 10 00 04                  HEADER  4,"WORD",NORMAL
       00:1104: 57 4F 52 44 
  2287 00:1108: 20 B6 12     WORD:           jsr     DO_COLON
  2288 00:110B: 8D 07                        dw      DUP
  2289 00:110D: DD 10                        dw      SOURCE
  2290 00:110F: 57 04                        dw      TO_IN
  2291 00:1111: DB 05                        dw      FETCH
  2292 00:1113: 6C 11                        dw      SLASH_STRING
  2293 00:1115: 8D 07                        dw      DUP
  2294 00:1117: 6D 08                        dw      TO_R
  2295 00:1119: E9 07                        dw      ROT
  2296 00:111B: BC 10                        dw      SKIP
  2297 00:111D: B0 07                        dw      OVER
  2298 00:111F: 6D 08                        dw      TO_R
  2299 00:1121: E9 07                        dw      ROT
  2300 00:1123: A5 10                        dw      SCAN
  Sun Apr 17 2016  0:51                                                                                                    Page 47


  2301 00:1125: 8D 07                        dw      DUP
  2302 00:1127: 8B 12 2D 11                  dw      QUERY_BRANCH,WORD_1
  2303 00:112B: AD 06                        dw      CHAR_MINUS
  2304 00:112D: A6 08        WORD_1:         dw      R_FROM
  2305 00:112F: A6 08                        dw      R_FROM
  2306 00:1131: E9 07                        dw      ROT
  2307 00:1133: 08 09                        dw      MINUS
  2308 00:1135: 57 04                        dw      TO_IN
  2309 00:1137: 83 05                        dw      PLUS_STORE
  2310 00:1139: 11 08                        dw      TUCK
  2311 00:113B: 08 09                        dw      MINUS
  2312 00:113D: 46 06                        dw      HERE
  2313 00:113F: D9 0D                        dw      TO_COUNTED
  2314 00:1141: 46 06                        dw      HERE
  2315 00:1143: 02 05                        dw      BL
  2316 00:1145: B0 07                        dw      OVER
  2317 00:1147: 17 12                        dw      COUNT
  2318 00:1149: F2 08                        dw      PLUS
  2319 00:114B: FD 05                        dw      C_STORE
  2320 00:114D: 1A 0D                        dw      EXIT
  2321                        
  2322                        ;==============================================================================
  2323                        ; String Words
  2324                        ;------------------------------------------------------------------------------
  2325                        
  2326                        ; -TRAILING ( c-addr u1 -- c-addr u2 )
  2327                        ;
  2328                        ; If u1 is greater than zero, u2 is equal to u1 less the number of spaces at
  2329                        ; the end of the character string specified by c-addr u1. If u1 is zero or the
  2330                        ; entire string consists of spaces, u2 is zero.
  2331                        
  2332 00:114F: 03 11 00 09                  HEADER  9,"-TRAILING",NORMAL
       00:1153: 2D 54 52 41 
       00:1157: 49 4C 49 4E 
       00:115B: 47 
  2333 00:115C: 20 B6 12     DASH_TRAILING:  jsr     DO_COLON
  2334                        ; TODO
  2335 00:115F: 1A 0D                        dw      EXIT
  2336                        
  2337                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  2338                        ;
  2339                        ; Adjust the character string at c-addr1 by n characters. The resulting
  2340                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  2341                        ; characters and is u1 minus n characters long.
  2342                        ;
  2343                        ;   ROT OVER + ROT ROT -
  2344                        
  2345 00:1161: 52 11 00 07                  HEADER  7,"/STRING",NORMAL
       00:1165: 2F 53 54 52 
       00:1169: 49 4E 47 
  2346 00:116C: 20 B6 12     SLASH_STRING:   jsr     DO_COLON
  2347 00:116F: E9 07                        dw      ROT
  2348 00:1171: B0 07                        dw      OVER
  2349 00:1173: F2 08                        dw      PLUS
  2350 00:1175: E9 07                        dw      ROT
  2351 00:1177: E9 07                        dw      ROT
  2352 00:1179: 08 09                        dw      MINUS
  2353 00:117B: 1A 0D                        dw      EXIT
  Sun Apr 17 2016  0:51                                                                                                    Page 48


  2354                        
  2355                        ; BLANK ( c-addr u -- )
  2356                        ;
  2357                        ; If u is greater than zero, store the character value for space in u
  2358                        ; consecutive character positions beginning at c-addr.
  2359                        ;
  2360                        ; In this implementation it is defined as
  2361                        ;
  2362                        ;   ?DUP IF OVER + SWAP DO BL I C! LOOP ELSE DROP THEN
  2363                        
  2364 00:117D: 64 11 00 05                  HEADER  5,"BLANK",NORMAL
       00:1181: 42 4C 41 4E 
       00:1185: 4B 
  2365 00:1186: 20 B6 12     BLANK:          jsr     DO_COLON
  2366 00:1189: 6A 07                        dw      QUERY_DUP
  2367 00:118B: 8B 12 A3 11                  dw      QUERY_BRANCH,BLANK_2
  2368 00:118F: B0 07                        dw      OVER
  2369 00:1191: F2 08                        dw      PLUS
  2370 00:1193: D4 07                        dw      SWAP
  2371 00:1195: 4D 13                        dw      DO_DO
  2372 00:1197: 02 05        BLANK_1:        dw      BL
  2373 00:1199: 7F 08                        dw      I
  2374 00:119B: FD 05                        dw      C_STORE
  2375 00:119D: EA 13 97 11                  dw      DO_LOOP,BLANK_1
  2376 00:11A1: 1A 0D                        dw      EXIT
  2377 00:11A3: 7C 07        BLANK_2:        dw      DROP
  2378 00:11A5: 1A 0D                        dw      EXIT
  2379                        
  2380                        ; CMOVE ( c-addr1 c-addr2 u -- )
  2381                        ;
  2382                        ; If u is greater than zero, copy u consecutive characters from the data space
  2383                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2384                        ; character from lower addresses to higher addresses.
  2385                        
  2386 00:11A7: 80 11 00 05                  HEADER  5,"CMOVE",NORMAL
       00:11AB: 43 4D 4F 56 
       00:11AF: 45 
  2387                        CMOVE:
  2388 00:11B0: 5A                           phy
  2389 00:11B1: A6 01                        ldx     <1                      ; Any characters to move?
  2390 00:11B3: F0 0F                        beq     CMOVE_2                 ; No
  2391 00:11B5: A0 00 00                     ldy     #0
  2392 00:11B8: E2 20                        short_a
  2393                        CMOVE_1:                                        ; Transfer a byte
  2394 00:11BA: B1 05                        lda     (5),y
  2395 00:11BC: 91 03                        sta     (3),y
  2396 00:11BE: C8                           iny
  2397 00:11BF: CA                           dex                             ; Decrement count
  2398 00:11C0: D0 F8                        bne     CMOVE_1                 ; .. and repeat until done
  2399 00:11C2: C2 20                        long_a
  2400                        CMOVE_2:
  2401 00:11C4: 7B                           tdc                             ; Clean up the stack
  2402 00:11C5: 18                           clc
  2403 00:11C6: 69 06 00                     adc     #6
  2404 00:11C9: 5B                           tcd
  2405 00:11CA: 7A                           ply
  2406 00:11CB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:11CF: 00 00 
  Sun Apr 17 2016  0:51                                                                                                    Page 49


  2407                        
  2408                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  2409                        ;
  2410                        ; If u is greater than zero, copy u consecutive characters from the data space
  2411                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2412                        ; character from higher addresses to lower addresses.
  2413                        
  2414 00:11D1: AA 11 00 06                  HEADER  6,"CMOVE>",NORMAL
       00:11D5: 43 4D 4F 56 
       00:11D9: 45 3E 
  2415                        CMOVE_GREATER:
  2416 00:11DB: 5A                           phy
  2417 00:11DC: A6 01                        ldx     <1                      ; Any characters to move?
  2418 00:11DE: F0 0E                        beq     CMOVE_GT_2              ; No.
  2419 00:11E0: A4 01                        ldy     <1
  2420 00:11E2: E2 20                        short_a
  2421                        CMOVE_GT_1:
  2422 00:11E4: 88                           dey                             ; Transfer a byte
  2423 00:11E5: B1 05                        lda     (5),y
  2424 00:11E7: 91 03                        sta     (3),y
  2425 00:11E9: CA                           dex                             ; Decrement length
  2426 00:11EA: D0 F8                        bne     CMOVE_GT_1              ; .. and repeat until done
  2427 00:11EC: C2 20                        long_a
  2428                        CMOVE_GT_2:
  2429 00:11EE: 7B                           tdc                             ; Clean up the stack
  2430 00:11EF: 18                           clc
  2431 00:11F0: 69 06 00                     adc     #6
  2432 00:11F3: 5B                           tcd
  2433 00:11F4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:11F8: 00 00 
  2434                        
  2435                        ; COMPARE ( c-addr1 u1 c-addr2 u2 -- n )
  2436                        ;
  2437                        ; Compare the string specified by c-addr1 u1 to the string specified by c-addr2
  2438                        ; u2. The strings are compared, beginning at the given addresses, character by
  2439                        ; character, up to the length of the shorter string or until a difference is
  2440                        ; found. If the two strings are identical, n is zero. If the two strings are
  2441                        ; identical up to the length of the shorter string, n is minus-one (-1) if u1
  2442                        ; is less than u2 and one (1) otherwise. If the two strings are not identical
  2443                        ; up to the length of the shorter string, n is minus-one (-1) if the first
  2444                        ; non-matching character in the string specified by c-addr1 u1 has a lesser
  2445                        ; numeric value than the corresponding character in the string specified by
  2446                        ; c-addr2 u2 and one (1) otherwise.
  2447                        
  2448 00:11FA: D4 11 00 07                  HEADER  7,"COMPARE",NORMAL
       00:11FE: 43 4F 4D 50 
       00:1202: 41 52 45 
  2449 00:1205: 20 B6 12     COMPARE:        jsr     DO_COLON
  2450                        ; TODO
  2451 00:1208: BB C8 C8 7C                  CONTINUE
       00:120C: 00 00 
  2452                        
  2453                        ; COUNT ( c-addr1 -- c-addr2 u )
  2454                        ;
  2455                        ; Return the character string specification for the counted string stored at
  2456                        ; c-addr1. c-addr2 is the address of the first character after c-addr1. u is
  2457                        ; the contents of the character at c-addr1, which is the length in characters
  2458                        ; of the string at c-addr2.
  Sun Apr 17 2016  0:51                                                                                                    Page 50


  2459                        ;
  2460                        ; In this implementation it is defined as
  2461                        ;
  2462                        ;   DUP CHAR+ SWAP C@
  2463                        
  2464 00:120E: FD 11 00 05                  HEADER  5,"COUNT",NORMAL
       00:1212: 43 4F 55 4E 
       00:1216: 54 
  2465 00:1217: 20 B6 12     COUNT:          jsr     DO_COLON
  2466 00:121A: 8D 07                        dw      DUP
  2467 00:121C: 9C 06                        dw      CHAR_PLUS
  2468 00:121E: D4 07                        dw      SWAP
  2469 00:1220: 2E 06                        dw      C_FETCH
  2470 00:1222: 1A 0D                        dw      EXIT
  2471                        
  2472                        ; SEARCH ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
  2473                        ;
  2474                        ; Search the string specified by c-addr1 u1 for the string specified by c-addr2
  2475                        ; u2. If flag is true, a match was found at c-addr3 with u3 characters
  2476                        ; remaining. If flag is false there was no match and c-addr3 is c-addr1 and u3
  2477                        ; is u1.
  2478                        
  2479 00:1224: 11 12 00 06                  HEADER  6,"SEARCH",NORMAL
       00:1228: 53 45 41 52 
       00:122C: 43 48 
  2480 00:122E: 20 B6 12     SEARCH:         jsr     DO_COLON
  2481                        ; TODO
  2482 00:1231: BB C8 C8 7C                  CONTINUE
       00:1235: 00 00 
  2483                        
  2484                        ;==============================================================================
  2485                        ; Compiling Words
  2486                        ;------------------------------------------------------------------------------
  2487                        
  2488                        ; +LOOP ( -- )
  2489                        
  2490 00:1237: 27 12 80 05                  HEADER  5,"+LOOP",IMMEDIATE
       00:123B: 2B 4C 4F 4F 
       00:123F: 50 
  2491 00:1240: 20 B6 12     PLUS_LOOP:      jsr     DO_COLON
  2492                        
  2493 00:1243: 1A 0D                        dw      EXIT
  2494                        
  2495                        ; ( ( -- )
  2496                        
  2497                        ;  [ HEX ] 29 WORD DROP ; IMMEDIATE
  2498                        
  2499 00:1245: 3A 12 80 01                  HEADER  1,"(",IMMEDIATE
       00:1249: 28 
  2500 00:124A: 20 B6 12                     jsr     DO_COLON
  2501 00:124D: BA 13 29 00                  dw      DO_LITERAL,')'
  2502 00:1251: 08 11                        dw      WORD
  2503 00:1253: 7C 07                        dw      DROP
  2504 00:1255: 1A 0D                        dw      EXIT
  2505                        
  2506                        ; (+LOOP)
  2507                        
  2508 00:1257: 48 12 00 07                  HEADER  7,"(+LOOP)",NORMAL
  Sun Apr 17 2016  0:51                                                                                                    Page 51


       00:125B: 28 2B 4C 4F 
       00:125F: 4F 50 29 
  2509                        DO_PLUS_LOOP:
  2510                        
  2511 00:1262: BB C8 C8 7C                  CONTINUE
       00:1266: 00 00 
  2512                        
  2513                        ; (BRANCH) ( -- )
  2514                        ;
  2515                        ; Cause the IP to be loaded with the word following the link to this word.
  2516                        
  2517 00:1268: 5A 12 00 08                  HEADER  8,"(BRANCH)",NORMAL
       00:126C: 28 42 52 41 
       00:1270: 4E 43 48 29 
  2518                        BRANCH:
  2519 00:1274: B9 00 00                     lda     !0,y                    ; Load branch address into IP
  2520 00:1277: A8                           tay
  2521 00:1278: BB C8 C8 7C                  CONTINUE                        ; Done
       00:127C: 00 00 
  2522                        
  2523                        ; (?BRANCH) ( flag -- )
  2524                        ;
  2525                        ; If flag is false then cause the IP to be loaded with the word following the
  2526                        ; link to this word, otherwise skip over it.
  2527                        
  2528 00:127E: 6B 12 00 09                  HEADER  9,"(?BRANCH)",NORMAL
       00:1282: 28 3F 42 52 
       00:1286: 41 4E 43 48 
       00:128A: 29 
  2529                        QUERY_BRANCH:
  2530 00:128B: A6 01                        ldx     <1                      ; Pull the top of stack value
  2531 00:128D: 7B                           tdc
  2532 00:128E: 1A                           inc     a                       ; Drop top item
  2533 00:128F: 1A                           inc     a
  2534 00:1290: 5B                           tcd
  2535 00:1291: 8A                           txa
  2536 00:1292: F0 E0                        beq     BRANCH                  ; Branch if top was zero
  2537 00:1294: C8                           iny                             ; Otherwise skip address
  2538 00:1295: C8                           iny
  2539 00:1296: BB C8 C8 7C                  CONTINUE                        ; Done
       00:129A: 00 00 
  2540                        
  2541                        ; : ( -- )
  2542                        
  2543 00:129C: 81 12 00 01                  HEADER  1,":",NORMAL
       00:12A0: 3A 
  2544 00:12A1: 20 B6 12     COLON:          jsr     DO_COLON
  2545 00:12A4: DF 0C                        dw      CREATE
  2546 00:12A6: BA 13 20 00                  dw      DO_LITERAL,$20
  2547 00:12AA: 17 06                        dw      C_COMMA
  2548 00:12AC: BA 13 B6 12                  dw      DO_LITERAL,DO_COLON
  2549 00:12B0: 9B 05                        dw      COMMA
  2550 00:12B2: 13 15                        dw      RIGHT_BRACKET
  2551 00:12B4: 1A 0D                        dw      EXIT
  2552                        
  2553                        DO_COLON:
  2554 00:12B6: FA                           plx                             ; Pull new word IP-1
  2555 00:12B7: 5A                           phy                             ; Save the old IP
  Sun Apr 17 2016  0:51                                                                                                    Page 52


  2556 00:12B8: E8                           inx                             ; Work out new IP
  2557 00:12B9: 9B                           txy
  2558 00:12BA: BB C8 C8 7C                  CONTINUE                        ; Done
       00:12BE: 00 00 
  2559                        
  2560                        ; ; ( -- )
  2561                        
  2562 00:12C0: 9F 12 80                     LINK    IMMEDIATE
  2563 00:12C3: 01 3B                        db      1,";"
  2564 00:12C5: 20 B6 12     SEMICOLON:      jsr     DO_COLON
  2565 00:12C8: BA 13 1A 0D                  dw      DO_LITERAL,EXIT
  2566 00:12CC: 9B 05                        dw      COMMA
  2567 00:12CE: 03 15                        dw      LEFT_BRACKET
  2568 00:12D0: 1A 0D                        dw      EXIT
  2569                        
  2570                        ; AGAIN ( -- )
  2571                        
  2572 00:12D2: C3 12 80 05                  HEADER  5,"AGAIN",IMMEDIATE
       00:12D6: 41 47 41 49 
       00:12DA: 4E 
  2573 00:12DB: 20 B6 12     AGAIN:          jsr     DO_COLON
  2574 00:12DE: BA 13 74 12                  dw      DO_LITERAL,BRANCH
  2575 00:12E2: 9B 05                        dw      COMMA
  2576 00:12E4: 9B 05                        dw      COMMA
  2577 00:12E6: 1A 0D                        dw      EXIT
  2578                        
  2579                        ; BEGIN ( -- )
  2580                        
  2581 00:12E8: D5 12 80 05                  HEADER  5,"BEGIN",IMMEDIATE
       00:12EC: 42 45 47 49 
       00:12F0: 4E 
  2582 00:12F1: 20 B6 12     BEGIN:          jsr     DO_COLON
  2583 00:12F4: 46 06                        dw      HERE
  2584 00:12F6: 1A 0D                        dw      EXIT
  2585                        
  2586                        ; CONSTANT ( x <spaces>name -- )
  2587                        ;
  2588                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2589                        ; definition for name with the execution semantics defined below.
  2590                        
  2591 00:12F8: EB 12 00 08                  HEADER  8,"CONSTANT",NORMAL
       00:12FC: 43 4F 4E 53 
       00:1300: 54 41 4E 54 
  2592 00:1304: 20 B6 12     CONSTANT:       jsr     DO_COLON
  2593 00:1307: DF 0C                        dw      CREATE
  2594 00:1309: BA 13 21 13                  dw      DO_LITERAL,DO_CONSTANT
  2595 00:130D: C8 0C                        dw      BUILD
  2596 00:130F: 9B 05                        dw      COMMA
  2597 00:1311: 1A 0D                        dw      EXIT
  2598                        
  2599                        ; (CONSTANT) ( -- x )
  2600                        
  2601 00:1313: FB 12 00 0A                  HEADER  10,"(CONSTANT)",NORMAL
       00:1317: 28 43 4F 4E 
       00:131B: 53 54 41 4E 
       00:131F: 54 29 
  2602                        DO_CONSTANT:
  2603 00:1321: FA                           plx
  Sun Apr 17 2016  0:51                                                                                                    Page 53


  2604 00:1322: 7B                           tdc
  2605 00:1323: 3A                           dec     a
  2606 00:1324: 3A                           dec     a
  2607 00:1325: 5B                           tcd
  2608 00:1326: BD 01 00                     lda     !1,x
  2609 00:1329: 85 01                        sta     <1
  2610 00:132B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:132F: 00 00 
  2611                        
  2612                        ; DO ( -- )
  2613                        
  2614 00:1331: 16 13 80 02                  HEADER  2,"DO",IMMEDIATE
       00:1335: 44 4F 
  2615 00:1337: 20 B6 12     DO:             jsr     DO_COLON
  2616 00:133A: BA 13 4D 13                  dw      DO_LITERAL,DO_DO
  2617 00:133E: 9B 05                        dw      COMMA
  2618 00:1340: 46 06                        dw      HERE
  2619 00:1342: 1A 0D                        dw      EXIT
  2620                        
  2621                        ; (DO) ( -- )
  2622                        
  2623 00:1344: 34 13 00 04                  HEADER  4,"(DO)",NORMAL
       00:1348: 28 44 4F 29 
  2624 00:134C: 00                           db
  2625                        DO_DO:
  2626 00:134D: A5 03                        lda     <3
  2627 00:134F: 48                           pha
  2628 00:1350: A5 01                        lda     <1
  2629 00:1352: 48                           pha
  2630 00:1353: 7B                           tdc
  2631 00:1354: 1A                           inc     a
  2632 00:1355: 1A                           inc     a
  2633 00:1356: 1A                           inc     a
  2634 00:1357: 1A                           inc     a
  2635 00:1358: 5B                           tcd
  2636 00:1359: BB C8 C8 7C                  CONTINUE
       00:135D: 00 00 
  2637                        
  2638                        ; ELSE ( -- )
  2639                        
  2640 00:135F: 47 13 80 04                  HEADER  4,"ELSE",IMMEDIATE
       00:1363: 45 4C 53 45 
  2641 00:1367: 20 B6 12     ELSE:           jsr     DO_COLON
  2642 00:136A: BA 13 74 12                  dw      DO_LITERAL,BRANCH
  2643 00:136E: 9B 05                        dw      COMMA
  2644 00:1370: 46 06                        dw      HERE
  2645 00:1372: F0 04                        dw      ZERO
  2646 00:1374: 9B 05                        dw      COMMA
  2647 00:1376: 46 06                        dw      HERE
  2648 00:1378: D4 07                        dw      SWAP
  2649 00:137A: 6D 05                        dw      STORE
  2650 00:137C: 1A 0D                        dw      EXIT
  2651                        
  2652                        ; IF ( -- )
  2653                        
  2654 00:137E: 62 13 80 02                  HEADER  2,"IF",IMMEDIATE
       00:1382: 49 46 
  2655 00:1384: 20 B6 12     IF:             jsr     DO_COLON
  Sun Apr 17 2016  0:51                                                                                                    Page 54


  2656 00:1387: BA 13 8B 12                  dw      DO_LITERAL,QUERY_BRANCH
  2657 00:138B: 9B 05                        dw      COMMA
  2658 00:138D: 46 06                        dw      HERE
  2659 00:138F: F0 04                        dw      ZERO
  2660 00:1391: 9B 05                        dw      COMMA
  2661 00:1393: 1A 0D                        dw      EXIT
  2662                        
  2663                        ; LITERAL ( x -- )
  2664                        ;
  2665                        ; Append the run-time semantics given below to the current definition.
  2666                        
  2667 00:1395: 81 13 80 07                  HEADER  7,"LITERAL",IMMEDIATE
       00:1399: 4C 49 54 45 
       00:139D: 52 41 4C 
  2668 00:13A0: 20 B6 12     LITERAL:        jsr     DO_COLON
  2669 00:13A3: BA 13 BA 13                  dw      DO_LITERAL,DO_LITERAL
  2670 00:13A7: 9B 05                        dw      COMMA
  2671 00:13A9: 9B 05                        dw      COMMA
  2672 00:13AB: 1A 0D                        dw      EXIT
  2673                        
  2674                        ; (LITERAL) ( -- x )
  2675                        ;
  2676                        ; Place x on the stack.
  2677                        
  2678 00:13AD: 98 13 00 09                  HEADER  9,"(LITERAL)",NORMAL
       00:13B1: 28 4C 49 54 
       00:13B5: 45 52 41 4C 
       00:13B9: 29 
  2679                        DO_LITERAL:
  2680 00:13BA: 7B                           tdc
  2681 00:13BB: 3A                           dec     a
  2682 00:13BC: 3A                           dec     a
  2683 00:13BD: 5B                           tcd
  2684 00:13BE: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  2685 00:13C1: C8                           iny
  2686 00:13C2: C8                           iny
  2687 00:13C3: 85 01                        sta     <1
  2688 00:13C5: BB C8 C8 7C                  CONTINUE                        ; Done
       00:13C9: 00 00 
  2689                        
  2690                        ; LOOP
  2691                        
  2692 00:13CB: B0 13 80 04                  HEADER  4,"LOOP",IMMEDIATE
       00:13CF: 4C 4F 4F 50 
  2693 00:13D3: 20 B6 12     LOOP:           jsr     DO_COLON
  2694 00:13D6: BA 13 EA 13                  dw      DO_LITERAL,DO_LOOP
  2695 00:13DA: 9B 05                        dw      COMMA
  2696 00:13DC: 9B 05                        dw      COMMA
  2697 00:13DE: 1A 0D                        dw      EXIT
  2698                        
  2699                        ; (LOOP)
  2700                        
  2701 00:13E0: CE 13 00 06                  HEADER  6,"(LOOP)",NORMAL
       00:13E4: 28 4C 4F 4F 
       00:13E8: 50 29 
  2702                        DO_LOOP
  2703 00:13EA: A3 01                        lda     1,s                     ; Add one to loop counter
  2704 00:13EC: 1A                           inc     a
  Sun Apr 17 2016  0:51                                                                                                    Page 55


  2705 00:13ED: 83 01                        sta     1,s
  2706 00:13EF: C3 03                        cmp     3,s                     ; Reached limit?
  2707 00:13F1: B0 0A                        bcs     DO_LOOP_END             ; Yes
  2708 00:13F3: B9 00 00                     lda     !0,y                    ; No, branch back to start
  2709 00:13F6: A8                           tay
  2710 00:13F7: BB C8 C8 7C                  CONTINUE                        ; Done
       00:13FB: 00 00 
  2711                        
  2712 00:13FD: C8           DO_LOOP_END:    iny                             ; Skip over address
  2713 00:13FE: C8                           iny
  2714 00:13FF: 68                           pla                             ; Drop loop variables
  2715 00:1400: 68                           pla
  2716 00:1401: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1405: 00 00 
  2717                        
  2718                        ; RECURSE ( -- )
  2719                        
  2720 00:1407: E3 13 80 07                  HEADER  7,"RECURSE",IMMEDIATE
       00:140B: 52 45 43 55 
       00:140F: 52 53 45 
  2721 00:1412: 20 B6 12     RECURSE:        jsr     DO_COLON
  2722 00:1415: 9B 04                        dw      LATEST
  2723 00:1417: DB 05                        dw      FETCH
  2724 00:1419: DA 0F                        dw      NFA_TO_CFA
  2725 00:141B: 9B 05                        dw      COMMA
  2726 00:141D: 1A 0D                        dw      EXIT
  2727                        
  2728                        ; S"
  2729                        
  2730 00:141F: 0A 14 80                     LINK    IMMEDIATE
  2731 00:1422: 02 53 22                     db      2,"S",'"'
  2732 00:1425: 20 B6 12     S_QUOTE:        jsr     DO_COLON
  2733 00:1428: 1A 0D                        dw      EXIT
  2734                        
  2735                        ; (S") ( -- c-addr u )
  2736                        
  2737                        DO_S_QUOTE:
  2738 00:142A: 7B                           tdc
  2739 00:142B: 3A                           dec     a                       ; Reserve space for values
  2740 00:142C: 3A                           dec     a
  2741 00:142D: 3A                           dec     a
  2742 00:142E: 3A                           dec     a
  2743 00:142F: 5B                           tcd
  2744 00:1430: E2 20                        short_a
  2745 00:1432: B9 00 00                     lda     !0,y                    ; Fetch the length
  2746 00:1435: 85 01                        sta     <1
  2747 00:1437: 64 02                        stz     <2
  2748 00:1439: C2 20                        long_a
  2749 00:143B: C8                           iny
  2750 00:143C: 98                           tya                             ; Save the text address
  2751 00:143D: 85 03                        sta     <3
  2752 00:143F: 18                           clc                             ; And update IP
  2753 00:1440: 65 01                        adc     <1
  2754 00:1442: A8                           tay
  2755 00:1443: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1447: 00 00 
  2756                        
  2757                        ; THEN ( -- )
  Sun Apr 17 2016  0:51                                                                                                    Page 56


  2758                        
  2759 00:1449: 22 14 80 04                  HEADER  4,"THEN",IMMEDIATE
       00:144D: 54 48 45 4E 
  2760 00:1451: 20 B6 12     THEN:           jsr     DO_COLON
  2761 00:1454: 46 06                        dw      HERE
  2762 00:1456: D4 07                        dw      SWAP
  2763 00:1458: 6D 05                        dw      STORE
  2764 00:145A: 1A 0D                        dw      EXIT
  2765                        
  2766                        ; UNTIL ( -- )
  2767                        
  2768 00:145C: 4C 14 80 05                  HEADER  5,"UNTIL",IMMEDIATE
       00:1460: 55 4E 54 49 
       00:1464: 4C 
  2769 00:1465: 20 B6 12     UNTIL:          jsr     DO_COLON
  2770 00:1468: BA 13 8B 12                  dw      DO_LITERAL,QUERY_BRANCH
  2771 00:146C: 9B 05                        dw      COMMA
  2772 00:146E: 9B 05                        dw      COMMA
  2773 00:1470: 1A 0D                        dw      EXIT
  2774                        
  2775                        ; USER
  2776                        
  2777 00:1472: 5F 14 00 04                  HEADER  4,"USER",NORMAL
       00:1476: 55 53 45 52 
  2778 00:147A: 20 B6 12     USER:           jsr     DO_COLON
  2779 00:147D: DF 0C                        dw      CREATE
  2780 00:147F: BA 13 93 14                  dw      DO_LITERAL,DO_USER
  2781 00:1483: C8 0C                        dw      BUILD
  2782 00:1485: 9B 05                        dw      COMMA
  2783 00:1487: 1A 0D                        dw      EXIT
  2784                        
  2785 00:1489: 75 14 00 06                  HEADER  6,"(USER)",NORMAL
       00:148D: 28 55 53 45 
       00:1491: 52 29 
  2786                        DO_USER:
  2787 00:1493: 7B                           tdc
  2788 00:1494: 3A                           dec     a                       ; Push on data stack
  2789 00:1495: 3A                           dec     a
  2790 00:1496: 5B                           tcd
  2791 00:1497: FA                           plx
  2792 00:1498: 18                           clc
  2793 00:1499: BD 01 00                     lda     !1,x
  2794 00:149C: 69 00 00                     adc     #USER_AREA
  2795 00:149F: 85 01                        sta     <1
  2796 00:14A1: BB C8 C8 7C                  CONTINUE                        ; Done
       00:14A5: 00 00 
  2797                        
  2798                        ; VARIABLE ( <spaces>name -- )
  2799                        ;
  2800                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2801                        ; definition for name with the execution semantics defined below. Reserve one
  2802                        ; cell of data space at an aligned address.
  2803                        
  2804 00:14A7: 8C 14 00                     LINK    NORMAL
  2805 00:14AA: 08 56 41 52                  db      8,"VARIABLE"
       00:14AE: 49 41 42 4C 
       00:14B2: 45 
  2806 00:14B3: 20 B6 12     VARIABLE:       jsr     DO_COLON
  Sun Apr 17 2016  0:51                                                                                                    Page 57


  2807 00:14B6: DF 0C                        dw      CREATE
  2808 00:14B8: BA 13 C8 14                  dw      DO_LITERAL,DO_VARIABLE
  2809 00:14BC: C8 0C                        dw      BUILD
  2810 00:14BE: BA 13 01 00                  dw      DO_LITERAL,1
  2811 00:14C2: 8B 06                        dw      CELLS
  2812 00:14C4: EE 05                        dw      ALLOT
  2813 00:14C6: 1A 0D                        dw      EXIT
  2814                        
  2815                        DO_VARIABLE:
  2816 00:14C8: 7B                           tdc
  2817 00:14C9: 3A                           dec     a
  2818 00:14CA: 3A                           dec     a
  2819 00:14CB: 5B                           tcd
  2820 00:14CC: 68                           pla
  2821 00:14CD: 1A                           inc     a
  2822 00:14CE: 85 01                        sta     <1
  2823 00:14D0: BB C8 C8 7C                  CONTINUE
       00:14D4: 00 00 
  2824                        
  2825                        ; WORDS ( -- )
  2826                        ;
  2827                        ;   LATEST @ BEGIN
  2828                        ;       DUP COUNT TYPE SPACE
  2829                        ;       NFA>LFA @
  2830                        ;   DUP 0= UNTIL
  2831                        ;   DROP ;
  2832                        
  2833 00:14D6: AA 14 00 05                  HEADER  5,"WORDS",NORMAL
       00:14DA: 57 4F 52 44 
       00:14DE: 53 
  2834 00:14DF: 20 B6 12                     jsr     DO_COLON
  2835 00:14E2: 9B 04                        dw      LATEST
  2836 00:14E4: DB 05                        dw      FETCH
  2837 00:14E6: 8D 07        WORDS_1:        dw      DUP
  2838 00:14E8: 17 12                        dw      COUNT
  2839 00:14EA: A3 15                        dw      TYPE
  2840 00:14EC: 71 15                        dw      SPACE
  2841 00:14EE: EE 0F                        dw      NFA_TO_LFA
  2842 00:14F0: DB 05                        dw      FETCH
  2843 00:14F2: 8D 07                        dw      DUP
  2844 00:14F4: 3F 0B                        dw      ZERO_EQUAL
  2845 00:14F6: 8B 12 E6 14                  dw      QUERY_BRANCH,WORDS_1
  2846 00:14FA: 7C 07                        dw      DROP
  2847 00:14FC: 1A 0D                        dw      EXIT
  2848                        
  2849                        ; [
  2850                        ;
  2851                        ; In this implementation it is defined as
  2852                        ;
  2853                        ;   0 STATE !
  2854                        
  2855 00:14FE: D9 14 80 01                  HEADER  1,"[",IMMEDIATE
       00:1502: 5B 
  2856 00:1503: 20 B6 12     LEFT_BRACKET:   jsr     DO_COLON
  2857 00:1506: F0 04                        dw      ZERO
  2858 00:1508: DA 04                        dw      STATE
  2859 00:150A: 6D 05                        dw      STORE
  2860 00:150C: 1A 0D                        dw      EXIT
  Sun Apr 17 2016  0:51                                                                                                    Page 58


  2861                        
  2862                        ; ]
  2863                        ;
  2864                        ; In this implementation it is defined as
  2865                        ;
  2866                        ;   -1 STATE !
  2867                        
  2868 00:150E: 01 15 00 01                  HEADER  1,"]",NORMAL
       00:1512: 5D 
  2869 00:1513: 20 B6 12     RIGHT_BRACKET:  jsr     DO_COLON
  2870 00:1516: BA 13 FF FF                  dw      DO_LITERAL,-1
  2871 00:151A: DA 04                        dw      STATE
  2872 00:151C: 6D 05                        dw      STORE
  2873 00:151E: 1A 0D                        dw      EXIT
  2874                        
  2875                        ;==============================================================================
  2876                        ; I/O Operations
  2877                        ;------------------------------------------------------------------------------
  2878                        
  2879                        ; CR ( -- )
  2880                        ;
  2881                        ; Cause subsequent output to appear at the beginning of the next line.
  2882                        ;
  2883                        ; In this implementation it is defined as
  2884                        ;
  2885                        ;   13 EMIT 10 EMIT
  2886                        
  2887 00:1520: 11 15 00 02                  HEADER  2,"CR",NORMAL
       00:1524: 43 52 
  2888 00:1526: 20 B6 12     CR:             jsr     DO_COLON
  2889 00:1529: BA 13 0D 00                  dw      DO_LITERAL,13
  2890 00:152D: 3F 15                        dw      EMIT
  2891 00:152F: BA 13 0A 00                  dw      DO_LITERAL,10
  2892 00:1533: 3F 15                        dw      EMIT
  2893 00:1535: 1A 0D                        dw      EXIT
  2894                        
  2895                        ; EMIT ( x -- )
  2896                        ;
  2897                        ; If x is a graphic character in the implementation-defined character set,
  2898                        ; display x. The effect of EMIT for all other values of x is implementation
  2899                        ; -defined.
  2900                        
  2901 00:1537: 23 15 00 04                  HEADER  4,"EMIT",NORMAL
       00:153B: 45 4D 49 54 
  2902                                        extern  UartTx
  2903                        EMIT:
  2904 00:153F: A5 01                        lda     <1                      ; Fetch character from stack
  2905 00:1541: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  2906 00:1544: 7B                           tdc
  2907 00:1545: 1A                           inc     a                       ; Drop the character
  2908 00:1546: 1A                           inc     a
  2909 00:1547: 5B                           tcd
  2910 00:1548: BB C8 C8 7C                  CONTINUE                        ; Done
       00:154C: 00 00 
  2911                        
  2912                        ; KEY ( -- char )
  2913                        ;
  2914                        ; Receive one character char, a member of the implementation-defined character
  Sun Apr 17 2016  0:51                                                                                                    Page 59


  2915                        ; set. Keyboard events that do not correspond to such characters are discarded
  2916                        ; until a valid character is received, and those events are subsequently
  2917                        ; unavailable.
  2918                        ;
  2919                        ; All standard characters can be received. Characters received by KEY are not
  2920                        ; displayed.
  2921                        
  2922 00:154E: 3A 15 00 03                  HEADER  3,"KEY",NORMAL
       00:1552: 4B 45 59 
  2923                                        extern  UartRx
  2924                        KEY:
  2925 00:1555: 20 xx xx                     jsr     UartRx                  ; Receive a character
  2926 00:1558: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  2927 00:155B: AA                           tax
  2928 00:155C: 7B                           tdc
  2929 00:155D: 3A                           dec     a                       ; And push to stack
  2930 00:155E: 3A                           dec     a
  2931 00:155F: 5B                           tcd
  2932 00:1560: 86 01                        stx     <1
  2933 00:1562: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1566: 00 00 
  2934                        
  2935                        ; SPACE ( -- )
  2936                        ;
  2937                        ; Display one space.
  2938                        ;
  2939                        ; In this implementation it is defined as
  2940                        ;
  2941                        ;   BL EMIT
  2942                        
  2943 00:1568: 51 15 00 05                  HEADER  5,"SPACE",NORMAL
       00:156C: 53 50 41 43 
       00:1570: 45 
  2944 00:1571: 20 B6 12     SPACE:          jsr     DO_COLON
  2945 00:1574: 02 05                        dw      BL
  2946 00:1576: 3F 15                        dw      EMIT
  2947 00:1578: 1A 0D                        dw      EXIT
  2948                        
  2949                        ; SPACES ( n -- )
  2950                        ;
  2951                        ; If n is greater than zero, display n spaces.
  2952                        ;
  2953                        ; In this implementation it is defined as
  2954                        ;
  2955                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  2956                        
  2957 00:157A: 6B 15 00 06                  HEADER  6,"SPACES",NORMAL
       00:157E: 53 50 41 43 
       00:1582: 45 53 
  2958 00:1584: 20 B6 12     SPACES:         jsr     DO_COLON
  2959 00:1587: 8D 07        SPACES_1:       dw      DUP
  2960 00:1589: 53 0B                        dw      ZERO_GREATER
  2961 00:158B: 8B 12 97 15                  dw      QUERY_BRANCH,SPACES_2
  2962 00:158F: 71 15                        dw      SPACE
  2963 00:1591: 49 09                        dw      ONE_MINUS
  2964 00:1593: 74 12 87 15                  dw      BRANCH,SPACES_1
  2965 00:1597: 7C 07        SPACES_2:       dw      DROP
  2966 00:1599: 1A 0D                        dw      EXIT
  Sun Apr 17 2016  0:51                                                                                                    Page 60


  2967                        
  2968                        ; TYPE ( c-addr u -- )
  2969                        ;
  2970                        ; If u is greater than zero, display the character string specified by c-addr
  2971                        ; and u.
  2972                        ;
  2973                        ; In this implementation it is defined as
  2974                        ;
  2975                        ;   ?DUP IF
  2976                        ;     OVER + SWAP DO I C@ EMIT LOOP
  2977                        ;   ELSE DROP THEN
  2978                        
  2979 00:159B: 7D 15 00 04                  HEADER  4,"TYPE",NORMAL
       00:159F: 54 59 50 45 
  2980 00:15A3: 20 B6 12     TYPE:           jsr     DO_COLON
  2981 00:15A6: 6A 07                        dw      QUERY_DUP
  2982 00:15A8: 8B 12 C2 15                  dw      QUERY_BRANCH,TYPE_2
  2983 00:15AC: B0 07                        dw      OVER
  2984 00:15AE: F2 08                        dw      PLUS
  2985 00:15B0: D4 07                        dw      SWAP
  2986 00:15B2: 4D 13                        dw      DO_DO
  2987 00:15B4: 7F 08        TYPE_1:         dw      I
  2988 00:15B6: 2E 06                        dw      C_FETCH
  2989 00:15B8: 3F 15                        dw      EMIT
  2990 00:15BA: EA 13 B4 15                  dw      DO_LOOP,TYPE_1
  2991 00:15BE: 74 12 C4 15                  dw      BRANCH,TYPE_3
  2992 00:15C2: 7C 07        TYPE_2          dw      DROP
  2993 00:15C4: 1A 0D        TYPE_3          dw      EXIT
  2994                        
  2995                        ;================================================================================
  2996                        ;--------------------------------------------------------------------------------
  2997                        
  2998                        ; #
  2999                        ; #>
  3000                        ; #S
  3001                        ; SIGN
  3002                        
  3003                        ;================================================================================
  3004                        ; Debugging Words
  3005                        ;--------------------------------------------------------------------------------
  3006                        
  3007                        ; .NYBBLE
  3008                        
  3009 00:15C6: 9E 15 00 07                  HEADER  7,".NYBBLE",NORMAL
       00:15CA: 2E 4E 59 42 
       00:15CE: 42 4C 45 
  3010                        DOT_NYBBLE:
  3011 00:15D1: A5 01                        lda     <1
  3012 00:15D3: 29 0F 00                     and     #$000f
  3013 00:15D6: 09 30 00                     ora     #$0030
  3014 00:15D9: C9 3A 00                     cmp     #$003a
  3015 00:15DC: 90 03                        bcc     $+5
  3016 00:15DE: 69 06 00                     adc     #$0006
  3017 00:15E1: 20 xx xx                     jsr     UartTx
  3018 00:15E4: 4C 7C 07                     jmp     DROP
  3019                        
  3020                        ; .BYTE
  3021                        
  Sun Apr 17 2016  0:51                                                                                                    Page 61


  3022 00:15E7: C9 15 00 05                  HEADER  5,".BYTE",NORMAL
       00:15EB: 2E 42 59 54 
       00:15EF: 45 
  3023 00:15F0: 20 B6 12     DOT_BYTE:       jsr     DO_COLON
  3024 00:15F3: 8D 07                        dw      DUP
  3025 00:15F5: BA 13 04 00                  dw      DO_LITERAL,4
  3026 00:15F9: 6A 0C                        dw      RSHIFT
  3027 00:15FB: D1 15                        dw      DOT_NYBBLE
  3028 00:15FD: D1 15                        dw      DOT_NYBBLE
  3029 00:15FF: 71 15                        dw      SPACE
  3030 00:1601: 1A 0D                        dw      EXIT
  3031                        
  3032                        ; .WORD
  3033                        
  3034 00:1603: EA 15 00 05                  HEADER  5,".WORD",NORMAL
       00:1607: 2E 57 4F 52 
       00:160B: 44 
  3035 00:160C: 20 B6 12     DOT_WORD:       jsr     DO_COLON
  3036 00:160F: 8D 07                        dw      DUP
  3037 00:1611: BA 13 0C 00                  dw      DO_LITERAL,12
  3038 00:1615: 6A 0C                        dw      RSHIFT
  3039 00:1617: D1 15                        dw      DOT_NYBBLE
  3040 00:1619: 8D 07                        dw      DUP
  3041 00:161B: BA 13 08 00                  dw      DO_LITERAL,8
  3042 00:161F: 6A 0C                        dw      RSHIFT
  3043 00:1621: D1 15                        dw      DOT_NYBBLE
  3044 00:1623: 8D 07                        dw      DUP
  3045 00:1625: BA 13 04 00                  dw      DO_LITERAL,4
  3046 00:1629: 6A 0C                        dw      RSHIFT
  3047 00:162B: D1 15                        dw      DOT_NYBBLE
  3048 00:162D: D1 15                        dw      DOT_NYBBLE
  3049 00:162F: 71 15                        dw      SPACE
  3050 00:1631: 1A 0D                        dw      EXIT
  3051                        
  3052                        ; .DP
  3053                        
  3054 00:1633: 06 16 00 03                  HEADER  3,".DP",NORMAL
       00:1637: 2E 44 50 
  3055 00:163A: 20 B6 12                     jsr     DO_COLON
  3056 00:163D: 5A 16                        dw      AT_DP
  3057 00:163F: 0C 16                        dw      DOT_WORD
  3058 00:1641: 1A 0D                        dw      EXIT
  3059                        
  3060 00:1643: 36 16 00 03                  HEADER  3,".RP",NORMAL
       00:1647: 2E 52 50 
  3061 00:164A: 20 B6 12                     jsr     DO_COLON
  3062 00:164D: 6F 16                        dw      AT_RP
  3063 00:164F: 0C 16                        dw      DOT_WORD
  3064 00:1651: 1A 0D                        dw      EXIT
  3065                        
  3066 00:1653: 46 16 00 03                  HEADER  3,"@DP",NORMAL
       00:1657: 40 44 50 
  3067                        AT_DP:
  3068 00:165A: 0B                           phd
  3069 00:165B: 7B                           tdc
  3070 00:165C: 3A                           dec     a
  3071 00:165D: 3A                           dec     a
  3072 00:165E: 5B                           tcd
  Sun Apr 17 2016  0:51                                                                                                    Page 62


  3073 00:165F: 68                           pla
  3074 00:1660: 85 01                        sta     <1
  3075 00:1662: BB C8 C8 7C                  CONTINUE
       00:1666: 00 00 
  3076                        
  3077 00:1668: 56 16 00 03                  HEADER  3,"@RP",NORMAL
       00:166C: 40 52 50 
  3078                        AT_RP:
  3079 00:166F: 7B                           tdc
  3080 00:1670: 3A                           dec     a
  3081 00:1671: 3A                           dec     a
  3082 00:1672: 5B                           tcd
  3083 00:1673: BA                           tsx
  3084 00:1674: 86 01                        stx     <1
  3085 00:1676: BB C8 C8 7C                  CONTINUE
       00:167A: 00 00 
  3086                        
  3087                                        include "device.asm"
     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; Device Specific Words for the W65C816SXB
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ;------------------------------------------------------------------------------
    23                        
    24 00:167C: 20 B6 12     TITLE:		jsr	DO_COLON	
    25 00:167F: 2A 14                        dw      DO_S_QUOTE
    26 00:1681: 1C 57 36 35                  db      28,"W65C816SXB ANS-Forth [16.04]"
       00:1685: 43 38 31 36 
       00:1689: 53 58 42 20 
       00:168D: 41 4E 53 2D 
       00:1691: 46 6F 72 74 
       00:1695: 68 20 5B 31 
       00:1699: 36 2E 30 34 
       00:169D: 5D 
    27 00:169E: 1A 0D        		dw	EXIT
    28                        		
    29                        ;-------------------------------------------------------------------------------
    30                        		
    31 00:16A0: 6B 16 00 08  		HEADER	8,"ACIA$RXD",NORMAL
       00:16A4: 41 43 49 41 
       00:16A8: 24 52 58 44 
  Sun Apr 17 2016  0:51                                                                                                    Page 63


    32 00:16AC: 20 21 13     		jsr	DO_CONSTANT
    33 00:16AF: 80 7F        		dw	$7f80
    34                        		
    35 00:16B1: A3 16 00 08  		HEADER	8,"ACIA$TXD",NORMAL
       00:16B5: 41 43 49 41 
       00:16B9: 24 54 58 44 
    36 00:16BD: 20 21 13     		jsr	DO_CONSTANT
    37 00:16C0: 80 7F        		dw	$7f80
    38                        		
    39 00:16C2: B4 16 00 07  		HEADER	7,"ACIA$SR",NORMAL
       00:16C6: 41 43 49 41 
       00:16CA: 24 53 52 
    40 00:16CD: 20 21 13     		jsr	DO_CONSTANT
    41 00:16D0: 81 7F        		dw     	$7f81
    42                        		
    43 00:16D2: C5 16 00 08  		HEADER	8,"ACIA$CMD",NORMAL
       00:16D6: 41 43 49 41 
       00:16DA: 24 43 4D 44 
    44 00:16DE: 20 21 13     		jsr	DO_CONSTANT
    45 00:16E1: 82 7F        		dw     	$7f82
    46                        		
    47 00:16E3: D5 16 00 08  		HEADER	8,"ACIA$CTL",NORMAL
       00:16E7: 41 43 49 41 
       00:16EB: 24 43 54 4C 
    48 00:16EF: 20 21 13     		jsr	DO_CONSTANT
    49 00:16F2: 83 7F        		dw	$7f83
    50                        
    51                        ;-------------------------------------------------------------------------------
    52                        
    53 00:16F4: E6 16 00 07  		HEADER	7,"PIA$PIA",NORMAL
       00:16F8: 50 49 41 24 
       00:16FC: 50 49 41 
    54 00:16FF: 20 21 13     		jsr	DO_CONSTANT
    55 00:1702: A0 7F        		dw      $7fa0
    56                        		
    57 00:1704: F7 16 00 08  		HEADER	8,"PIA$DDRA",NORMAL
       00:1708: 50 49 41 24 
       00:170C: 44 44 52 41 
    58 00:1710: 20 21 13     		jsr	DO_CONSTANT
    59 00:1713: A0 7F        		dw	$7fa0
    60                        		
    61 00:1715: 07 17 00 07  		HEADER	7,"PIA$CRA",NORMAL
       00:1719: 50 49 41 24 
       00:171D: 43 52 41 
    62 00:1720: 20 21 13     		jsr	DO_CONSTANT
    63 00:1723: A1 7F        		dw      $7fa1
    64                        		
    65 00:1725: 18 17 00 07  		HEADER	7,"PIA$PIB",NORMAL
       00:1729: 50 49 41 24 
       00:172D: 50 49 42 
    66 00:1730: 20 21 13     		jsr	DO_CONSTANT
    67 00:1733: A2 7F        		dw      $7fa2
    68                        		
    69 00:1735: 28 17 00 08  		HEADER	8,"PIA$DDRB",NORMAL
       00:1739: 50 49 41 24 
       00:173D: 44 44 52 42 
    70 00:1741: 20 21 13     		jsr	DO_CONSTANT
    71 00:1744: A2 7F        		dw      $7fa2
  Sun Apr 17 2016  0:51                                                                                                    Page 64


    72                        		
    73 00:1746: 38 17 00 07  		HEADER	7,"PIA$CRB",NORMAL
       00:174A: 50 49 41 24 
       00:174E: 43 52 42 
    74 00:1751: 20 21 13     		jsr	DO_CONSTANT
    75 00:1754: A3 7F        		dw      $7fa3
    76                        
    77                        ;-------------------------------------------------------------------------------
    78                        
    79 00:1756: 49 17 00 08  		HEADER	8,"VIA1$ORB",NORMAL
       00:175A: 56 49 41 31 
       00:175E: 24 4F 52 42 
    80 00:1762: 20 21 13     		jsr	DO_CONSTANT
    81 00:1765: C0 7F        		dw      $7fc0
    82                        		
    83 00:1767: C0 7F        VIA1_IRB        dw      $7fc0
    84 00:1769: C1 7F        VIA1_ORA        dw      $7fc1
    85 00:176B: C1 7F        VIA1_IRA        dw      $7fc1
    86 00:176D: C2 7F        VIA1_DDRB       dw      $7fc2
    87 00:176F: C3 7F        VIA1_DDRA       dw      $7fc3
    88 00:1771: C4 7F        VIA1_T1CL       dw      $7fc4
    89 00:1773: C5 7F        VIA1_T1CH       dw      $7fc5
    90 00:1775: C6 7F        VIA1_T1LL       dw      $7fc6
    91 00:1777: C7 7F        VIA1_T1LH       dw      $7fc7
    92 00:1779: C8 7F        VIA1_T2CL       dw      $7fc8
    93 00:177B: C9 7F        VIA1_T2CH       dw      $7fc9
    94 00:177D: CA 7F        VIA1_SR         dw      $7fca
    95 00:177F: CB 7F        VIA1_ACR        dw      $7fcb
    96 00:1781: CC 7F        VIA1_PCR        dw      $7fcc
    97 00:1783: CD 7F        VIA1_IFR        dw      $7fcd
    98 00:1785: CE 7F        VIA1_IER        dw      $7fce
    99 00:1787: CF 7F        VIA1_ORAN       dw      $7fcf
   100 00:1789: CF 7F        VIA1_IRAN       dw      $7fcf
   101                        
   102                        ;-------------------------------------------------------------------------------
   103                        
   104 00:178B: E0 7F        VIA2_ORB        dw      $7fe0
   105 00:178D: E0 7F        VIA2_IRB        dw      $7fe0
   106 00:178F: E1 7F        VIA2_ORA        dw      $7fe1
   107 00:1791: E1 7F        VIA2_IRA        dw      $7fe1
   108 00:1793: E2 7F        VIA2_DDRB       dw      $7fe2
   109 00:1795: E3 7F        VIA2_DDRA       dw      $7fe3
   110 00:1797: E4 7F        VIA2_T1CL       dw      $7fe4
   111 00:1799: E5 7F        VIA2_T1CH       dw      $7fe5
   112 00:179B: E6 7F        VIA2_T1LL       dw      $7fe6
   113 00:179D: E7 7F        VIA2_T1LH       dw      $7fe7
   114 00:179F: E8 7F        VIA2_T2CL       dw      $7fe8
   115 00:17A1: E9 7F        VIA2_T2CH       dw      $7fe9
   116 00:17A3: EA 7F        VIA2_SR         dw      $7fea
   117 00:17A5: EB 7F        VIA2_ACR        dw      $7feb
   118 00:17A7: EC 7F        VIA2_PCR        dw      $7fec
   119 00:17A9: ED 7F        VIA2_IFR        dw      $7fed
   120 00:17AB: EE 7F        VIA2_IER        dw      $7fee
   121 00:17AD: EF 7F        VIA2_ORAN       dw      $7fef
   122 00:17AF: EF 7F        VIA2_IRAN       dw      $7fef
  3088                        
  3089                                        TRAILER
  3090                        NEXT_WORD:
  Sun Apr 17 2016  0:51                                                                                                    Page 65


  3091                        
  3092                                        end


      Lines assembled: 4876
      Errors: 0
