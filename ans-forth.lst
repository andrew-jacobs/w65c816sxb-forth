  Fri Mar 18 2016 23:20                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The Forth data stack is DP
    27                        ;
    28                        ; The Y register holds the forth instruction pointer and the direct page
    29                        ; register is used to access the word address pointer and user variables.
    30                        ;
    31                        ; Some of the high-level definitions are based on Bradford J. Rodriguez's
    32                        ; CamelForth implementations.
    33                        ;
    34                        ;==============================================================================
    35                        ;------------------------------------------------------------------------------
    36                        
    37                                        pw      132
    38                                        inclist on
    39                                        maclist off
    40                        
    41                                        chip    65816
    42                                        longi   off
    43                                        longa   off
    44                        
    45                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
     7                        ;
  Fri Mar 18 2016 23:20                                                                                                    Page 2


     8                        ; Western Design Center W65C816 device definitions                                          
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;===============================================================================
    25                        ; Revision History:
    26                        ;
    27                        ; 2015-12-18 AJ Initial version
    28                        ;-------------------------------------------------------------------------------
    29                        ; $Id$
    30                        ;-------------------------------------------------------------------------------
    31                        
    32                        ;==============================================================================
    33                        ; Status Register Bits
    34                        ;------------------------------------------------------------------------------
    35                        
    36             00000080   N_FLAG          equ     1<<7
    37             00000040   V_FLAG          equ     1<<6
    38             00000020   M_FLAG          equ     1<<5
    39             00000010   X_FLAG          equ     1<<4
    40             00000010   B_FLAG          equ     1<<4
    41             00000008   D_FLAG          equ     1<<3
    42             00000004   I_FLAG          equ     1<<2
    43             00000002   Z_FLAG          equ     1<<1
    44             00000001   C_FLAG          equ     1<<0
    45                        
    46                        ;==============================================================================
    47                        ; Macros
    48                        ;------------------------------------------------------------------------------
    49                        
    50                        ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
    51                        ; is fixed at $0100-$01ff. 
    52                        
    53                        emulate         macro
    54                                        sec
    55                                        xce
    56                                        endm
    57                        
    58                        ; Puts the processor in native mode. The size of the memory and index register
    59                        ; operations is not controlled by the M & X bits in the status register.
    60                        
    61                        native          macro
    62                                        clc
    63                                        xce
    64                                        endm
    65                        
  Fri Mar 18 2016 23:20                                                                                                    Page 3


    66                        ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
    67                         
    68                        long_a          macro
    69                                        rep     #M_FLAG
    70                                        longa   on
    71                                        endm
    72                        
    73                        ; Resets the X bit making the index registers 16-bits wide
    74                        
    75                        long_i          macro
    76                                        rep     #X_FLAG
    77                                        longi   on
    78                                        endm
    79                        
    80                        ; Resets the M and X bits making the accumulator, memory accesses and index
    81                        ; registers 16-bits wide.
    82                                        
    83                        long_ai         macro
    84                                        rep     #M_FLAG|X_FLAG
    85                                        longa   on
    86                                        longi   on
    87                                        endm
    88                        
    89                        ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
    90                        
    91                        short_a         macro
    92                                        sep     #M_FLAG
    93                                        longa   off
    94                                        endm
    95                        
    96                        ; Sets the X bit making the index registers 8-bits wide.
    97                        
    98                        short_i         macro
    99                                        sep     #X_FLAG
   100                                        longi   off
   101                                        endm
   102                                        
   103                        ; Sets the M & X bits making the accumulator, memory accesses and index
   104                        ; registers 8-bits wide.
   105                        
   106                        short_ai        macro
   107                                        sep     #M_FLAG|X_FLAG
   108                                        longa   off
   109                                        longi   off
   110                                        endm
    46                        
    47                        ;==============================================================================
    48                        ; Macros
    49                        ;------------------------------------------------------------------------------
    50                        
    51                        ; The LINK macro deposits the link section of a word header automatically
    52                        ; linking the new word to the last.
    53                        
    54             00000000   WORDZ           set     0                       ; Word counter
    55             00000000   WORD0           equ     0                       ; Null address for first word
    56                        
    57                        LINK            macro   TYPE
    58                                        dw      WORD@<WORDZ>            ; Link
  Fri Mar 18 2016 23:20                                                                                                    Page 4


    59                                        db      TYPE                    ; Type
    60                        WORDZ           set     WORDZ+1
    61                        WORD@<WORDZ>:
    62                                        endm
    63                        
    64                        ; Deposits a word header containing the name which is linked back to the
    65                        ; previous word.
    66                        ;
    67                        ; The WDC assembler does not handle string parameters to macros very well,
    68                        ; stopping at the first comma or space in them, so some headers must be
    69                        ; manually constructed.
    70                        
    71             00000000   NORMAL          equ     $00
    72             00000080   IMMEDIATE       equ     $80
    73                        
    74                        HEADER          macro   LEN,NAME,TYPE
    75                                        LINK    TYPE
    76                                        db      LEN,NAME
    77                                        endm
    78                        
    79                        ; The CONTINUE macro is used at the end of a native word to invoke the next
    80                        ; word pointer.
    81                        
    82                        CONTINUE        macro
    83                                        tyx                             ; Copy IP to X
    84                                        iny
    85                                        iny
    86                                        jmp     (0,x)                   ; Then execute word
    87                                        endm
    88                        
    89                        TRAILER         macro
    90                        LAST_WORD       equ     WORD@<WORDZ>
    91                                        endm
    92                        
    93                        ;==============================================================================
    94                        ; Definitions
    95                        ;------------------------------------------------------------------------------
    96                        
    97             00000014   USER_SIZE       equ     20
    98             00000080   DSTACK_SIZE     equ     128
    99             00000080   RSTACK_SIZE     equ     128
   100                        
   101             00000000   TO_IN_OFFSET    equ     0
   102             00000002   BASE_OFFSET     equ     2
   103             00000004   BLK_OFFSET      equ     4
   104             00000006   DP_OFFSET       equ     6
   105             00000008   LATEST_OFFSET   equ     8
   106             0000000A   SCR_OFFSET      equ     10
   107             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
   108             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
   109             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
   110             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
   111                        
   112             00000080   TIB_SIZE        equ     128
   113                        
   114                        ;==============================================================================
   115                        ; Data Areas
   116                        ;------------------------------------------------------------------------------
  Fri Mar 18 2016 23:20                                                                                                    Page 5


   117                        
   118                                        page0
   119                                        org     $00
   120                        
   121 00:0000:              USER_AREA       ds      USER_SIZE               ; User Variables
   122                        
   123                        
   124             00000100   DSTACK_START    equ     $0100
   125             00000180   DSTACK_END      equ     DSTACK_START+DSTACK_SIZE
   126                        
   127             00000180   RSTACK_START    equ     $0180
   128             00000200   RSTACK_END      equ     RSTACK_START+RSTACK_SIZE
   129                        
   130                        
   131                                        data
   132                                        org     $0200
   133                        
   134 00:0200:              TIB_AREA        ds      TIB_SIZE                ; Terminal Input Buffer
   135                        
   136                        ;==============================================================================
   137                        ; Forth Entry Point
   138                        ;------------------------------------------------------------------------------
   139                        
   140                        FORTH           section OFFSET $0400
   141                        
   142                                        public  Start
   143                        Start:
   144 00:0400: 18 FB                        native                          ; Go to native mode
   145 00:0402: C2 30                        long_ai                         ; And all 16-bit registers
   146 00:0404: A9 FF 01                     lda     #RSTACK_END-1           ; Initialise return stack
   147 00:0407: 1B                           tcs
   148 00:0408: A9 7F 01                     lda     #DSTACK_END-1           ; .. and data stack
   149 00:040B: 5B                           tcd
   150                        
   151 00:040C: A0 15 04                     ldy     #COLD                   ; Then perform COLD start
   152 00:040F: BB C8 C8 7C                  CONTINUE
       00:0413: 00 00 
   153                        
   154                        COLD:
   155 00:0415: 47 05                        dw      DECIMAL
   156 00:0417: F0 04                        dw      ZERO
   157 00:0419: 70 04                        dw      BLK
   158 00:041B: 6D 05                        dw      STORE
   159 00:041D: 1A 05                        dw      FALSE
   160 00:041F: DA 04                        dw      STATE
   161 00:0421: 6D 05                        dw      STORE
   162 00:0423: DF 12                        dw      DO_LITERAL
   163 00:0425: A5 16                        dw      NEXT_WORD
   164 00:0427: 8C 04                        dw      DP
   165 00:0429: 6D 05                        dw      STORE
   166 00:042B: DF 12                        dw      DO_LITERAL
   167 00:042D: 4D 16                        dw      LAST_WORD
   168 00:042F: 9B 04                        dw      LATEST
   169 00:0431: 6D 05                        dw      STORE
   170 00:0433: 1A 14                        dw      CR
   171 00:0435: 1A 14                        dw      CR
   172 00:0437: 70 15                        dw      TITLE
   173 00:0439: 97 14                        dw      TYPE
  Fri Mar 18 2016 23:20                                                                                                    Page 6


   174 00:043B: 1A 14                        dw      CR
   175 00:043D: 1A 14                        dw      CR
   176 00:043F: 63 0C                        dw      ABORT
   177                        
   178                        ;==============================================================================
   179                        ; System/User Variables
   180                        ;------------------------------------------------------------------------------
   181                        
   182                        ; #TIB ( -- a-addr )
   183                        ;
   184                        ; a-addr is the address of a cell containing the number of characters in the
   185                        ; terminal input buffer.
   186                        
   187 00:0441: 00 00 00 04                  HEADER  4,"#TIB",NORMAL
       00:0445: 23 54 49 42 
   188 00:0449: 20 6C 12     HASH_TIB:       jsr     DO_CONSTANT
   189 00:044C: 4E 04                        dw      $+2
   190 00:044E: 7E 00                        dw      TIB_SIZE-2
   191                        
   192                        ; >IN ( -- a-addr )
   193                        ;
   194                        ; a-addr is the address of a cell containing the offset in characters from the
   195                        ; start of the input buffer to the start of the parse area.
   196                        
   197 00:0450: 44 04 00 03                  HEADER  3,">IN",NORMAL
       00:0454: 3E 49 4E 
   198 00:0457: 20 87 13     TO_IN:          jsr     DO_USER
   199 00:045A: 00 00                        dw      TO_IN_OFFSET
   200                        
   201                        ; BASE ( -- a-addr )
   202                        ;
   203                        ; a-addr is the address of a cell containing the current number-conversion
   204                        ; radix {{2...36}}.
   205                        
   206 00:045C: 53 04 00 04                  HEADER  4,"BASE",NORMAL
       00:0460: 42 41 53 45 
   207 00:0464: 20 87 13     BASE:           jsr     DO_USER
   208 00:0467: 02 00                        dw      BASE_OFFSET
   209                        
   210                        ; BLK ( -- a-addr )
   211                        ;
   212                        ; a-addr is the address of a cell containing zero or the number of the mass-
   213                        ; storage block being interpreted. If BLK contains zero, the input source is
   214                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   215                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   216                        
   217 00:0469: 5F 04 00 03                  HEADER  3,"BLK",NORMAL
       00:046D: 42 4C 4B 
   218 00:0470: 20 87 13     BLK:            jsr     DO_USER
   219 00:0473: 04 00                        dw      BLK_OFFSET
   220                        
   221                        ; (BUFFER)
   222                        
   223 00:0475: 6C 04 00 08                  HEADER  8,"(BUFFER)",NORMAL
       00:0479: 28 42 55 46 
       00:047D: 46 45 52 29 
   224 00:0481: 20 87 13     BUFFER:         jsr     DO_USER
   225 00:0484: 10 00                        dw      BUFFER_OFFSET
  Fri Mar 18 2016 23:20                                                                                                    Page 7


   226                        
   227                        ; DP ( -- a-addr )
   228                        ;
   229                        ; Dictionary Pointer
   230                        
   231 00:0486: 78 04 00 02                  HEADER  2,"DP",NORMAL
       00:048A: 44 50 
   232 00:048C: 20 87 13     DP:             jsr     DO_USER
   233 00:048F: 06 00                        dw      DP_OFFSET
   234                        
   235                        ; LATEST ( -- a-addr )
   236                        
   237 00:0491: 89 04 00 06                  HEADER  6,"LATEST",NORMAL
       00:0495: 4C 41 54 45 
       00:0499: 53 54 
   238 00:049B: 20 87 13     LATEST:         jsr     DO_USER
   239 00:049E: 08 00                        dw      LATEST_OFFSET
   240                        
   241                        ; (LENGTH)
   242                        
   243 00:04A0: 94 04 00 08                  HEADER  8,"(LENGTH)",NORMAL
       00:04A4: 28 4C 45 4E 
       00:04A8: 47 54 48 29 
   244 00:04AC: 20 87 13     LENGTH:         jsr     DO_USER
   245 00:04AF: 12 00                        dw      LENGTH_OFFSET
   246                        
   247                        ; SCR ( -- a-addr )
   248                        ;
   249                        ; a-addr is the address of a cell containing the block number of the block most
   250                        ; recently LISTed.
   251                        
   252 00:04B1: A3 04 00 03                  HEADER  3,"SCR",NORMAL
       00:04B5: 53 43 52 
   253 00:04B8: 20 87 13     SCR:            jsr     DO_USER
   254 00:04BB: 0A 00                        dw      SCR_OFFSET
   255                        
   256                        ; (SOURCE-ID)
   257                        
   258 00:04BD: B4 04 00 0B                  HEADER  11,"(SOURCE-ID)",NORMAL
       00:04C1: 28 53 4F 55 
       00:04C5: 52 43 45 2D 
       00:04C9: 49 44 29 
   259 00:04CC: 20 87 13     SOURCEID:       jsr     DO_USER
   260 00:04CF: 0C 00                        dw      SOURCEID_OFFSET
   261                        
   262                        ; STATE ( -- a-addr )
   263                        ;
   264                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   265                        ; is true when in compilation state, false otherwise. The true value in STATE
   266                        ; is non-zero, but is otherwise implementation-defined.
   267                        
   268 00:04D1: C0 04 00 05                  HEADER  5,"STATE",NORMAL
       00:04D5: 53 54 41 54 
       00:04D9: 45 
   269 00:04DA: 20 87 13     STATE:          jsr     DO_USER
   270 00:04DD: 0E 00                        dw      STATE_OFFSET
   271                        
   272                        ; TIB ( -- c-addr )
  Fri Mar 18 2016 23:20                                                                                                    Page 8


   273                        ;
   274                        ; c-addr is the address of the terminal input buffer.
   275                        
   276 00:04DF: D4 04 00 03                  HEADER  3,"TIB",NORMAL
       00:04E3: 54 49 42 
   277 00:04E6: 20 6C 12     TIB:            jsr     DO_CONSTANT
   278 00:04E9: 00 02                        dw      TIB_AREA
   279                        
   280                        ;==============================================================================
   281                        ; Constants
   282                        ;------------------------------------------------------------------------------
   283                        
   284                        ; 0 ( -- 0 )
   285                        ;
   286                        ; Push the constant value zero on the stack
   287                        
   288 00:04EB: E2 04 00 01                  HEADER  1,"0",NORMAL
       00:04EF: 30 
   289                        ZERO:
   290 00:04F0: 7B                           tdc
   291 00:04F1: 3A                           dec     a                       ; Make space on the stack
   292 00:04F2: 3A                           dec     a
   293 00:04F3: 5B                           tcd
   294 00:04F4: 64 01                        stz     <1                      ; And create a zero value
   295 00:04F6: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04FA: 00 00 
   296                        
   297                        ; BL ( -- char )
   298                        ;
   299                        ; char is the character value for a space.
   300                        
   301 00:04FC: EE 04 00 02                  HEADER  2,"BL",NORMAL
       00:0500: 42 4C 
   302                        BL:
   303 00:0502: 7B                           tdc
   304 00:0503: 3A                           dec     a                       ; Make space on the stack
   305 00:0504: 3A                           dec     a
   306 00:0505: 5B                           tcd
   307 00:0506: A9 20 00                     lda     #' '                    ; And save a space value
   308 00:0509: 85 01                        sta     <1
   309 00:050B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:050F: 00 00 
   310                        
   311                        ; FALSE ( -- false )
   312                        ;
   313                        ; Return a false flag.
   314                        
   315 00:0511: FF 04 00 05                  HEADER  5,"FALSE",NORMAL
       00:0515: 46 41 4C 53 
       00:0519: 45 
   316                        FALSE:
   317 00:051A: 7B                           tdc
   318 00:051B: 3A                           dec     a                       ; Make space on the stack
   319 00:051C: 3A                           dec     a
   320 00:051D: 5B                           tcd
   321 00:051E: 64 01                        stz     <1                      ; And create a false value
   322 00:0520: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0524: 00 00 
  Fri Mar 18 2016 23:20                                                                                                    Page 9


   323                        
   324                        ; TRUE ( -- true )
   325                        ;
   326                        ; Return a true flag, a single-cell value with all bits set.
   327                        
   328 00:0526: 14 05 00 04                  HEADER  4,"TRUE",NORMAL
       00:052A: 54 52 55 45 
   329                        TRUE:
   330 00:052E: 7B                           tdc
   331 00:052F: 3A                           dec     a                       ; Make space on the stack
   332 00:0530: 3A                           dec     a
   333 00:0531: 5B                           tcd
   334 00:0532: 64 01                        stz     <1                      ; And create a true value
   335 00:0534: C6 01                        dec     <1
   336 00:0536: BB C8 C8 7C                  CONTINUE                        ; Done
       00:053A: 00 00 
   337                        
   338                        ;==============================================================================
   339                        ; Radix
   340                        ;------------------------------------------------------------------------------
   341                        
   342                        ; DECIMAL ( -- )
   343                        ;
   344                        ; Set the numeric conversion radix to ten (decimal).
   345                        
   346 00:053C: 29 05 00 07                  HEADER  7,"DECIMAL",NORMAL
       00:0540: 44 45 43 49 
       00:0544: 4D 41 4C 
   347 00:0547: 20 1D 12     DECIMAL:        jsr     DO_COLON
   348 00:054A: DF 12 0A 00                  dw      DO_LITERAL,10
   349 00:054E: 64 04                        dw      BASE
   350 00:0550: 6D 05                        dw      STORE
   351 00:0552: C7 0C                        dw      EXIT
   352                        
   353                        ; HEX ( -- )
   354                        ;
   355                        ; Set contents of BASE to sixteen.
   356                        
   357 00:0554: 3F 05 00 03                  HEADER  3,"HEX",NORMAL
       00:0558: 48 45 58 
   358 00:055B: 20 1D 12     HEX:            jsr     DO_COLON
   359 00:055E: DF 12 10 00                  dw      DO_LITERAL,16
   360 00:0562: 64 04                        dw      BASE
   361 00:0564: 6D 05                        dw      STORE
   362 00:0566: C7 0C                        dw      EXIT
   363                        
   364                        ;==============================================================================
   365                        ; Memory Operations
   366                        ;------------------------------------------------------------------------------
   367                        
   368                        ; ! ( x a-addr -- )
   369                        ;
   370                        ; Store x at a-addr.
   371                        
   372 00:0568: 57 05 00 01                  HEADER  1,"!",NORMAL
       00:056C: 21 
   373                        STORE:
   374 00:056D: A5 03                        lda     <3                      ; Fetch data value
  Fri Mar 18 2016 23:20                                                                                                    Page 10


   375 00:056F: 92 01                        sta     (1)                     ; .. and store
   376 00:0571: 7B                           tdc                             ; Clean up data stack
   377 00:0572: 1A                           inc     a
   378 00:0573: 1A                           inc     a
   379 00:0574: 1A                           inc     a
   380 00:0575: 1A                           inc     a
   381 00:0576: 5B                           tcd
   382 00:0577: BB C8 C8 7C                  CONTINUE                        ; Done
       00:057B: 00 00 
   383                        
   384                        ; +! ( n|u a-addr -- )
   385                        ;
   386                        ; Add n|u to the single-cell number at a-addr.
   387                        
   388 00:057D: 6B 05 00 02                  HEADER  2,"+!",NORMAL
       00:0581: 2B 21 
   389                        PLUS_STORE:
   390 00:0583: 18                           clc
   391 00:0584: A5 03                        lda     <3                      ; Fetch data value
   392 00:0586: 72 01                        adc     (1)
   393 00:0588: 92 01                        sta     (1)
   394 00:058A: 7B                           tdc                             ; Clean up data stack
   395 00:058B: 1A                           inc     a
   396 00:058C: 1A                           inc     a
   397 00:058D: 1A                           inc     a
   398 00:058E: 1A                           inc     a
   399 00:058F: 5B                           tcd
   400 00:0590: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0594: 00 00 
   401                        
   402                        ; , ( x -- )
   403                        ;
   404                        ; Reserve one cell of data space and store x in the cell. If the data-space
   405                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   406                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   407                        ; is not aligned prior to execution of ,.
   408                        ;
   409                        ;   HERE ! 1 CELLS ALLOT
   410                        
   411 00:0596: 80 05 00                     LINK    NORMAL
   412 00:0599: 01 2C                        db      1,","
   413 00:059B: 20 1D 12     COMMA:          jsr     DO_COLON
   414 00:059E: 46 06                        dw      HERE
   415 00:05A0: 6D 05                        dw      STORE
   416 00:05A2: DF 12 01 00                  dw      DO_LITERAL,1
   417 00:05A6: 8B 06                        dw      CELLS
   418 00:05A8: EE 05                        dw      ALLOT
   419 00:05AA: C7 0C                        dw      EXIT
   420                        
   421                        ; 2! ( x1 x2 a-addr -- )
   422                        ;
   423                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   424                        ; consecutive cell. It is equivalent to the sequence SWAP OVER ! CELL+ !.
   425                        
   426 00:05AC: 99 05 00 02                  HEADER  2,"2!",NORMAL
       00:05B0: 32 21 
   427 00:05B2: 20 1D 12     TWO_STORE:      jsr     DO_COLON
   428 00:05B5: 99 07                        dw      SWAP
  Fri Mar 18 2016 23:20                                                                                                    Page 11


   429 00:05B7: 83 07                        dw      OVER
   430 00:05B9: 6D 05                        dw      STORE
   431 00:05BB: 78 06                        dw      CELL_PLUS
   432 00:05BD: 6D 05                        dw      STORE
   433 00:05BF: C7 0C                        dw      EXIT
   434                        
   435                        ; 2@ ( a-addr -- x1 x2 )
   436                        ;
   437                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   438                        ; the next consecutive cell. It is equivalent to the sequence DUP CELL+ @ SWAP
   439                        ; @.
   440                        
   441 00:05C1: AF 05 00 02                  HEADER  2,"2@",NORMAL
       00:05C5: 32 40 
   442 00:05C7: 20 1D 12     TWO_FETCH:      jsr     DO_COLON
   443 00:05CA: 60 07                        dw      DUP
   444 00:05CC: 78 06                        dw      CELL_PLUS
   445 00:05CE: DB 05                        dw      FETCH
   446 00:05D0: 99 07                        dw      SWAP
   447 00:05D2: DB 05                        dw      FETCH
   448 00:05D4: C7 0C                        dw      EXIT
   449                        
   450                        ; @ ( a-addr -- x )
   451                        ;
   452                        ; x is the value stored at a-addr.
   453                        
   454 00:05D6: C4 05 00 01                  HEADER  1,"@",NORMAL
       00:05DA: 40 
   455                        FETCH:
   456 00:05DB: B2 01                        lda     (1)                     ; Fetch from memory
   457 00:05DD: 85 01                        sta     <1                      ; .. and replace top value
   458 00:05DF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05E3: 00 00 
   459                        
   460                        ; ALLOT ( n -- )
   461                        ;
   462                        ; If n is greater than zero, reserve n address units of data space. If n is
   463                        ; less than zero, release |n| address units of data space. If n is zero, leave
   464                        ; the data-space pointer unchanged.
   465                        ;
   466                        ; In this implementation its is defined as:
   467                        ;
   468                        ;   DP +!
   469                        
   470 00:05E5: D9 05 00 05                  HEADER  5,"ALLOT",NORMAL
       00:05E9: 41 4C 4C 4F 
       00:05ED: 54 
   471 00:05EE: 20 1D 12     ALLOT:          jsr     DO_COLON
   472 00:05F1: 8C 04                        dw      DP
   473 00:05F3: 83 05                        dw      PLUS_STORE
   474 00:05F5: C7 0C                        dw      EXIT
   475                        
   476                        ; C! ( char c-addr -- )
   477                        ;
   478                        ; Store char at c-addr. When character size is smaller than cell size, only the
   479                        ; number of low-order bits corresponding to character size are transferred.
   480                        
   481 00:05F7: E8 05 00 02                  HEADER  2,"C!",NORMAL
  Fri Mar 18 2016 23:20                                                                                                    Page 12


       00:05FB: 43 21 
   482                        C_STORE:
   483 00:05FD: A5 03                        lda     <3                      ; Fetch the data value
   484 00:05FF: E2 20                        short_a
   485 00:0601: 92 01                        sta     (1)                     ; And store it
   486 00:0603: C2 20                        long_a
   487 00:0605: 7B                           tdc                             ; Clean up the stack
   488 00:0606: 1A                           inc     a
   489 00:0607: 1A                           inc     a
   490 00:0608: 1A                           inc     a
   491 00:0609: 1A                           inc     a
   492 00:060A: 5B                           tcd
   493 00:060B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:060F: 00 00 
   494                        
   495                        ; C, ( char -- )
   496                        ;
   497                        ; Reserve space for one character in the data space and store char in the
   498                        ; space. If the data-space pointer is character aligned when C, begins
   499                        ; execution, it will remain character aligned when C, finishes execution.
   500                        ; An ambiguous condition exists if the data-space pointer is not character-
   501                        ; aligned prior to execution of C,
   502                        ;
   503                        ;   HERE C! 1 CHARS ALLOT
   504                        
   505 00:0611: FA 05 00                     LINK    NORMAL
   506 00:0614: 02 43 2C                     db      2,"C,"
   507 00:0617: 20 1D 12     C_COMMA:        jsr     DO_COLON
   508 00:061A: 46 06                        dw      HERE
   509 00:061C: FD 05                        dw      C_STORE
   510 00:061E: DF 12 01 00                  dw      DO_LITERAL,1
   511 00:0622: BE 06                        dw      CHARS
   512 00:0624: EE 05                        dw      ALLOT
   513 00:0626: C7 0C                        dw      EXIT
   514                        
   515                        ; C@ ( c-addr -- char )
   516                        ;
   517                        ; Fetch the character stored at c-addr. When the cell size is greater than
   518                        ; character size, the unused high-order bits are all zeroes.
   519                        
   520 00:0628: 14 06 00 02                  HEADER  2,"C@",NORMAL
       00:062C: 43 40 
   521                        C_FETCH:
   522 00:062E: E2 20                        short_a
   523 00:0630: B2 01                        lda     (1)                     ; Fetch the data byte
   524 00:0632: 85 01                        sta     <1                      ; .. and replace stack value
   525 00:0634: 64 02                        stz     <2
   526 00:0636: C2 20                        long_a
   527 00:0638: BB C8 C8 7C                  CONTINUE                        ; Done
       00:063C: 00 00 
   528                        
   529                        ; HERE ( -- addr )
   530                        ;
   531                        ; addr is the data-space pointer.
   532                        
   533 00:063E: 2B 06 00 04                  HEADER  4,"HERE",NORMAL
       00:0642: 48 45 52 45 
   534 00:0646: 20 1D 12     HERE:           jsr     DO_COLON
  Fri Mar 18 2016 23:20                                                                                                    Page 13


   535 00:0649: 8C 04                        dw      DP
   536 00:064B: DB 05                        dw      FETCH
   537 00:064D: C7 0C                        dw      EXIT
   538                        
   539                        ;==============================================================================
   540                        ; Alignment
   541                        ;------------------------------------------------------------------------------
   542                        
   543                        ; ALIGN ( -- )
   544                        ;
   545                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   546                        
   547 00:064F: 41 06 00 05                  HEADER  5,"ALIGN",NORMAL
       00:0653: 41 4C 49 47 
       00:0657: 4E 
   548                        ALIGN:
   549 00:0658: BB C8 C8 7C                  CONTINUE                        ; Done
       00:065C: 00 00 
   550                        
   551                        ; ALIGNED ( addr -- a-addr )
   552                        ;
   553                        ; a-addr is the first aligned address greater than or equal to addr.
   554                        
   555 00:065E: 52 06 00 07                  HEADER  7,"ALIGNED",NORMAL
       00:0662: 41 4C 49 47 
       00:0666: 4E 45 44 
   556                        ALIGNED:
   557 00:0669: BB C8 C8 7C                  CONTINUE                        ; Done
       00:066D: 00 00 
   558                        
   559                        ; CELL+ ( a-addr1 -- a-addr2 )
   560                        ;
   561                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   562                        
   563 00:066F: 61 06 00 05                  HEADER  5,"CELL+",NORMAL
       00:0673: 43 45 4C 4C 
       00:0677: 2B 
   564                        CELL_PLUS:
   565 00:0678: E6 01                        inc     <1                      ; Bump the address by two
   566 00:067A: E6 01                        inc     <1
   567 00:067C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0680: 00 00 
   568                        
   569                        ; CELLS ( n1 -- n2 )
   570                        ;
   571                        ; n2 is the size in address units of n1 cells.
   572                        
   573 00:0682: 72 06 00 05                  HEADER  5,"CELLS",NORMAL
       00:0686: 43 45 4C 4C 
       00:068A: 53 
   574                        CELLS:
   575 00:068B: 06 01                        asl     <1                      ; Two bytes per cell
   576 00:068D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0691: 00 00 
   577                        
   578                        ; CHAR+ ( c-addr1 -- c-addr2 )
   579                        ;
   580                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
  Fri Mar 18 2016 23:20                                                                                                    Page 14


   581                        
   582 00:0693: 85 06 00 05                  HEADER  5,"CHAR+",NORMAL
       00:0697: 43 48 41 52 
       00:069B: 2B 
   583                        CHAR_PLUS:
   584 00:069C: E6 01                        inc     <1                      ; Bump the address by one
   585 00:069E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06A2: 00 00 
   586                        
   587                        ; CHAR- ( c-addr1 -- c-addr2 )
   588                        ;
   589                        ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
   590                        
   591 00:06A4: 96 06 00 05                  HEADER  5,"CHAR-",NORMAL
       00:06A8: 43 48 41 52 
       00:06AC: 2D 
   592                        CHAR_MINUS:
   593 00:06AD: C6 01                        dec     <1
   594 00:06AF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06B3: 00 00 
   595                        
   596                        ; CHARS ( n1 -- n2 )
   597                        ;
   598                        ; n2 is the size in address units of n1 characters.
   599                        
   600 00:06B5: A7 06 00 05                  HEADER  5,"CHARS",NORMAL
       00:06B9: 43 48 41 52 
       00:06BD: 53 
   601                        CHARS:
   602 00:06BE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06C2: 00 00 
   603                        
   604                        ;==============================================================================
   605                        ; Stack Operations
   606                        ;------------------------------------------------------------------------------
   607                        
   608                        ; 2DROP ( x1 x2 -- )
   609                        ;
   610                        ; Drop cell pair x1 x2 from the stack.
   611                        
   612 00:06C4: B8 06 00 05                  HEADER  5,"2DROP",NORMAL
       00:06C8: 32 44 52 4F 
       00:06CC: 50 
   613                        TWO_DROP:
   614 00:06CD: 7B                           tdc                             ; Removed two words from stack
   615 00:06CE: 1A                           inc     a
   616 00:06CF: 1A                           inc     a
   617 00:06D0: 1A                           inc     a
   618 00:06D1: 1A                           inc     a
   619 00:06D2: 5B                           tcd
   620 00:06D3: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06D7: 00 00 
   621                        
   622                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   623                        ;
   624                        ; Duplicate cell pair x1 x2.
   625                        
   626 00:06D9: C7 06 00 04                  HEADER  4,"2DUP",NORMAL
  Fri Mar 18 2016 23:20                                                                                                    Page 15


       00:06DD: 32 44 55 50 
   627                        TWO_DUP:
   628 00:06E1: 7B                           tdc                             ; Make space for new value
   629 00:06E2: 3A                           dec     a
   630 00:06E3: 3A                           dec     a
   631 00:06E4: 3A                           dec     a
   632 00:06E5: 3A                           dec     a
   633 00:06E6: 5B                           tcd
   634 00:06E7: A5 05                        lda     <5                      ; Copy top two values
   635 00:06E9: 85 01                        sta     <1
   636 00:06EB: A5 07                        lda     <7
   637 00:06ED: 85 03                        sta     <3
   638 00:06EF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06F3: 00 00 
   639                        
   640                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   641                        ;
   642                        ; Copy cell pair x1 x2 to the top of the stack.
   643                        
   644 00:06F5: DC 06 00 05                  HEADER  5,"2OVER",NORMAL
       00:06F9: 32 4F 56 45 
       00:06FD: 52 
   645                        TWO_OVER:
   646 00:06FE: 7B                           tdc                             ; Make space for new value
   647 00:06FF: 3A                           dec     a
   648 00:0700: 3A                           dec     a
   649 00:0701: 3A                           dec     a
   650 00:0702: 3A                           dec     a
   651 00:0703: 5B                           tcd
   652 00:0704: A5 09                        lda     <9                      ; Ciopy top two values
   653 00:0706: 85 01                        sta     <1
   654 00:0708: A5 0B                        lda     <11
   655 00:070A: 85 03                        sta     <3
   656 00:070C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0710: 00 00 
   657                        
   658                        ; 2ROT
   659                        
   660                        ; TODO
   661                        
   662                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   663                        ;
   664                        ; Exchange the top two cell pairs.
   665                        
   666 00:0712: F8 06 00 05                  HEADER  5,"2SWAP",NORMAL
       00:0716: 32 53 57 41 
       00:071A: 50 
   667                        TWO_SWAP:
   668 00:071B: A5 03                        lda     <3                      ; Save x3
   669 00:071D: 48                           pha
   670 00:071E: A5 01                        lda     <1                      ; Save x4
   671 00:0720: 48                           pha
   672 00:0721: A5 07                        lda     <7                      ; Move x1
   673 00:0723: 85 03                        sta     <3
   674 00:0725: A5 05                        lda     <5                      ; Move x2
   675 00:0727: 85 01                        sta     <1
   676 00:0729: 68                           pla                             ; Move x4
   677 00:072A: 85 05                        sta     <5
  Fri Mar 18 2016 23:20                                                                                                    Page 16


   678 00:072C: 68                           pla                             ; Move x3
   679 00:072D: 85 07                        sta     <7
   680 00:072F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0733: 00 00 
   681                        
   682                        ; ?DUP ( x -- 0 | x x )
   683                        ;
   684                        ; Duplicate x if it is non-zero.
   685                        
   686 00:0735: 15 07 00 04                  HEADER  4,"?DUP",NORMAL
       00:0739: 3F 44 55 50 
   687                        QUERY_DUP:
   688 00:073D: A5 01                        lda     <1                      ; Fetch top value
   689 00:073F: D0 1F                        bne     DUP                     ; Non-zero value?
   690 00:0741: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0745: 00 00 
   691                        
   692                        ; DROP ( x -- )
   693                        ;
   694                        ; Remove x from the stack.
   695                        
   696 00:0747: 38 07 00 04                  HEADER  4,"DROP",NORMAL
       00:074B: 44 52 4F 50 
   697                        DROP:
   698 00:074F: 7B                           tdc                             ; Drop the top value
   699 00:0750: 1A                           inc     a
   700 00:0751: 1A                           inc     a
   701 00:0752: 5B                           tcd
   702 00:0753: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0757: 00 00 
   703                        
   704                        ; DUP ( x -- x x )
   705                        ;
   706                        ; Duplicate x.
   707                        
   708 00:0759: 4A 07 00 03                  HEADER  3,"DUP",NORMAL
       00:075D: 44 55 50 
   709                        DUP:
   710 00:0760: 7B                           tdc
   711 00:0761: 3A                           dec     a
   712 00:0762: 3A                           dec     a
   713 00:0763: 5B                           tcd
   714 00:0764: A5 03                        lda     <3                      ; Fetch top value
   715 00:0766: 85 01                        sta     <1                      ; And make a copy
   716 00:0768: BB C8 C8 7C                  CONTINUE                        ; Done
       00:076C: 00 00 
   717                        
   718                        ; NIP ( x1 x2 -- x2 )
   719                        ;
   720                        ; Drop the first item below the top of stack.
   721                        
   722 00:076E: 5C 07 00 03                  HEADER  3,"NIP",NORMAL
       00:0772: 4E 49 50 
   723                        NIP:
   724 00:0775: A5 01                        lda     <1                      ; Copy x2 over x1
   725 00:0777: 85 03                        sta     <3
   726 00:0779: 80 D4                        bra     DROP
   727                        
  Fri Mar 18 2016 23:20                                                                                                    Page 17


   728                        ; OVER ( x1 x2 -- x1 x2 x1 )
   729                        ;
   730                        ; Place a copy of x1 on top of the stack.
   731                        
   732 00:077B: 71 07 00 04                  HEADER  4,"OVER",NORMAL
       00:077F: 4F 56 45 52 
   733                        OVER:
   734 00:0783: 7B                           tdc
   735 00:0784: 3A                           dec     a
   736 00:0785: 3A                           dec     a
   737 00:0786: 5B                           tcd
   738 00:0787: A5 05                        lda     <5                      ; Fetch second value
   739 00:0789: 85 01                        sta     <1                      ; And make a copy
   740 00:078B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:078F: 00 00 
   741                        
   742                        ; SWAP ( x1 x2 -- x2 x1 )
   743                        ;
   744                        ; Exchange the top two stack items.
   745                        
   746 00:0791: 7E 07 00 04                  HEADER  4,"SWAP",NORMAL
       00:0795: 53 57 41 50 
   747                        SWAP:
   748 00:0799: A5 01                        lda     <1                      ; Switch top two words
   749 00:079B: A6 03                        ldx     <3
   750 00:079D: 85 03                        sta     <3
   751 00:079F: 86 01                        stx     <1
   752 00:07A1: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07A5: 00 00 
   753                        
   754                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   755                        ;
   756                        ; Rotate the top three stack entries.
   757                        
   758 00:07A7: 94 07 00 03                  HEADER  3,"ROT",NORMAL
       00:07AB: 52 4F 54 
   759                        ROT:
   760 00:07AE: A6 05                        ldx     <5                      ; Save x1
   761 00:07B0: A5 03                        lda     <3                      ; Move x2
   762 00:07B2: 85 05                        sta     <5
   763 00:07B4: A5 01                        lda     <1                      ; Move x3
   764 00:07B6: 85 03                        sta     <3
   765 00:07B8: 86 01                        stx     <1                      ; Restore x1
   766 00:07BA: BB C8 C8 7C                  CONTINUE
       00:07BE: 00 00 
   767                        
   768                        ; ROLL [TODO]
   769                        
   770                        ; TUCK ( x1 x2 -- x2 x1 x2 )
   771                        ;
   772                        ; Copy the first (top) stack item below the second stack item.
   773                        
   774 00:07C0: AA 07 00 04                  HEADER  4,"TUCK",NORMAL
       00:07C4: 54 55 43 4B 
   775 00:07C8: 20 1D 12     TUCK:           jsr     DO_COLON
   776 00:07CB: 99 07                        dw      SWAP
   777 00:07CD: 83 07                        dw      OVER
   778 00:07CF: C7 0C                        dw      EXIT
  Fri Mar 18 2016 23:20                                                                                                    Page 18


   779                        
   780                        ;==============================================================================
   781                        ; Return Stack Operations
   782                        ;------------------------------------------------------------------------------
   783                        
   784                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   785                        ;
   786                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   787                        ; SWAP >R >R.
   788                        
   789 00:07D1: C3 07 00 03                  HEADER  3,"2>R",NORMAL
       00:07D5: 32 3E 52 
   790                        TWO_TO_R:
   791 00:07D8: A5 03                        lda     <3                      ; Transfer x1
   792 00:07DA: 48                           pha
   793 00:07DB: A5 01                        lda     <1                      ; Transfer x2
   794 00:07DD: 48                           pha
   795 00:07DE: 7B                           tdc
   796 00:07DF: 1A                           inc     a                       ; Clean up data stack
   797 00:07E0: 1A                           inc     a
   798 00:07E1: 1A                           inc     a
   799 00:07E2: 1A                           inc     a
   800 00:07E3: 5B                           tcd
   801 00:07E4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07E8: 00 00 
   802                        
   803                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   804                        ;
   805                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   806                        ; R> SWAP.
   807                        
   808 00:07EA: D4 07 00 03                  HEADER  3,"2R>",NORMAL
       00:07EE: 32 52 3E 
   809                        TWO_R_FROM:
   810 00:07F1: 7B                           tdc
   811 00:07F2: 3A                           dec     a                       ; Make space for values
   812 00:07F3: 3A                           dec     a
   813 00:07F4: 3A                           dec     a
   814 00:07F5: 3A                           dec     a
   815 00:07F6: 5B                           tcd
   816 00:07F7: 68                           pla                             ; Transfer x2
   817 00:07F8: 85 01                        sta     <1
   818 00:07FA: 68                           pla                             ; Transfer x1
   819 00:07FB: 85 03                        sta     <3
   820 00:07FD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0801: 00 00 
   821                        
   822                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
   823                        ;
   824                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   825                        ; 2DUP >R >R SWAP.
   826                        
   827 00:0803: ED 07 00 03                  HEADER  3,"2R@",NORMAL
       00:0807: 32 52 40 
   828                        TWO_R_FETCH:
   829 00:080A: 7B                           tdc
   830 00:080B: 3A                           dec     a                       ; Make space for values
   831 00:080C: 3A                           dec     a
  Fri Mar 18 2016 23:20                                                                                                    Page 19


   832 00:080D: 3A                           dec     a
   833 00:080E: 3A                           dec     a
   834 00:080F: 5B                           tcd
   835 00:0810: A3 01                        lda     1,s                     ; Transfer x2
   836 00:0812: 85 01                        sta     <1
   837 00:0814: A3 03                        lda     3,s                     ; Transfer x1
   838 00:0816: 85 03                        sta     <3
   839 00:0818: BB C8 C8 7C                  CONTINUE                        ; Done
       00:081C: 00 00 
   840                        
   841                        ; >R ( x -- ) ( R: -- x )
   842                        ;
   843                        ; Move x to the return stack.
   844                        
   845 00:081E: 06 08 00 02                  HEADER  2,">R",NORMAL
       00:0822: 3E 52 
   846                        TO_R:
   847 00:0824: A5 01                        lda     <1                      ; Transfer top value
   848 00:0826: 48                           pha                             ; .. to return stack
   849 00:0827: 7B                           tdc
   850 00:0828: 1A                           inc     a
   851 00:0829: 1A                           inc     a
   852 00:082A: 5B                           tcd
   853 00:082B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:082F: 00 00 
   854                        
   855                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   856                        ;
   857                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   858                        ; exists if the loop control parameters are unavailable.
   859                        
   860 00:0831: 21 08 00 01                  HEADER  1,"I",NORMAL
       00:0835: 49 
   861                        I:
   862 00:0836: 7B                           tdc
   863 00:0837: 3A                           dec     a
   864 00:0838: 3A                           dec     a
   865 00:0839: 5B                           tcd
   866 00:083A: A3 01                        lda     1,s
   867 00:083C: 85 01                        sta     <1
   868 00:083E: BB C8 C8 7C                  CONTINUE
       00:0842: 00 00 
   869                        
   870                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   871                        ;
   872                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   873                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   874                        ; unavailable.
   875                        
   876 00:0844: 34 08 00 01                  HEADER  1,"J",NORMAL
       00:0848: 4A 
   877                        J:
   878 00:0849: 7B                           tdc
   879 00:084A: 3A                           dec     a
   880 00:084B: 3A                           dec     a
   881 00:084C: 5B                           tcd
   882 00:084D: A3 05                        lda     5,s
   883 00:084F: 85 01                        sta     <1
  Fri Mar 18 2016 23:20                                                                                                    Page 20


   884 00:0851: BB C8 C8 7C                  CONTINUE
       00:0855: 00 00 
   885                        
   886                        ; R> ( -- x ) ( R: x -- )
   887                        ;
   888                        ; Move x from the return stack to the data stack.
   889                        
   890 00:0857: 47 08 00 02                  HEADER  2,"R>",NORMAL
       00:085B: 52 3E 
   891                        R_FROM:
   892 00:085D: 7B                           tdc
   893 00:085E: 3A                           dec     a
   894 00:085F: 3A                           dec     a
   895 00:0860: 5B                           tcd
   896 00:0861: 68                           pla                             ; Fetch return stack value
   897 00:0862: 85 01                        sta     <1
   898 00:0864: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0868: 00 00 
   899                        
   900                        ; R@ ( -- x ) ( R: x -- x )
   901                        ;
   902                        ; Copy x from the return stack to the data stack.
   903                        
   904 00:086A: 5A 08 00 02                  HEADER  2,"R@",NORMAL
       00:086E: 52 40 
   905                        R_FETCH:
   906 00:0870: 7B                           tdc
   907 00:0871: 3A                           dec     a
   908 00:0872: 3A                           dec     a
   909 00:0873: 5B                           tcd
   910 00:0874: A3 01                        lda     1,s
   911 00:0876: 85 01                        sta     <1
   912 00:0878: BB C8 C8 7C                  CONTINUE
       00:087C: 00 00 
   913                        
   914                        ;==============================================================================
   915                        ; Single Precision Arithmetic
   916                        ;------------------------------------------------------------------------------
   917                        
   918                        ; * ( n1|u1 n2|u2 -- n3|u3 )
   919                        ;
   920                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
   921                        
   922 00:087E: 6D 08 00 01                  HEADER  1,"*",NORMAL
       00:0882: 2A 
   923                        STAR:
   924 00:0883: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0887: 00 00 
   925                        
   926                        ; */
   927                        
   928 00:0889: 81 08 00 02                  HEADER  2,"*/",NORMAL
       00:088D: 2A 2F 
   929                        STAR_SLASH:
   930 00:088F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0893: 00 00 
   931                        
   932                        ; */MOD
  Fri Mar 18 2016 23:20                                                                                                    Page 21


   933                        
   934 00:0895: 8C 08 00 05                  HEADER  5,"*/MOD",NORMAL
       00:0899: 2A 2F 4D 4F 
       00:089D: 44 
   935                        STAR_SLASH_MOD:
   936 00:089E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08A2: 00 00 
   937                        
   938                        ; + ( n1|u1 n2|u2 -- n3|u3 )
   939                        ;
   940                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
   941                        
   942 00:08A4: 98 08 00 01                  HEADER  1,"+",NORMAL
       00:08A8: 2B 
   943                        PLUS:
   944 00:08A9: 18                           clc                             ; Add top two values
   945 00:08AA: A5 03                        lda     <3
   946 00:08AC: 65 01                        adc     <1
   947 00:08AE: 85 03                        sta     <3                      ; Save result
   948 00:08B0: 7B                           tdc
   949 00:08B1: 1A                           inc     a                       ; Clean up data stack
   950 00:08B2: 1A                           inc     a
   951 00:08B3: 5B                           tcd
   952 00:08B4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08B8: 00 00 
   953                        
   954                        ; - ( n1|u1 n2|u2 -- n3|u3 )
   955                        ;
   956                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
   957                        
   958 00:08BA: A7 08 00 01                  HEADER  1,"-",NORMAL
       00:08BE: 2D 
   959                        MINUS:
   960 00:08BF: 38                           sec                             ; Subtract top two values
   961 00:08C0: A5 03                        lda     <3
   962 00:08C2: E5 01                        sbc     <1
   963 00:08C4: 85 03                        sta     <3                      ; Save result
   964 00:08C6: 7B                           tdc
   965 00:08C7: 1A                           inc     a                       ; Clean up data stack
   966 00:08C8: 1A                           inc     a
   967 00:08C9: 5B                           tcd
   968 00:08CA: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08CE: 00 00 
   969                        
   970                        ; /
   971                        
   972 00:08D0: BD 08 00 01                  HEADER  1,"/",NORMAL
       00:08D4: 2F 
   973 00:08D5: 20 1D 12     SLASH:          jsr     DO_COLON
   974 00:08D8: E6 08                        dw      SLASH_MOD
   975 00:08DA: 75 07                        dw      NIP
   976 00:08DC: C7 0C                        dw      EXIT
   977                        
   978                        ; /MOD
   979                        
   980 00:08DE: D3 08 00 04                  HEADER  4,"/MOD",NORMAL
       00:08E2: 2F 4D 4F 44 
   981                        SLASH_MOD:
  Fri Mar 18 2016 23:20                                                                                                    Page 22


   982 00:08E6: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08EA: 00 00 
   983                        
   984                        ; 1+ ( n1|u1 -- n2|u2 )
   985                        ;
   986                        ; Add one (1) to n1|u1 giving the sum n2|u2.
   987                        
   988 00:08EC: E1 08 00 02                  HEADER  2,"1+",NORMAL
       00:08F0: 31 2B 
   989                        ONE_PLUS:
   990 00:08F2: E6 01                        inc     <1                      ; Increment top of stack
   991 00:08F4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08F8: 00 00 
   992                        
   993                        ; 1- ( n1|u1 -- n2|u2 )
   994                        ;
   995                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
   996                        
   997 00:08FA: EF 08 00 02                  HEADER  2,"1-",NORMAL
       00:08FE: 31 2D 
   998                        ONE_MINUS:
   999 00:0900: C6 01                        dec     <1                      ; Decrement top of stack
  1000 00:0902: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0906: 00 00 
  1001                        
  1002                        ; 2* ( x1 -- x2 )
  1003                        ;
  1004                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
  1005                        ; filling the vacated least-significant bit with zero.
  1006                        
  1007 00:0908: FD 08 00 02                  HEADER  2,"2*",NORMAL
       00:090C: 32 2A 
  1008                        TWO_STAR:
  1009 00:090E: 06 01                        asl     <1                      ; Multiply top value by two
  1010 00:0910: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0914: 00 00 
  1011                        
  1012                        ; 2/ ( x1 -- x2 )
  1013                        ;
  1014                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
  1015                        ; leaving the most-significant bit unchanged.
  1016                        
  1017 00:0916: 0B 09 00 02                  HEADER  2,"2/",NORMAL
       00:091A: 32 2F 
  1018                        TWO_SLASH:
  1019 00:091C: A5 01                        lda     <1                      ; Load the top value
  1020 00:091E: 2A                           rol     a                       ; Extract the top bit
  1021 00:091F: 66 01                        ror     <1                      ; And shift back into value
  1022 00:0921: BB C8 C8 7C                  CONTINUE
       00:0925: 00 00 
  1023                        
  1024                        ; ABS ( n -- u )
  1025                        ;
  1026                        ; u is the absolute value of n.
  1027                        
  1028 00:0927: 19 09 00 03                  HEADER  3,"ABS",NORMAL
       00:092B: 41 42 53 
  1029                        ABS:
  Fri Mar 18 2016 23:20                                                                                                    Page 23


  1030 00:092E: A5 01                        lda     <1
  1031 00:0930: 30 50                        bmi     NEGATE
  1032 00:0932: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0936: 00 00 
  1033                        
  1034                        ; MAX
  1035                        
  1036 00:0938: 2A 09 00 03                  HEADER  3,"MAX",NORMAL
       00:093C: 4D 41 58 
  1037 00:093F: 20 1D 12     MAX:            jsr     DO_COLON
  1038 00:0942: E1 06                        dw      TWO_DUP
  1039 00:0944: 1F 0B                        dw      LESS
  1040 00:0946: 02 12 4C 09                  dw      QUERY_BRANCH,MAX_1
  1041 00:094A: 99 07                        dw      SWAP
  1042 00:094C: 4F 07        MAX_1:          dw      DROP
  1043 00:094E: C7 0C                        dw      EXIT
  1044                        
  1045                        ; MIN
  1046                        
  1047 00:0950: 3B 09 00 03                  HEADER  3,"MIN",NORMAL
       00:0954: 4D 49 4E 
  1048 00:0957: 20 1D 12     MIN:            jsr     DO_COLON
  1049 00:095A: E1 06                        dw      TWO_DUP
  1050 00:095C: 73 0B                        dw      GREATER
  1051 00:095E: 02 12 64 09                  dw      QUERY_BRANCH,MIN_1
  1052 00:0962: 99 07                        dw      SWAP
  1053 00:0964: 4F 07        MIN_1:          dw      DROP
  1054 00:0966: C7 0C                        dw      EXIT
  1055                        
  1056                        ; MOD
  1057                        
  1058 00:0968: 53 09 00 03                  HEADER  3,"MOD",NORMAL
       00:096C: 4D 4F 44 
  1059 00:096F: 20 1D 12     MOD:            jsr     DO_COLON
  1060 00:0972: E6 08                        dw      SLASH_MOD
  1061 00:0974: 4F 07                        dw      DROP
  1062 00:0976: C7 0C                        dw      EXIT
  1063                        
  1064                        ; NEGATE ( n1 -- n2 )
  1065                        ;
  1066                        ; Negate n1, giving its arithmetic inverse n2.
  1067                        
  1068 00:0978: 6B 09 00 06                  HEADER  6,"NEGATE",NORMAL
       00:097C: 4E 45 47 41 
       00:0980: 54 45 
  1069                        NEGATE:
  1070 00:0982: 38                           sec                             ; Negate the top of stack
  1071 00:0983: A9 00 00                     lda     #0
  1072 00:0986: E5 01                        sbc     <1
  1073 00:0988: 85 01                        sta     <1
  1074 00:098A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:098E: 00 00 
  1075                        
  1076                        ; UMAX ( x1 x2 -- x1|x2 )
  1077                        
  1078 00:0990: 7B 09 00 04                  HEADER  4,"UMAX",NORMAL
       00:0994: 55 4D 41 58 
  1079                        UMAX:
  Fri Mar 18 2016 23:20                                                                                                    Page 24


  1080 00:0998: A5 01                        lda     <1                      ; Compare the top values
  1081 00:099A: C5 03                        cmp     <3
  1082 00:099C: B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
  1083 00:099E: 4C 4F 07                     jmp     DROP                    ; No, x1 is
  1084 00:09A1: 4C 75 07     UMAX_EXIT:      jmp     NIP
  1085                        
  1086                        ; UMIN ( x1 x2 -- x1|x2 )
  1087                        
  1088 00:09A4: 93 09 00 04                  HEADER  4,"UMIN",NORMAL
       00:09A8: 55 4D 49 4E 
  1089                        UMIN:
  1090 00:09AC: A5 01                        lda     <1                      ; Compare the top values
  1091 00:09AE: C5 03                        cmp     <3
  1092 00:09B0: 90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
  1093 00:09B2: 4C 4F 07                     jmp     DROP                    ; No, x1 is
  1094 00:09B5: 4C 75 07     UMIN_EXIT:      jmp     NIP
  1095                        
  1096                        ;==============================================================================
  1097                        ; Double Precision Arithmetic
  1098                        ;------------------------------------------------------------------------------
  1099                        
  1100                        ; D+ ( d1|ud1 d2|ud2 -- d3|ud3 )
  1101                        ;
  1102                        ; Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
  1103                        
  1104 00:09B8: A7 09 00 02                  HEADER  2,"D+",NORMAL
       00:09BC: 44 2B 
  1105                        D_PLUS:
  1106 00:09BE: 18                           clc
  1107 00:09BF: A5 07                        lda     <7                      ; Add low words
  1108 00:09C1: 65 03                        adc     <3
  1109 00:09C3: 85 07                        sta     <7
  1110 00:09C5: A5 05                        lda     <5                      ; Then the high words
  1111 00:09C7: 65 01                        adc     <1
  1112 00:09C9: 85 05                        sta     <5
  1113 00:09CB: 7B                           tdc                             ; Drop top double
  1114 00:09CC: 1A                           inc     a
  1115 00:09CD: 1A                           inc     a
  1116 00:09CE: 1A                           inc     a
  1117 00:09CF: 1A                           inc     a
  1118 00:09D0: 5B                           tcd
  1119 00:09D1: BB C8 C8 7C                  CONTINUE                        ; Done
       00:09D5: 00 00 
  1120                        
  1121                        ; D- ( d1|ud1 d2|ud2 -- d3|ud3 )
  1122                        ;
  1123                        ; Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
  1124                        
  1125 00:09D7: BB 09 00 02                  HEADER  2,"D-",NORMAL
       00:09DB: 44 2D 
  1126                        D_MINUS:
  1127 00:09DD: 38                           sec
  1128 00:09DE: A5 07                        lda     <7                      ; Subtract low words
  1129 00:09E0: E5 03                        sbc     <3
  1130 00:09E2: 85 07                        sta     <7
  1131 00:09E4: A5 05                        lda     <5                      ; Then the high words
  1132 00:09E6: E5 01                        sbc     <1
  1133 00:09E8: 85 05                        sta     <5
  Fri Mar 18 2016 23:20                                                                                                    Page 25


  1134 00:09EA: 7B                           tdc                             ; Drop top double
  1135 00:09EB: 1A                           inc     a
  1136 00:09EC: 1A                           inc     a
  1137 00:09ED: 1A                           inc     a
  1138 00:09EE: 1A                           inc     a
  1139 00:09EF: 5B                           tcd
  1140 00:09F0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:09F4: 00 00 
  1141                        
  1142                        ; D2* ( xd1 -- xd2 )
  1143                        ;
  1144                        ; xd2 is the result of shifting xd1 one bit toward the most-significant bit,
  1145                        ; filling the vacated least-significant bit with zero.
  1146                        
  1147 00:09F6: DA 09 00 03                  HEADER  3,"D2*",NORMAL
       00:09FA: 44 32 2A 
  1148                        D_TWO_STAR:
  1149 00:09FD: 06 03                        asl     <3
  1150 00:09FF: 26 01                        rol     <1
  1151 00:0A01: BB C8 C8 7C                  CONTINUE
       00:0A05: 00 00 
  1152                        
  1153                        ; D2/ ( xd1 -- xd2 )
  1154                        ;
  1155                        ; xd2 is the result of shifting xd1 one bit toward the least-significant bit,
  1156                        ; leaving the most-significant bit unchanged.
  1157                        
  1158 00:0A07: F9 09 00 03                  HEADER  3,"D2/",NORMAL
       00:0A0B: 44 32 2F 
  1159                        D_TWO_SLASH:
  1160 00:0A0E: A5 01                        lda     <1
  1161 00:0A10: 2A                           rol     a
  1162 00:0A11: 66 01                        ror     <1
  1163 00:0A13: 66 03                        ror     <3
  1164 00:0A15: BB C8 C8 7C                  CONTINUE
       00:0A19: 00 00 
  1165                        
  1166                        ; DABS
  1167                        ; DMAX
  1168                        ; DMIN
  1169                        
  1170                        ; DNEGATE ( d1 -- d2 )
  1171                        ;
  1172                        ; d2 is the negation of d1.
  1173                        
  1174 00:0A1B: 0A 0A 00 07                  HEADER  7,"DNEGATE",NORMAL
       00:0A1F: 44 4E 45 47 
       00:0A23: 41 54 45 
  1175                        DNEGATE:
  1176 00:0A26: 38                           sec
  1177 00:0A27: A9 00 00                     lda     #0                      ; Subtract low word from zero
  1178 00:0A2A: E5 03                        sbc     <3
  1179 00:0A2C: 85 03                        sta     <3
  1180 00:0A2E: A9 00 00                     lda     #0                      ; Then the high word
  1181 00:0A31: E5 01                        sbc     <1
  1182 00:0A33: 85 01                        sta     <1
  1183 00:0A35: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A39: 00 00 
  Fri Mar 18 2016 23:20                                                                                                    Page 26


  1184                        
  1185                        ; UD* ( ud1 d2 -- ud3)
  1186                        ;
  1187                        ; 32*16->32 multiply
  1188                        ;
  1189                        ;   DUP >R UM* DROP  SWAP R> UM* ROT + ;
  1190                        
  1191 00:0A3B: 1E 0A 00 03                  HEADER  3,"UD*",NORMAL
       00:0A3F: 55 44 2A 
  1192 00:0A42: 20 1D 12     UD_STAR:        jsr     DO_COLON
  1193 00:0A45: 60 07                        dw      DUP
  1194 00:0A47: 24 08                        dw      TO_R
  1195 00:0A49: A5 0A                        dw      UM_STAR
  1196 00:0A4B: 4F 07                        dw      DROP
  1197 00:0A4D: 99 07                        dw      SWAP
  1198 00:0A4F: 5D 08                        dw      R_FROM
  1199 00:0A51: A5 0A                        dw      UM_STAR
  1200 00:0A53: AE 07                        dw      ROT
  1201 00:0A55: A9 08                        dw      PLUS
  1202 00:0A57: C7 0C                        dw      EXIT
  1203                        
  1204                        ;==============================================================================
  1205                        ; Mixed Arithmetic
  1206                        ;------------------------------------------------------------------------------
  1207                        
  1208                        
  1209                        ; D>S ( d -- n )
  1210                        ;
  1211                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1212                        ; range of a signed single-cell number.
  1213                        
  1214 00:0A59: 3E 0A 00 03                  HEADER  3,"D>S",NORMAL
       00:0A5D: 44 3E 53 
  1215                        D_TO_S:
  1216 00:0A60: 7B                           tdc
  1217 00:0A61: 1A                           inc     a                       ; Drop the high word
  1218 00:0A62: 1A                           inc     a
  1219 00:0A63: 5B                           tcd
  1220 00:0A64: BB C8 C8 7C                  CONTINUE
       00:0A68: 00 00 
  1221                        
  1222                        ; M*/
  1223                        
  1224                        ; M+ ( d1|ud1 n -- d2|ud2 )
  1225                        ;
  1226                        ; Add n to d1|ud1, giving the sum d2|ud2.
  1227                        
  1228 00:0A6A: 5C 0A 00 02                  HEADER  2,"M+",NORMAL
       00:0A6E: 4D 2B 
  1229                        M_PLUS:
  1230 00:0A70: 18                           clc
  1231 00:0A71: A5 01                        lda     <1
  1232 00:0A73: 65 05                        adc     <5
  1233 00:0A75: 85 05                        sta     <5
  1234 00:0A77: 90 02                        bcc     $+4
  1235 00:0A79: E6 03                        inc     <3
  1236 00:0A7B: 7B                           tdc
  1237 00:0A7C: 1A                           inc     a
  Fri Mar 18 2016 23:20                                                                                                    Page 27


  1238 00:0A7D: 1A                           inc     a
  1239 00:0A7E: 5B                           tcd
  1240 00:0A7F: BB C8 C8 7C                  CONTINUE
       00:0A83: 00 00 
  1241                        
  1242                        ; S>D ( n -- d )
  1243                        ;
  1244                        ; Convert the number n to the double-cell number d with the same numerical
  1245                        ; value.
  1246                        
  1247 00:0A85: 6D 0A 00 03                  HEADER  3,"S>D",NORMAL
       00:0A89: 53 3E 44 
  1248                        S_TO_D:
  1249 00:0A8C: 7B                           tdc
  1250 00:0A8D: 3A                           dec     a                       ; Assume n is positive
  1251 00:0A8E: 3A                           dec     a
  1252 00:0A8F: 5B                           tcd
  1253 00:0A90: 64 01                        stz     <1                      ; .. push a zero value
  1254 00:0A92: A5 03                        lda     <3                      ; Test the number
  1255 00:0A94: 10 02                        bpl     S_TO_D_1
  1256 00:0A96: C6 01                        dec     <1                      ; Make top -1 if negative
  1257 00:0A98: BB C8 C8 7C  S_TO_D_1        CONTINUE                        ; Done
       00:0A9C: 00 00 
  1258                        
  1259                        ; UM* ( n1 n2 -- d )
  1260                        
  1261 00:0A9E: 88 0A 00 03                  HEADER  3,"UM*",NORMAL
       00:0AA2: 55 4D 2A 
  1262                        UM_STAR:
  1263 00:0AA5: A5 01                        lda     <1                      ; Fetch multiplier
  1264 00:0AA7: 48                           pha
  1265 00:0AA8: 64 01                        stz     <1                      ; Clear the result
  1266 00:0AAA: A2 10 00                     ldx     #16
  1267 00:0AAD: A5 03        UM_STAR_1:      lda     <3                      ; Shift multiplier one bit
  1268 00:0AAF: 4A                           lsr     a
  1269 00:0AB0: 90 07                        bcc     UM_STAR_2               ; Not set, no add
  1270 00:0AB2: A3 01                        lda     1,s                     ; Fetch multiplicand
  1271 00:0AB4: 18                           clc
  1272 00:0AB5: 65 01                        adc     <1
  1273 00:0AB7: 85 01                        sta     <1
  1274 00:0AB9: 66 01        UM_STAR_2:      ror     <1                      ; Rotate high word down
  1275 00:0ABB: 66 03                        ror     <3
  1276 00:0ABD: CA                           dex
  1277 00:0ABE: D0 ED                        bne     UM_STAR_1
  1278 00:0AC0: 68                           pla
  1279 00:0AC1: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0AC5: 00 00 
  1280                        
  1281                        ;==============================================================================
  1282                        ; Comparisons
  1283                        ;------------------------------------------------------------------------------
  1284                        
  1285                        ; 0< ( n -- flag )
  1286                        ;
  1287                        ; flag is true if and only if n is less than zero.
  1288                        
  1289 00:0AC7: A1 0A 00 02                  HEADER  2,"0<",NORMAL
       00:0ACB: 30 3C 
  Fri Mar 18 2016 23:20                                                                                                    Page 28


  1290                        ZERO_LESS:
  1291 00:0ACD: A5 01                        lda     <1                      ; Test top of stack
  1292 00:0ACF: 64 01                        stz     <1                      ; Assume false result
  1293 00:0AD1: 10 02                        bpl     ZERO_LT_1               ; Was the value negative?
  1294 00:0AD3: C6 01                        dec     <1                      ; Yes, make true result
  1295 00:0AD5: BB C8 C8 7C  ZERO_LT_1:      CONTINUE                        ; Done
       00:0AD9: 00 00 
  1296                        
  1297                        ; 0<> ( x -- flag )
  1298                        ;
  1299                        ; flag is true if and only if x is not equal to zero.
  1300                        
  1301 00:0ADB: CA 0A 00 03                  HEADER  3,"0<>",NORMAL
       00:0ADF: 30 3C 3E 
  1302                        ZERO_NOT_EQUAL:
  1303 00:0AE2: A5 01                        lda     <1                      ; Test top of stack
  1304 00:0AE4: 64 01                        stz     <1                      ; Assume false result
  1305 00:0AE6: F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
  1306 00:0AE8: C6 01                        dec     <1                      ; Yes, make true result
  1307 00:0AEA: BB C8 C8 7C  ZERO_NE_1:      CONTINUE                        ; Done
       00:0AEE: 00 00 
  1308                        
  1309                        ; 0= ( x -- flag )
  1310                        ;
  1311                        ; flag is true if and only if x is equal to zero.
  1312                        
  1313 00:0AF0: DE 0A 00 02                  HEADER  2,"0=",NORMAL
       00:0AF4: 30 3D 
  1314                        ZERO_EQUAL:
  1315 00:0AF6: A5 01                        lda     <1                      ; Test top of stack
  1316 00:0AF8: 64 01                        stz     <1                      ; Assume false result
  1317 00:0AFA: D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
  1318 00:0AFC: C6 01                        dec     <1                      ; Yes, make true result
  1319 00:0AFE: BB C8 C8 7C  ZERO_EQ_1:      CONTINUE                        ; Done
       00:0B02: 00 00 
  1320                        
  1321                        ; 0> ( n -- flag )
  1322                        ;
  1323                        ; flag is true if and only if n is greater than zero.
  1324                        
  1325 00:0B04: F3 0A 00 02                  HEADER  2,"0>",NORMAL
       00:0B08: 30 3E 
  1326                        ZERO_GREATER:
  1327 00:0B0A: A5 01                        lda     <1                      ; Test top of stack
  1328 00:0B0C: 64 01                        stz     <1                      ; Assume false result
  1329 00:0B0E: 30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
  1330 00:0B10: F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
  1331 00:0B12: C6 01                        dec     <1                      ; Yes, make true result
  1332 00:0B14: BB C8 C8 7C  ZERO_GT_EXIT:   CONTINUE                        ; Done
       00:0B18: 00 00 
  1333                        
  1334                        ; <
  1335                        
  1336 00:0B1A: 07 0B 00 01                  HEADER  1,"<",NORMAL
       00:0B1E: 3C 
  1337                        LESS:
  1338 00:0B1F: A6 01                        ldx     <1                      ; Pull x2 from stack
  1339 00:0B21: 7B                           tdc
  Fri Mar 18 2016 23:20                                                                                                    Page 29


  1340 00:0B22: 1A                           inc     a
  1341 00:0B23: 1A                           inc     a
  1342 00:0B24: 5B                           tcd
  1343 00:0B25: 8A                           txa
  1344 00:0B26: 38                           sec                             ; Compare with x1
  1345 00:0B27: E5 01                        sbc     <1
  1346 00:0B29: 64 01                        stz     <1                      ; Assume false result
  1347 00:0B2B: 70 04                        bvs     LESS_1
  1348 00:0B2D: 10 04                        bpl     LESS_2                  ; V == 0 && N == 0
  1349 00:0B2F: 80 04                        bra     LESS_3
  1350 00:0B31: 10 02        LESS_1:         bpl     LESS_3                  ; V == 1 && N == 1
  1351 00:0B33: C6 01        LESS_2:         dec     <1
  1352 00:0B35: BB C8 C8 7C  LESS_3:         CONTINUE
       00:0B39: 00 00 
  1353                        
  1354                        ; <>
  1355                        
  1356 00:0B3B: 1D 0B 00 02                  HEADER  2,"<>",NORMAL
       00:0B3F: 3C 3E 
  1357                        NOT_EQUAL:
  1358 00:0B41: A6 01                        ldx     <1                      ; Pull x2 from stack
  1359 00:0B43: 7B                           tdc
  1360 00:0B44: 1A                           inc     a
  1361 00:0B45: 1A                           inc     a
  1362 00:0B46: 5B                           tcd
  1363 00:0B47: E4 01                        cpx     <1                      ; Compare with x1
  1364 00:0B49: 64 01                        stz     <1                      ; Assume equal
  1365 00:0B4B: F0 02                        beq     NE_EXIT                 ; Test flags
  1366 00:0B4D: C6 01                        dec     <1                      ; Make result true
  1367 00:0B4F: BB C8 C8 7C  NE_EXIT:        CONTINUE                        ; Done
       00:0B53: 00 00 
  1368                        
  1369                        ; = ( x1 x2 -- flag )
  1370                        ;
  1371                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  1372                        
  1373 00:0B55: 3E 0B 00 01                  HEADER  1,"=",NORMAL
       00:0B59: 3D 
  1374                        EQUAL:
  1375 00:0B5A: A6 01                        ldx     <1                      ; Pull x2 from stack
  1376 00:0B5C: 7B                           tdc
  1377 00:0B5D: 1A                           inc     a
  1378 00:0B5E: 1A                           inc     a
  1379 00:0B5F: 5B                           tcd
  1380 00:0B60: E4 01                        cpx     <1                      ; Compare with x1
  1381 00:0B62: 64 01                        stz     <1                      ; Assume not equal
  1382 00:0B64: D0 02                        bne     EQ_EXIT                 ; Test the flags
  1383 00:0B66: C6 01                        dec     <1                      ; Make result true
  1384 00:0B68: BB C8 C8 7C  EQ_EXIT:        CONTINUE                        ; Done
       00:0B6C: 00 00 
  1385                        
  1386                        ; >
  1387                        
  1388 00:0B6E: 58 0B 00 01                  HEADER  1,">",NORMAL
       00:0B72: 3E 
  1389 00:0B73: 20 1D 12     GREATER:        jsr     DO_COLON
  1390 00:0B76: 99 07                        dw      SWAP
  1391 00:0B78: 1F 0B                        dw      LESS
  Fri Mar 18 2016 23:20                                                                                                    Page 30


  1392 00:0B7A: C7 0C                        dw      EXIT
  1393                        
  1394                        ; U<
  1395                        
  1396 00:0B7C: 71 0B 00 02                  HEADER  2,"U<",NORMAL
       00:0B80: 55 3C 
  1397                        U_LESS:
  1398 00:0B82: A6 01                        ldx     <1                      ; Pull x2
  1399 00:0B84: 7B                           tdc                             ; Drop from stack
  1400 00:0B85: 1A                           inc     a
  1401 00:0B86: 1A                           inc     a
  1402 00:0B87: 5B                           tcd
  1403 00:0B88: E4 01                        cpx     <1                      ; Compare with x1
  1404 00:0B8A: 64 01                        stz     <1                      ; Assume false
  1405 00:0B8C: F0 04                        beq     U_LESS_1                ; Equal
  1406 00:0B8E: 90 02                        bcc     U_LESS_1                ; Less
  1407 00:0B90: C6 01                        dec     <1
  1408 00:0B92: BB C8 C8 7C  U_LESS_1:       CONTINUE
       00:0B96: 00 00 
  1409                        
  1410                        ; U>
  1411                        
  1412 00:0B98: 7F 0B 00 02                  HEADER  2,"U>",NORMAL
       00:0B9C: 55 3E 
  1413 00:0B9E: 20 1D 12     U_GREATER:      jsr     DO_COLON
  1414 00:0BA1: 99 07                        dw      SWAP
  1415 00:0BA3: 82 0B                        dw      U_LESS
  1416 00:0BA5: C7 0C                        dw      EXIT
  1417                        
  1418                        ;==============================================================================
  1419                        ; Logical Operations
  1420                        ;------------------------------------------------------------------------------
  1421                        
  1422                        ; AND ( x1 x2 -- x3 )
  1423                        ;
  1424                        ; x3 is the bit-by-bit logical and of x1 with x2.
  1425                        
  1426 00:0BA7: 9B 0B 00 03                  HEADER  3,"AND",NORMAL
       00:0BAB: 41 4E 44 
  1427                        AND:
  1428 00:0BAE: A5 01                        lda     <1
  1429 00:0BB0: 25 03                        and     <3
  1430 00:0BB2: 85 03                        sta     <3
  1431 00:0BB4: 7B                           tdc
  1432 00:0BB5: 1A                           inc     a
  1433 00:0BB6: 1A                           inc     a
  1434 00:0BB7: 5B                           tcd
  1435 00:0BB8: BB C8 C8 7C                  CONTINUE
       00:0BBC: 00 00 
  1436                        
  1437                        ; INVERT ( x1 -- x2 )
  1438                        ;
  1439                        ; Invert all bits of x1, giving its logical inverse x2.
  1440                        
  1441 00:0BBE: AA 0B 00 06                  HEADER  6,"INVERT",NORMAL
       00:0BC2: 49 4E 56 45 
       00:0BC6: 52 54 
  1442                        INVERT:
  Fri Mar 18 2016 23:20                                                                                                    Page 31


  1443 00:0BC8: A5 01                        lda     <1                      ; Fetch top value
  1444 00:0BCA: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1445 00:0BCD: 85 01                        sta     <1                      ; .. and write back
  1446 00:0BCF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0BD3: 00 00 
  1447                        
  1448                        ; LSHIFT ( x1 u -- x2 )
  1449                        ;
  1450                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1451                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1452                        ; exists if u is greater than or equal to the number of bits in a cell.
  1453                        
  1454 00:0BD5: C1 0B 00 06                  HEADER  6,"LSHIFT",NORMAL
       00:0BD9: 4C 53 48 49 
       00:0BDD: 46 54 
  1455                        LSHIFT:
  1456 00:0BDF: A6 01                        ldx     <1                      ; Pull bit count
  1457 00:0BE1: 08                           php
  1458 00:0BE2: 7B                           tdc
  1459 00:0BE3: 1A                           inc     a                       ; .. from the stack
  1460 00:0BE4: 1A                           inc     a
  1461 00:0BE5: 5B                           tcd
  1462 00:0BE6: 28                           plp
  1463 00:0BE7: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1464 00:0BE9: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1465 00:0BEC: B0 0B                        bcs     LSHIFT_2                ; Yes, result will be zero
  1466 00:0BEE: 06 01        LSHIFT_1        asl     <1                      ; Shift one bit left
  1467 00:0BF0: CA                           dex                             ; Update count
  1468 00:0BF1: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  1469 00:0BF3: BB C8 C8 7C  LSHIFT_0        CONTINUE                        ; Done
       00:0BF7: 00 00 
  1470 00:0BF9: 64 01        LSHIFT_2        stz     <1                      ; Clear top value
  1471 00:0BFB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0BFF: 00 00 
  1472                        
  1473                        ; OR ( x1 x2 -- x3 )
  1474                        ;
  1475                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1476                        
  1477 00:0C01: D8 0B 00 02                  HEADER  2,"OR",NORMAL
       00:0C05: 4F 52 
  1478                        OR:
  1479 00:0C07: A5 01                        lda     <1
  1480 00:0C09: 05 03                        ora     <3
  1481 00:0C0B: 85 03                        sta     <3
  1482 00:0C0D: 7B                           tdc
  1483 00:0C0E: 1A                           inc     a
  1484 00:0C0F: 1A                           inc     a
  1485 00:0C10: 5B                           tcd
  1486 00:0C11: BB C8 C8 7C                  CONTINUE
       00:0C15: 00 00 
  1487                        
  1488                        ; RSHIFT ( x1 u -- x2 )
  1489                        ;
  1490                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1491                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1492                        ; exists if u is greater than or equal to the number of bits in a cell.
  1493                        
  Fri Mar 18 2016 23:20                                                                                                    Page 32


  1494 00:0C17: 04 0C 00 06                  HEADER  6,"RSHIFT",NORMAL
       00:0C1B: 52 53 48 49 
       00:0C1F: 46 54 
  1495                        RSHIFT:
  1496 00:0C21: A6 01                        ldx     <1                      ; Pull bit count
  1497 00:0C23: 08                           php
  1498 00:0C24: 7B                           tdc
  1499 00:0C25: 1A                           inc     a                       ; .. from the stack
  1500 00:0C26: 1A                           inc     a
  1501 00:0C27: 5B                           tcd
  1502 00:0C28: 28                           plp
  1503 00:0C29: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1504 00:0C2B: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1505 00:0C2E: B0 0B                        bcs     RSHIFT_2                ; Yes, result will be zero
  1506 00:0C30: 46 01        RSHIFT_1        lsr     <1                      ; Shift one bit left
  1507 00:0C32: CA                           dex                             ; Update count
  1508 00:0C33: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1509 00:0C35: BB C8 C8 7C  RSHIFT_0        CONTINUE                        ; Done
       00:0C39: 00 00 
  1510 00:0C3B: 64 01        RSHIFT_2        stz     <1                      ; Clear top value
  1511 00:0C3D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0C41: 00 00 
  1512                        
  1513                        ; XOR ( x1 x2 -- x3 )
  1514                        ;
  1515                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1516                        
  1517 00:0C43: 1A 0C 00 03                  HEADER  3,"XOR",NORMAL
       00:0C47: 58 4F 52 
  1518                        XOR:
  1519 00:0C4A: A5 01                        lda     <1
  1520 00:0C4C: 45 03                        eor     <3
  1521 00:0C4E: 85 03                        sta     <3
  1522 00:0C50: 7B                           tdc
  1523 00:0C51: 1A                           inc     a
  1524 00:0C52: 1A                           inc     a
  1525 00:0C53: 5B                           tcd
  1526 00:0C54: BB C8 C8 7C                  CONTINUE
       00:0C58: 00 00 
  1527                        
  1528                        ;==============================================================================
  1529                        ; Control Words
  1530                        ;------------------------------------------------------------------------------
  1531                        
  1532                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1533                        ;
  1534                        ; Empty the data stack and perform the function of QUIT, which includes
  1535                        ; emptying the return stack, without displaying a message.
  1536                        
  1537 00:0C5A: 46 0C 00 05                  HEADER  5,"ABORT",NORMAL
       00:0C5E: 41 42 4F 52 
       00:0C62: 54 
  1538 00:0C63: 20 1D 12     ABORT:          jsr     DO_COLON
  1539 00:0C66: 6A 0C                        dw      DO_ABORT
  1540 00:0C68: D6 0C                        dw      QUIT
  1541                        
  1542                        DO_ABORT:
  1543 00:0C6A: A9 7F 01                     lda     #DSTACK_END-1
  Fri Mar 18 2016 23:20                                                                                                    Page 33


  1544 00:0C6D: 5B                           tcd
  1545 00:0C6E: BB C8 C8 7C                  CONTINUE
       00:0C72: 00 00 
  1546                        
  1547                        ; (BUILD) ( dtc-addr -- )
  1548                        ;
  1549                        ; Adds a jump the to exection function for the new word.
  1550                        
  1551 00:0C74: 5D 0C 00 07                  HEADER  7,"(BUILD)",NORMAL
       00:0C78: 28 42 55 49 
       00:0C7C: 4C 44 29 
  1552 00:0C7F: 20 1D 12     BUILD:          jsr     DO_COLON
  1553 00:0C82: DF 12 20 00                  dw      DO_LITERAL,$20
  1554 00:0C86: 17 06                        dw      C_COMMA
  1555 00:0C88: 9B 05                        dw      COMMA
  1556 00:0C8A: C7 0C                        dw      EXIT
  1557                        
  1558                        ; CREATE ( -- ) [TODO]
  1559                        ;
  1560                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1561                        ; definition for name with the execution semantics defined below. If the data-
  1562                        ; space pointer is not aligned, reserve enough data space to align it. The new
  1563                        ; data-space pointer defines names data field. CREATE does not allocate data
  1564                        ; space in names data field.
  1565                        
  1566 00:0C8C: 77 0C 00 06                  HEADER  6,"CREATE",NORMAL
       00:0C90: 43 52 45 41 
       00:0C94: 54 45 
  1567 00:0C96: 20 1D 12     CREATE:         jsr     DO_COLON
  1568                                        ; parse
  1569 00:0C99: 46 06                        dw      HERE
  1570 00:0C9B: 9B 04 DB 05                  dw      LATEST,FETCH,COMMA
       00:0C9F: 9B 05 
  1571 00:0CA1: F0 04                        dw      ZERO
  1572 00:0CA3: 17 06                        dw      C_COMMA
  1573 00:0CA5: 9B 04                        dw      LATEST
  1574 00:0CA7: 6D 05                        dw      STORE
  1575                                        ; move name
  1576 00:0CA9: C7 0C                        dw      EXIT
  1577                        
  1578                        ; EXECUTE ( i*x xt -- j*x )
  1579                        ;
  1580                        ; Remove xt from the stack and perform the semantics identified by it. Other
  1581                        ; stack effects are due to the word EXECUTEd.
  1582                        
  1583 00:0CAB: 8F 0C 00 07                  HEADER  7,"EXECUTE",NORMAL
       00:0CAF: 45 58 45 43 
       00:0CB3: 55 54 45 
  1584                        EXECUTE:
  1585 00:0CB6: A6 01                        ldx     <1
  1586 00:0CB8: 7B                           tdc
  1587 00:0CB9: 1A                           inc     a
  1588 00:0CBA: 1A                           inc     a
  1589 00:0CBB: 5B                           tcd
  1590 00:0CBC: CA                           dex
  1591 00:0CBD: DA                           phx
  1592 00:0CBE: 60                           rts
  1593                        
  Fri Mar 18 2016 23:20                                                                                                    Page 34


  1594                        ; EXIT ( -- ) ( R: nest-sys -- )
  1595                        ;
  1596                        ; Return control to the calling definition specified by nest-sys. Before
  1597                        ; executing EXIT within a do-loop, a program shall discard the loop-control
  1598                        ; parameters by executing UNLOOP.
  1599                        
  1600 00:0CBF: AE 0C 00 04                  HEADER  4,"EXIT",NORMAL
       00:0CC3: 45 58 49 54 
  1601                        EXIT:
  1602 00:0CC7: 7A                           ply
  1603 00:0CC8: BB C8 C8 7C                  CONTINUE
       00:0CCC: 00 00 
  1604                        
  1605                        ; QUIT ( -- ) ( R: i*x -- )
  1606                        ;
  1607                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  1608                        ; user input device the input source, and enter interpretation state. Do not
  1609                        ; display a message. Repeat the following:
  1610                        ;  Accept a line from the input source into the input buffer, set >IN to zero,
  1611                        ;   and interpret.
  1612                        ;  Display the implementation-defined system prompt if in interpretation state,
  1613                        ;   all processing has been completed, and no ambiguous condition exists.
  1614                        ;
  1615                        ; In this implementation it is defined as:
  1616                        ;
  1617                        ;   DO_QUIT 0 STATE !
  1618                        ;   0 (SOURCE-ID) !
  1619                        ;   BEGIN
  1620                        ;     REFILL
  1621                        ;     WHILE SOURCE EVALUATE
  1622                        ;     STATE @ 0= IF S" Ok" CR TYPE THEN
  1623                        ;   AGAIN ;
  1624                        
  1625 00:0CCE: C2 0C 00 04                  HEADER  4,"QUIT",NORMAL
       00:0CD2: 51 55 49 54 
  1626 00:0CD6: 20 1D 12     QUIT:           jsr     DO_COLON
  1627 00:0CD9: 06 0D                        dw      DO_QUIT
  1628 00:0CDB: F0 04                        dw      ZERO
  1629 00:0CDD: DA 04                        dw      STATE
  1630 00:0CDF: 6D 05                        dw      STORE
  1631 00:0CE1: F0 04                        dw      ZERO
  1632 00:0CE3: CC 04                        dw      SOURCEID
  1633 00:0CE5: 6D 05                        dw      STORE
  1634 00:0CE7: B0 0F        QUIT_1:         dw      REFILL
  1635 00:0CE9: 02 12 EF 0C                  dw      QUERY_BRANCH,QUIT_2
  1636 00:0CED: C7 0E                        dw      INTERPRET
  1637 00:0CEF: DA 04        QUIT_2:         dw      STATE
  1638 00:0CF1: DB 05                        dw      FETCH
  1639 00:0CF3: F6 0A                        dw      ZERO_EQUAL
  1640 00:0CF5: 02 12 02 0D                  dw      QUERY_BRANCH,QUIT_3
  1641 00:0CF9: 47 13                        dw      DO_S_QUOTE
  1642 00:0CFB: 02 4F 6B                     db      2,"Ok"
  1643 00:0CFE: 97 14                        dw      TYPE
  1644 00:0D00: 1A 14                        dw      CR
  1645 00:0D02: EB 11 E7 0C  QUIT_3:         dw      BRANCH,QUIT_1
  1646                        
  1647                        DO_QUIT:
  1648 00:0D06: A9 FF 01                     lda     #RSTACK_END-1           ; Reset the return stack
  Fri Mar 18 2016 23:20                                                                                                    Page 35


  1649 00:0D09: 1B                           tcs
  1650 00:0D0A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0D0E: 00 00 
  1651                        
  1652                        ;==============================================================================
  1653                        ; Parser & Interpreter
  1654                        ;------------------------------------------------------------------------------
  1655                        
  1656                        ; ?NUMBER
  1657                        ;
  1658                        ;   DUP  0 0 ROT COUNT      -- ca ud adr n
  1659                        ;   ?SIGN >R  >NUMBER       -- ca ud adr' n'
  1660                        ;   IF   R> 2DROP 2DROP 0   -- ca 0   (error)
  1661                        ;   ELSE 2DROP NIP R>
  1662                        ;       IF NEGATE THEN  -1  -- n -1   (ok)
  1663                        ;   THEN ;
  1664                        
  1665 00:0D10: D1 0C 00 07                  HEADER  7,"?NUMBER",NORMAL
       00:0D14: 3F 4E 55 4D 
       00:0D18: 42 45 52 
  1666 00:0D1B: 20 1D 12     QUERY_NUMBER:   jsr     DO_COLON
  1667 00:0D1E: 60 07                        dw      DUP
  1668 00:0D20: F0 04                        dw      ZERO
  1669 00:0D22: F0 04                        dw      ZERO
  1670 00:0D24: AE 07                        dw      ROT
  1671 00:0D26: A1 11                        dw      COUNT
  1672 00:0D28: 59 0D                        dw      QUERY_SIGN
  1673 00:0D2A: 24 08                        dw      TO_R
  1674 00:0D2C: A0 0D                        dw      TO_NUMBER
  1675 00:0D2E: 02 12 3E 0D                  dw      QUERY_BRANCH,QNUM_1
  1676 00:0D32: 5D 08                        dw      R_FROM
  1677 00:0D34: CD 06                        dw      TWO_DROP
  1678 00:0D36: CD 06                        dw      TWO_DROP
  1679 00:0D38: F0 04                        dw      ZERO
  1680 00:0D3A: EB 11 4E 0D                  dw      BRANCH,QNUM_3
  1681 00:0D3E: CD 06        QNUM_1:         dw      TWO_DROP
  1682 00:0D40: 75 07                        dw      NIP
  1683 00:0D42: 5D 08                        dw      R_FROM
  1684 00:0D44: 02 12 4A 0D                  dw      QUERY_BRANCH,QNUM_2
  1685 00:0D48: 82 09                        dw      NEGATE
  1686 00:0D4A: DF 12 FF FF  QNUM_2:         dw      DO_LITERAL,-1
  1687 00:0D4E: C7 0C        QNUM_3:         dw      EXIT
  1688                        
  1689                        ; ?SIGN ( c-addr n -- adr' n' f )
  1690                        ;
  1691                        ;   OVER C@                 -- adr n c
  1692                        ;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else 0
  1693                        ;   DUP IF 1+               -- +=0, -=+2
  1694                        ;       >R 1 /STRING R>     -- adr' n' f
  1695                        ;   THEN ;
  1696                        
  1697 00:0D50: 13 0D 00 05                  HEADER  5,"?SIGN",NORMAL
       00:0D54: 3F 53 49 47 
       00:0D58: 4E 
  1698 00:0D59: 20 1D 12     QUERY_SIGN:     jsr     DO_COLON
  1699 00:0D5C: 83 07                        dw      OVER
  1700 00:0D5E: 2E 06                        dw      C_FETCH
  1701 00:0D60: DF 12 2D 00                  dw      DO_LITERAL,'-'
  Fri Mar 18 2016 23:20                                                                                                    Page 36


  1702 00:0D64: BF 08                        dw      MINUS
  1703 00:0D66: 60 07                        dw      DUP
  1704 00:0D68: 2E 09                        dw      ABS
  1705 00:0D6A: DF 12 01 00                  dw      DO_LITERAL,1
  1706 00:0D6E: 5A 0B                        dw      EQUAL
  1707 00:0D70: AE 0B                        dw      AND
  1708 00:0D72: 60 07                        dw      DUP
  1709 00:0D74: 02 12 84 0D                  dw      QUERY_BRANCH,QSIGN_1
  1710 00:0D78: F2 08                        dw      ONE_PLUS
  1711 00:0D7A: 24 08                        dw      TO_R
  1712 00:0D7C: DF 12 01 00                  dw      DO_LITERAL,1
  1713 00:0D80: 19 11                        dw      SLASH_STRING
  1714 00:0D82: 5D 08                        dw      R_FROM
  1715 00:0D84: C7 0C        QSIGN_1:        dw      EXIT
  1716                        
  1717                        ; >COUNTED ( c-addr n -- )
  1718                        ;
  1719                        ;   2DUP C! CHAR+ SWAP CMOVE
  1720                        
  1721 00:0D86: 20 1D 12     TO_COUNTED:     jsr     DO_COLON
  1722 00:0D89: E1 06                        dw      TWO_DUP
  1723 00:0D8B: FD 05                        dw      C_STORE
  1724 00:0D8D: 9C 06                        dw      CHAR_PLUS
  1725 00:0D8F: 99 07                        dw      SWAP
  1726 00:0D91: 33 11                        dw      CMOVE
  1727 00:0D93: C7 0C                        dw      EXIT
  1728                        
  1729                        ; >NUMBER ( ud adr u -- ud' adr' u' )
  1730                        ;
  1731                        ;
  1732                        ;   BEGIN
  1733                        ;   DUP WHILE
  1734                        ;       OVER C@ DIGIT?
  1735                        ;       0= IF DROP EXIT THEN
  1736                        ;       >R 2SWAP BASE @ UD*
  1737                        ;       R> M+ 2SWAP
  1738                        ;       1 /STRING
  1739                        ;   REPEAT ;
  1740                        
  1741 00:0D95: 53 0D 00 07                  HEADER  7,">NUMBER",NORMAL
       00:0D99: 3E 4E 55 4D 
       00:0D9D: 42 45 52 
  1742 00:0DA0: 20 1D 12     TO_NUMBER:      jsr     DO_COLON
  1743 00:0DA3: 60 07        TO_NUM_1:       dw      DUP
  1744 00:0DA5: 02 12 D3 0D                  dw      QUERY_BRANCH,TO_NUM_3
  1745 00:0DA9: 83 07                        dw      OVER
  1746 00:0DAB: 2E 06                        dw      C_FETCH
  1747 00:0DAD: 52 0E                        dw      DIGIT_QUERY
  1748 00:0DAF: F6 0A                        dw      ZERO_EQUAL
  1749 00:0DB1: 02 12 B9 0D                  dw      QUERY_BRANCH,TO_NUM_2
  1750 00:0DB5: 4F 07                        dw      DROP
  1751 00:0DB7: C7 0C                        dw      EXIT
  1752 00:0DB9: 24 08        TO_NUM_2:       dw      TO_R
  1753 00:0DBB: 1B 07                        dw      TWO_SWAP
  1754 00:0DBD: 64 04                        dw      BASE
  1755 00:0DBF: DB 05                        dw      FETCH
  1756 00:0DC1: 42 0A                        dw      UD_STAR
  1757 00:0DC3: 5D 08                        dw      R_FROM
  Fri Mar 18 2016 23:20                                                                                                    Page 37


  1758 00:0DC5: 70 0A                        dw      M_PLUS
  1759 00:0DC7: 1B 07                        dw      TWO_SWAP
  1760 00:0DC9: DF 12 01 00                  dw      DO_LITERAL,1
  1761 00:0DCD: 19 11                        dw      SLASH_STRING
  1762 00:0DCF: EB 11 A3 0D                  dw      BRANCH,TO_NUM_1
  1763 00:0DD3: C7 0C        TO_NUM_3:       dw      EXIT
  1764                        
  1765                        ; ACCEPT ( c-addr +n1 -- +n2 )
  1766                        ;
  1767                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  1768                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  1769                        ; received. A program that depends on the presence or absence of non-graphic
  1770                        ; characters in the string has an environmental dependency. The editing
  1771                        ; functions, if any, that the system performs in order to construct the string
  1772                        ; are implementation-defined.
  1773                        ;
  1774                        ; Input terminates when an implementation-defined line terminator is received.
  1775                        ; When input terminates, nothing is appended to the string, and the display is
  1776                        ; maintained in an implementation-defined way.
  1777                        ;
  1778                        ; +n2 is the length of the string stored at c-addr.
  1779                        ;
  1780                        ;   OVER + 1- OVER      -- sa ea a
  1781                        ;   BEGIN KEY           -- sa ea a c
  1782                        ;   DUP 0D <> WHILE
  1783                        ;     DUP 8 = OVER 127 = OR IF
  1784                        ;       DROP 1-
  1785                        ;       >R OVER R> UMAX
  1786                        ;       8 EMIT SPACE 8 EMIT
  1787                        ;     ELSE
  1788                        ;       DUP EMIT        -- sa ea a c
  1789                        ;       OVER C! 1+ OVER UMIN
  1790                        ;     THEN              -- sa ea a
  1791                        ;   REPEAT              -- sa ea a c
  1792                        ;   DROP NIP SWAP - ;
  1793                        
  1794 00:0DD5: 98 0D 00 06                  HEADER  6,"ACCEPT",NORMAL
       00:0DD9: 41 43 43 45 
       00:0DDD: 50 54 
  1795 00:0DDF: 20 1D 12     ACCEPT:         jsr     DO_COLON
  1796 00:0DE2: 83 07                        dw      OVER
  1797 00:0DE4: A9 08                        dw      PLUS
  1798 00:0DE6: 00 09                        dw      ONE_MINUS
  1799 00:0DE8: 83 07                        dw      OVER
  1800 00:0DEA: 49 14        ACCEPT_1:       dw      KEY
  1801 00:0DEC: 60 07                        dw      DUP
  1802 00:0DEE: DF 12 0D 00                  dw      DO_LITERAL,$0D
  1803 00:0DF2: 41 0B                        dw      NOT_EQUAL
  1804 00:0DF4: 02 12 3E 0E                  dw      QUERY_BRANCH,ACCEPT_4
  1805 00:0DF8: 60 07                        dw      DUP
  1806 00:0DFA: DF 12 08 00                  dw      DO_LITERAL,$08
  1807 00:0DFE: 5A 0B                        dw      EQUAL
  1808 00:0E00: 83 07                        dw      OVER
  1809 00:0E02: DF 12 7F 00                  dw      DO_LITERAL,$7f
  1810 00:0E06: 5A 0B                        dw      EQUAL
  1811 00:0E08: 07 0C                        dw      OR
  1812 00:0E0A: 02 12 2C 0E                  dw      QUERY_BRANCH,ACCEPT_2
  1813 00:0E0E: 4F 07                        dw      DROP
  Fri Mar 18 2016 23:20                                                                                                    Page 38


  1814 00:0E10: 00 09                        dw      ONE_MINUS
  1815 00:0E12: 24 08                        dw      TO_R
  1816 00:0E14: 83 07                        dw      OVER
  1817 00:0E16: 5D 08                        dw      R_FROM
  1818 00:0E18: 98 09                        dw      UMAX
  1819 00:0E1A: DF 12 08 00                  dw      DO_LITERAL,8
  1820 00:0E1E: 33 14                        dw      EMIT
  1821 00:0E20: 65 14                        dw      SPACE
  1822 00:0E22: DF 12 08 00                  dw      DO_LITERAL,8
  1823 00:0E26: 33 14                        dw      EMIT
  1824 00:0E28: EB 11 3A 0E                  dw      BRANCH,ACCEPT_3
  1825 00:0E2C: 60 07        ACCEPT_2:       dw      DUP
  1826 00:0E2E: 33 14                        dw      EMIT
  1827 00:0E30: 83 07                        dw      OVER
  1828 00:0E32: FD 05                        dw      C_STORE
  1829 00:0E34: F2 08                        dw      ONE_PLUS
  1830 00:0E36: 83 07                        dw      OVER
  1831 00:0E38: AC 09                        dw      UMIN
  1832 00:0E3A: EB 11 EA 0D  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  1833 00:0E3E: 4F 07        ACCEPT_4:       dw      DROP
  1834 00:0E40: 75 07                        dw      NIP
  1835 00:0E42: 99 07                        dw      SWAP
  1836 00:0E44: BF 08                        dw      MINUS
  1837 00:0E46: C7 0C                        dw      EXIT
  1838                        
  1839                        ; DIGIT?
  1840                        ;
  1841                        ;   [ HEX ] DUP 39 > 100 AND +     silly looking
  1842                        ;   DUP 140 > 107 AND -   30 -     but it works!
  1843                        ;   DUP BASE @ U< ;
  1844                        
  1845 00:0E48: D8 0D 00 06                  HEADER  6,"DIGIT?",NORMAL
       00:0E4C: 44 49 47 49 
       00:0E50: 54 3F 
  1846 00:0E52: 20 1D 12     DIGIT_QUERY:    jsr     DO_COLON
  1847 00:0E55: 60 07                        dw      DUP
  1848 00:0E57: DF 12 39 00                  dw      DO_LITERAL,'9'
  1849 00:0E5B: 73 0B                        dw      GREATER
  1850 00:0E5D: DF 12 00 01                  dw      DO_LITERAL,$100
  1851 00:0E61: AE 0B                        dw      AND
  1852 00:0E63: A9 08                        dw      PLUS
  1853 00:0E65: 60 07                        dw      DUP
  1854 00:0E67: DF 12 40 01                  dw      DO_LITERAL,$140
  1855 00:0E6B: 73 0B                        dw      GREATER
  1856 00:0E6D: DF 12 07 01                  dw      DO_LITERAL,$107
  1857 00:0E71: AE 0B                        dw      AND
  1858 00:0E73: BF 08                        dw      MINUS
  1859 00:0E75: DF 12 30 00                  dw      DO_LITERAL,'0'
  1860 00:0E79: BF 08                        dw      MINUS
  1861 00:0E7B: 60 07                        dw      DUP
  1862 00:0E7D: 64 04                        dw      BASE
  1863 00:0E7F: DB 05                        dw      FETCH
  1864 00:0E81: 82 0B                        dw      U_LESS
  1865 00:0E83: C7 0C                        dw      EXIT
  1866                        
  1867                        ; EVALUATE ( i*x c-addr u -- j*x )
  1868                        ;
  1869                        ; Save the current input source specification. Store minus-one (-1) in
  Fri Mar 18 2016 23:20                                                                                                    Page 39


  1870                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  1871                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  1872                        ; parse area is empty, restore the prior input source specification. Other
  1873                        ; stack effects are due to the words EVALUATEd.
  1874                        ;
  1875                        ;   >R >R SAVE-INPUT
  1876                        ;   -1 (SOURCE-ID) !
  1877                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  1878                        ;   INTERPRET
  1879                        ;   RESTORE-INPUT DROP
  1880                        
  1881 00:0E85: 4B 0E 00 08                  HEADER  8,"EVALUATE",NORMAL
       00:0E89: 45 56 41 4C 
       00:0E8D: 55 41 54 45 
  1882 00:0E91: 20 1D 12     EVALUATE:       jsr     DO_COLON
  1883 00:0E94: 24 08                        dw      TO_R
  1884 00:0E96: 24 08                        dw      TO_R
  1885 00:0E98: 3D 10                        dw      SAVE_INPUT
  1886 00:0E9A: 5D 08                        dw      R_FROM
  1887 00:0E9C: 5D 08                        dw      R_FROM
  1888 00:0E9E: 2E 05                        dw      TRUE
  1889 00:0EA0: CC 04                        dw      SOURCEID
  1890 00:0EA2: 6D 05                        dw      STORE
  1891 00:0EA4: F0 04                        dw      ZERO
  1892 00:0EA6: 57 04                        dw      TO_IN
  1893 00:0EA8: 6D 05                        dw      STORE
  1894 00:0EAA: AC 04                        dw      LENGTH
  1895 00:0EAC: 6D 05                        dw      STORE
  1896 00:0EAE: 81 04                        dw      BUFFER
  1897 00:0EB0: 6D 05                        dw      STORE
  1898 00:0EB2: C7 0E                        dw      INTERPRET
  1899 00:0EB4: EE 0F                        dw      RESTORE_INPUT
  1900 00:0EB6: 4F 07                        dw      DROP
  1901 00:0EB8: C7 0C                        dw      EXIT
  1902                        
  1903                        ; INTERPRET ( -- )
  1904                        ;
  1905                        ;
  1906                        ;   BEGIN
  1907                        ;   BL WORD DUP C@ WHILE        -- textadr
  1908                        ;       FIND                    -- a 0/1/-1
  1909                        ;       ?DUP IF                 -- xt 1/-1
  1910                        ;           1+ STATE @ 0= OR    immed or interp?
  1911                        ;           IF EXECUTE ELSE , THEN
  1912                        ;       ELSE                    -- textadr
  1913                        ;           ?NUMBER
  1914                        ;           IF STATE @
  1915                        ;               IF POSTPONE LITERAL THEN     converted ok
  1916                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  1917                        ;           THEN
  1918                        ;       THEN
  1919                        ;   REPEAT DROP ;
  1920                        
  1921 00:0EBA: 88 0E 00 09                  HEADER  9,"INTERPRET",NORMAL
       00:0EBE: 49 4E 54 45 
       00:0EC2: 52 50 52 45 
       00:0EC6: 54 
  1922 00:0EC7: 20 1D 12     INTERPRET:      jsr     DO_COLON
  Fri Mar 18 2016 23:20                                                                                                    Page 40


  1923 00:0ECA: 02 05        INTERPRET_1:    dw      BL
  1924 00:0ECC: B5 10                        dw      WORD
  1925 00:0ECE: 60 07                        dw      DUP
  1926 00:0ED0: 2E 06                        dw      C_FETCH
  1927 00:0ED2: 02 12 1E 0F                  dw      QUERY_BRANCH,INTERPRET_7
  1928 00:0ED6: 2A 0F                        dw      FIND
  1929 00:0ED8: 3D 07                        dw      QUERY_DUP
  1930 00:0EDA: 02 12 F8 0E                  dw      QUERY_BRANCH,INTERPRET_4
  1931 00:0EDE: F2 08                        dw      ONE_PLUS
  1932 00:0EE0: DA 04                        dw      STATE
  1933 00:0EE2: DB 05                        dw      FETCH
  1934 00:0EE4: F6 0A                        dw      ZERO_EQUAL
  1935 00:0EE6: 07 0C                        dw      OR
  1936 00:0EE8: 02 12 F2 0E                  dw      QUERY_BRANCH,INTERPRET_2
  1937 00:0EEC: B6 0C                        dw      EXECUTE
  1938 00:0EEE: EB 11 F4 0E                  dw      BRANCH,INTERPRET_3
  1939 00:0EF2: 9B 05        INTERPRET_2:    dw      COMMA
  1940 00:0EF4: EB 11 1A 0F  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  1941 00:0EF8: 1B 0D        INTERPRET_4:    dw      QUERY_NUMBER
  1942 00:0EFA: 02 12 0C 0F                  dw      QUERY_BRANCH,INTERPRET_5
  1943 00:0EFE: DA 04                        dw      STATE
  1944 00:0F00: DB 05                        dw      FETCH
  1945 00:0F02: 02 12 1A 0F                  dw      QUERY_BRANCH,INTERPRET_6
  1946 00:0F06: C5 12                        dw      LITERAL
  1947 00:0F08: EB 11 1A 0F                  dw      BRANCH,INTERPRET_6
  1948 00:0F0C: A1 11        INTERPRET_5:    dw      COUNT
  1949 00:0F0E: 97 14                        dw      TYPE
  1950 00:0F10: DF 12 3F 00                  dw      DO_LITERAL,$3f
  1951 00:0F14: 33 14                        dw      EMIT
  1952 00:0F16: 1A 14                        dw      CR
  1953 00:0F18: 63 0C                        dw      ABORT
  1954 00:0F1A: EB 11 CA 0E  INTERPRET_6     dw      BRANCH,INTERPRET_1
  1955 00:0F1E: 4F 07        INTERPRET_7:    dw      DROP
  1956 00:0F20: C7 0C                        dw      EXIT
  1957                        
  1958                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  1959                        ;
  1960                        ; Find the definition named in the counted string at c-addr. If the definition
  1961                        ; is not found, return c-addr and zero. If the definition is found, return its
  1962                        ; execution token xt. If the definition is immediate, also return one (1),
  1963                        ; otherwise also return minus-one (-1). For a given string, the values returned
  1964                        ; by FIND while compiling may differ from those returned while not compiling.
  1965                        ;
  1966                        ;   LATEST @ BEGIN             -- a nfa
  1967                        ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
  1968                        ;       S=                     -- a nfa f
  1969                        ;       DUP IF
  1970                        ;           DROP
  1971                        ;           NFA>LFA @ DUP      -- a link link
  1972                        ;       THEN
  1973                        ;   0= UNTIL                   -- a nfa  OR  a 0
  1974                        ;   DUP IF
  1975                        ;       NIP DUP NFA>CFA        -- nfa xt
  1976                        ;       SWAP IMMED?            -- xt iflag
  1977                        ;       0= 1 OR                -- xt 1/-1
  1978                        ;   THEN ;
  1979                        
  1980 00:0F22: BD 0E 00 04                  HEADER  4,"FIND",NORMAL
  Fri Mar 18 2016 23:20                                                                                                    Page 41


       00:0F26: 46 49 4E 44 
  1981 00:0F2A: 20 1D 12     FIND:           jsr     DO_COLON
  1982 00:0F2D: 9B 04                        dw      LATEST
  1983 00:0F2F: DB 05                        dw      FETCH
  1984 00:0F31: E1 06        FIND1:          dw      TWO_DUP
  1985 00:0F33: 83 07                        dw      OVER
  1986 00:0F35: 2E 06                        dw      C_FETCH
  1987 00:0F37: 9C 06                        dw      CHAR_PLUS
  1988 00:0F39: 05 10                        dw      S_EQUAL
  1989 00:0F3B: 60 07                        dw      DUP
  1990 00:0F3D: 02 12 49 0F                  dw      QUERY_BRANCH,FIND2
  1991 00:0F41: 4F 07                        dw      DROP
  1992 00:0F43: 9B 0F                        dw      NFA_TO_LFA
  1993 00:0F45: DB 05                        dw      FETCH
  1994 00:0F47: 60 07                        dw      DUP
  1995 00:0F49: F6 0A        FIND2:          dw      ZERO_EQUAL
  1996 00:0F4B: 02 12 31 0F                  dw      QUERY_BRANCH,FIND1
  1997 00:0F4F: 60 07                        dw      DUP
  1998 00:0F51: 02 12 67 0F                  dw      QUERY_BRANCH,FIND3
  1999 00:0F55: 75 07                        dw      NIP
  2000 00:0F57: 60 07                        dw      DUP
  2001 00:0F59: 87 0F                        dw      NFA_TO_CFA
  2002 00:0F5B: 99 07                        dw      SWAP
  2003 00:0F5D: 73 0F                        dw      IMMED_QUERY
  2004 00:0F5F: F6 0A                        dw      ZERO_EQUAL
  2005 00:0F61: DF 12 01 00                  dw      DO_LITERAL,1
  2006 00:0F65: 07 0C                        dw      OR
  2007 00:0F67: C7 0C        FIND3:          dw      EXIT
  2008                        
  2009                        ; IMMED? ( nfa -- f )
  2010                        
  2011 00:0F69: 25 0F 00 06                  HEADER  6,"IMMED?",NORMAL
       00:0F6D: 49 4D 4D 45 
       00:0F71: 44 3F 
  2012 00:0F73: 20 1D 12     IMMED_QUERY:    jsr     DO_COLON
  2013 00:0F76: 00 09                        dw      ONE_MINUS
  2014 00:0F78: 2E 06                        dw      C_FETCH
  2015 00:0F7A: C7 0C                        dw      EXIT
  2016                        
  2017                        ; NFA>CFA ( nfa -- cfa )
  2018                        
  2019 00:0F7C: 6C 0F 00 07                  HEADER  7,"NFA>CFA",NORMAL
       00:0F80: 4E 46 41 3E 
       00:0F84: 43 46 41 
  2020 00:0F87: 20 1D 12     NFA_TO_CFA:     jsr     DO_COLON
  2021 00:0F8A: A1 11                        dw      COUNT
  2022 00:0F8C: A9 08                        dw      PLUS
  2023 00:0F8E: C7 0C                        dw      EXIT
  2024                        
  2025                        ; NFA>LFA ( nfa -- lfa )
  2026                        
  2027 00:0F90: 7F 0F 00 07                  HEADER  7,"NFA>LFA",NORMAL
       00:0F94: 4E 46 41 3E 
       00:0F98: 4C 46 41 
  2028 00:0F9B: 20 1D 12     NFA_TO_LFA:     jsr     DO_COLON
  2029 00:0F9E: DF 12 03 00                  dw      DO_LITERAL,3
  2030 00:0FA2: BF 08                        dw      MINUS
  2031 00:0FA4: C7 0C                        dw      EXIT
  Fri Mar 18 2016 23:20                                                                                                    Page 42


  2032                        
  2033                        ; REFILL ( -- flag )
  2034                        ;
  2035                        ; Attempt to fill the input buffer from the input source, returning a true flag
  2036                        ; if successful.
  2037                        ;
  2038                        ; When the input source is the user input device, attempt to receive input into
  2039                        ; the terminal input buffer. If successful, make the result the input buffer,
  2040                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  2041                        ; is considered successful. If there is no input available from the current
  2042                        ; input source, return false.
  2043                        ;
  2044                        ; When the input source is a string from EVALUATE, return false and perform no
  2045                        ; other action.
  2046                        ;
  2047                        ;   SOURCE-ID 0= IF
  2048                        ;     TIB DUP #TIB @ ACCEPT SPACE
  2049                        ;     LENGTH ! BUFFER !
  2050                        ;     0 >IN ! TRUE EXIT
  2051                        ;   THEN
  2052                        ;   FALSE
  2053                        
  2054 00:0FA6: 93 0F 00 06                  HEADER  6,"REFILL",NORMAL
       00:0FAA: 52 45 46 49 
       00:0FAE: 4C 4C 
  2055 00:0FB0: 20 1D 12     REFILL:         jsr     DO_COLON
  2056 00:0FB3: A4 10                        dw      SOURCE_ID
  2057 00:0FB5: F6 0A                        dw      ZERO_EQUAL
  2058 00:0FB7: 02 12 D9 0F                  dw      QUERY_BRANCH,REFILL_1
  2059 00:0FBB: E6 04                        dw      TIB
  2060 00:0FBD: 60 07                        dw      DUP
  2061 00:0FBF: 49 04                        dw      HASH_TIB
  2062 00:0FC1: DB 05                        dw      FETCH
  2063 00:0FC3: DF 0D                        dw      ACCEPT
  2064 00:0FC5: 65 14                        dw      SPACE
  2065 00:0FC7: AC 04                        dw      LENGTH
  2066 00:0FC9: 6D 05                        dw      STORE
  2067 00:0FCB: 81 04                        dw      BUFFER
  2068 00:0FCD: 6D 05                        dw      STORE
  2069 00:0FCF: F0 04                        dw      ZERO
  2070 00:0FD1: 57 04                        dw      TO_IN
  2071 00:0FD3: 6D 05                        dw      STORE
  2072 00:0FD5: 2E 05                        dw      TRUE
  2073 00:0FD7: C7 0C                        dw      EXIT
  2074 00:0FD9: 1A 05        REFILL_1:       dw      FALSE
  2075 00:0FDB: C7 0C                        dw      EXIT
  2076                        
  2077                        ; RESTORE-INPUT
  2078                        ;
  2079                        ;   >IN ! (LENGTH) ! BUFFER !
  2080                        ;   SOURCEID !
  2081                        ;   TRUE
  2082                        
  2083 00:0FDD: A9 0F 00 0D                  HEADER  13,"RESTORE-INPUT",NORMAL
       00:0FE1: 52 45 53 54 
       00:0FE5: 4F 52 45 2D 
       00:0FE9: 49 4E 50 55 
       00:0FED: 54 
  Fri Mar 18 2016 23:20                                                                                                    Page 43


  2084 00:0FEE: 20 1D 12     RESTORE_INPUT   jsr     DO_COLON
  2085 00:0FF1: 57 04                        dw      TO_IN
  2086 00:0FF3: 6D 05                        dw      STORE
  2087 00:0FF5: AC 04                        dw      LENGTH
  2088 00:0FF7: 6D 05                        dw      STORE
  2089 00:0FF9: 81 04                        dw      BUFFER
  2090 00:0FFB: 6D 05                        dw      STORE
  2091 00:0FFD: CC 04                        dw      SOURCEID
  2092 00:0FFF: 6D 05                        dw      STORE
  2093 00:1001: 2E 05                        dw      TRUE
  2094 00:1003: C7 0C                        dw      EXIT
  2095                        
  2096                        ; S= ( c-addr1 caddr2 u -- n)
  2097                        ;
  2098                        ; Misnamed, more like C's strncmp. Note that counted length bytes are compared!
  2099                        
  2100                        S_EQUAL:
  2101 00:1005: 5A                           phy
  2102 00:1006: A6 01                        ldx     <1                      ; Fetch maximum length
  2103 00:1008: F0 14                        beq     S_EQUAL_3
  2104 00:100A: A0 00 00                     ldy     #0
  2105 00:100D: E2 20                        short_a
  2106                        S_EQUAL_1:
  2107 00:100F: B1 05                        lda     (5),y                   ; Compare bytes
  2108 00:1011: D1 03                        cmp     (3),y
  2109 00:1013: D0 06                        bne     S_EQUAL_2
  2110 00:1015: C8                           iny
  2111 00:1016: CA                           dex                             ; End of strings?
  2112 00:1017: D0 F6                        bne     S_EQUAL_1               ; No
  2113 00:1019: 80 03                        bra     S_EQUAL_3               ; Yes. must be the same
  2114                        S_EQUAL_2:
  2115 00:101B: A2 FF FF                     ldx     #$ffff                  ; Difference found
  2116                        S_EQUAL_3:
  2117 00:101E: C2 20                        long_a
  2118 00:1020: 7B                           tdc                             ; Clean up the stack
  2119 00:1021: 1A                           inc     a
  2120 00:1022: 1A                           inc     a
  2121 00:1023: 1A                           inc     a
  2122 00:1024: 1A                           inc     a
  2123 00:1025: 5B                           tcd
  2124 00:1026: 86 01                        stx     <1                      ; Save the flag
  2125 00:1028: 7A                           ply
  2126 00:1029: BB C8 C8 7C                  CONTINUE
       00:102D: 00 00 
  2127                        
  2128                        ; SAVE-INPUT
  2129                        
  2130 00:102F: E0 0F 00 0A                  HEADER  10,"SAVE-INPUT",NORMAL
       00:1033: 53 41 56 45 
       00:1037: 2D 49 4E 50 
       00:103B: 55 54 
  2131 00:103D: 20 1D 12     SAVE_INPUT:     jsr     DO_COLON
  2132 00:1040: CC 04                        dw      SOURCEID
  2133 00:1042: DB 05                        dw      FETCH
  2134 00:1044: 81 04                        dw      BUFFER
  2135 00:1046: DB 05                        dw      FETCH
  2136 00:1048: AC 04                        dw      LENGTH
  2137 00:104A: DB 05                        dw      FETCH
  Fri Mar 18 2016 23:20                                                                                                    Page 44


  2138 00:104C: 57 04                        dw      TO_IN
  2139 00:104E: DB 05                        dw      FETCH
  2140 00:1050: C7 0C                        dw      EXIT
  2141                        
  2142                        ; SCAN ( c-addr n c == c-addr' n' )
  2143                        
  2144                        SCAN:
  2145                        SCAN_1:
  2146 00:1052: A5 03                        lda     <3                      ; Any data left to scan?
  2147 00:1054: F0 10                        beq     SCAN_2                  ; No.
  2148 00:1056: A5 01                        lda     <1                      ; Fetch and compare with scan
  2149 00:1058: E2 20                        short_a
  2150 00:105A: D2 05                        cmp     (5)
  2151 00:105C: C2 20                        long_a
  2152 00:105E: F0 06                        beq     SCAN_2
  2153 00:1060: E6 05                        inc     <5
  2154 00:1062: C6 03                        dec     <3
  2155 00:1064: 80 EC                        bra     SCAN_1
  2156                        SCAN_2:
  2157 00:1066: 4C 4F 07                     jmp     DROP                    ; Drop the character
  2158                        
  2159                        ; SKIP ( c-addr n c == c-addr' n' )
  2160                        ;
  2161                        
  2162                        SKIP:
  2163 00:1069: A5 03        SKIP_1:         lda     <3                      ; Any data left to skip over?
  2164 00:106B: F0 10                        beq     SKIP_2                  ; No.
  2165 00:106D: A5 01                        lda     <1                      ; Fetch and compare with skip
  2166 00:106F: E2 20                        short_a
  2167 00:1071: D2 05                        cmp     (5)
  2168 00:1073: C2 20                        long_a
  2169 00:1075: D0 06                        bne     SKIP_2                  ; Cannot be skipped
  2170 00:1077: E6 05                        inc     <5                      ; Bump data address
  2171 00:1079: C6 03                        dec     <3                      ; and update length
  2172 00:107B: 80 EC                        bra     SKIP_1                  ; And repeat
  2173                        SKIP_2:
  2174 00:107D: 4C 4F 07                     jmp     DROP                    ; Drop the character
  2175                        
  2176                        ; SOURCE ( -- c-addr u )
  2177                        ;
  2178                        ; c-addr is the address of, and u is the number of characters in, the input
  2179                        ; buffer.
  2180                        ;
  2181                        ; In this implementation it is defined as
  2182                        ;
  2183                        ;   BUFFER @ LENGTH @
  2184                        
  2185 00:1080: 32 10 00 06                  HEADER  6,"SOURCE",NORMAL
       00:1084: 53 4F 55 52 
       00:1088: 43 45 
  2186 00:108A: 20 1D 12     SOURCE:         jsr     DO_COLON
  2187 00:108D: 81 04                        dw      BUFFER
  2188 00:108F: DB 05                        dw      FETCH
  2189 00:1091: AC 04                        dw      LENGTH
  2190 00:1093: DB 05                        dw      FETCH
  2191 00:1095: C7 0C                        dw      EXIT
  2192                        
  2193                        ; SOURCE-ID ( -- 0 | -1 )
  Fri Mar 18 2016 23:20                                                                                                    Page 45


  2194                        ;
  2195                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  2196                        ; device.
  2197                        
  2198 00:1097: 83 10 00 09                  HEADER  9,"SOURCE-ID",NORMAL
       00:109B: 53 4F 55 52 
       00:109F: 43 45 2D 49 
       00:10A3: 44 
  2199 00:10A4: 20 1D 12     SOURCE_ID:      jsr     DO_COLON
  2200 00:10A7: CC 04                        dw      SOURCEID
  2201 00:10A9: DB 05                        dw      FETCH
  2202 00:10AB: C7 0C                        dw      EXIT
  2203                        
  2204                        ; WORD
  2205                        ;
  2206                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  2207                        ;   DUP >R   ROT SKIP           -- c adr' n'
  2208                        ;   OVER >R  ROT SCAN           -- adr" n"
  2209                        ;   DUP IF CHAR- THEN        skip trailing delim.
  2210                        ;   R> R> ROT -   >IN +!        update >IN offset
  2211                        ;   TUCK -                      -- adr' N
  2212                        ;   HERE >counted               --
  2213                        ;   HERE                        -- a
  2214                        ;   BL OVER COUNT + C! ;    append trailing blank
  2215                        
  2216 00:10AD: 9A 10 00 04                  HEADER  4,"WORD",NORMAL
       00:10B1: 57 4F 52 44 
  2217 00:10B5: 20 1D 12     WORD:           jsr     DO_COLON
  2218 00:10B8: 60 07                        dw      DUP
  2219 00:10BA: 8A 10                        dw      SOURCE
  2220 00:10BC: 57 04                        dw      TO_IN
  2221 00:10BE: DB 05                        dw      FETCH
  2222 00:10C0: 19 11                        dw      SLASH_STRING
  2223 00:10C2: 60 07                        dw      DUP
  2224 00:10C4: 24 08                        dw      TO_R
  2225 00:10C6: AE 07                        dw      ROT
  2226 00:10C8: 69 10                        dw      SKIP
  2227 00:10CA: 83 07                        dw      OVER
  2228 00:10CC: 24 08                        dw      TO_R
  2229 00:10CE: AE 07                        dw      ROT
  2230 00:10D0: 52 10                        dw      SCAN
  2231 00:10D2: 60 07                        dw      DUP
  2232 00:10D4: 02 12 DA 10                  dw      QUERY_BRANCH,WORD_1
  2233 00:10D8: AD 06                        dw      CHAR_MINUS
  2234 00:10DA: 5D 08        WORD_1:         dw      R_FROM
  2235 00:10DC: 5D 08                        dw      R_FROM
  2236 00:10DE: AE 07                        dw      ROT
  2237 00:10E0: BF 08                        dw      MINUS
  2238 00:10E2: 57 04                        dw      TO_IN
  2239 00:10E4: 83 05                        dw      PLUS_STORE
  2240 00:10E6: C8 07                        dw      TUCK
  2241 00:10E8: BF 08                        dw      MINUS
  2242 00:10EA: 46 06                        dw      HERE
  2243 00:10EC: 86 0D                        dw      TO_COUNTED
  2244 00:10EE: 46 06                        dw      HERE
  2245 00:10F0: 02 05                        dw      BL
  2246 00:10F2: 83 07                        dw      OVER
  2247 00:10F4: A1 11                        dw      COUNT
  Fri Mar 18 2016 23:20                                                                                                    Page 46


  2248 00:10F6: A9 08                        dw      PLUS
  2249 00:10F8: FD 05                        dw      C_STORE
  2250 00:10FA: C7 0C                        dw      EXIT
  2251                        
  2252                        ;==============================================================================
  2253                        ; String Words
  2254                        ;------------------------------------------------------------------------------
  2255                        
  2256                        ; -TRAILING
  2257                        
  2258 00:10FC: B0 10 00 09                  HEADER  9,"-TRAILING",NORMAL
       00:1100: 2D 54 52 41 
       00:1104: 49 4C 49 4E 
       00:1108: 47 
  2259 00:1109: 20 1D 12     DASH_TRAILING:  jsr     DO_COLON
  2260                        
  2261 00:110C: C7 0C                        dw      EXIT
  2262                        
  2263                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  2264                        ;
  2265                        ; Adjust the character string at c-addr1 by n characters. The resulting
  2266                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  2267                        ; characters and is u1 minus n characters long.
  2268                        ;
  2269                        ;   ROT OVER + ROT ROT -
  2270                        
  2271 00:110E: FF 10 00 07                  HEADER  7,"/STRING",NORMAL
       00:1112: 2F 53 54 52 
       00:1116: 49 4E 47 
  2272 00:1119: 20 1D 12     SLASH_STRING:   jsr     DO_COLON
  2273 00:111C: AE 07                        dw      ROT
  2274 00:111E: 83 07                        dw      OVER
  2275 00:1120: A9 08                        dw      PLUS
  2276 00:1122: AE 07                        dw      ROT
  2277 00:1124: AE 07                        dw      ROT
  2278 00:1126: BF 08                        dw      MINUS
  2279 00:1128: C7 0C                        dw      EXIT
  2280                        
  2281                        ; BLANK
  2282                        
  2283                        ; CMOVE ( c-addr1 c-addr2 u -- )
  2284                        ;
  2285                        ; If u is greater than zero, copy u consecutive characters from the data space
  2286                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2287                        ; character from lower addresses to higher addresses.
  2288                        
  2289 00:112A: 11 11 00 05                  HEADER  5,"CMOVE",NORMAL
       00:112E: 43 4D 4F 56 
       00:1132: 45 
  2290                        CMOVE:
  2291 00:1133: 5A                           phy
  2292 00:1134: A6 01                        ldx     <1                      ; Any characters to move?
  2293 00:1136: F0 0F                        beq     CMOVE_2                 ; No
  2294 00:1138: A0 00 00                     ldy     #0
  2295 00:113B: E2 20                        short_a
  2296                        CMOVE_1:                                        ; Transfer a byte
  2297 00:113D: B1 05                        lda     (5),y
  2298 00:113F: 91 03                        sta     (3),y
  Fri Mar 18 2016 23:20                                                                                                    Page 47


  2299 00:1141: C8                           iny
  2300 00:1142: CA                           dex                             ; Decrement count
  2301 00:1143: D0 F8                        bne     CMOVE_1                 ; .. and repeat until done
  2302 00:1145: C2 20                        long_a
  2303                        CMOVE_2:
  2304 00:1147: 7B                           tdc                             ; Clean up the stack
  2305 00:1148: 18                           clc
  2306 00:1149: 69 06 00                     adc     #6
  2307 00:114C: 5B                           tcd
  2308 00:114D: 7A                           ply
  2309 00:114E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1152: 00 00 
  2310                        
  2311                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  2312                        ;
  2313                        ; If u is greater than zero, copy u consecutive characters from the data space
  2314                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2315                        ; character from higher addresses to lower addresses.
  2316                        
  2317 00:1154: 2D 11 00 06                  HEADER  6,"CMOVE>",NORMAL
       00:1158: 43 4D 4F 56 
       00:115C: 45 3E 
  2318                        CMOVE_GREATER:
  2319 00:115E: 5A                           phy
  2320 00:115F: A6 01                        ldx     <1                      ; Any characters to move?
  2321 00:1161: F0 0E                        beq     CMOVE_GT_2              ; No.
  2322 00:1163: A4 01                        ldy     <1
  2323 00:1165: E2 20                        short_a
  2324                        CMOVE_GT_1:
  2325 00:1167: 88                           dey                             ; Transfer a byte
  2326 00:1168: B1 05                        lda     (5),y
  2327 00:116A: 91 03                        sta     (3),y
  2328 00:116C: CA                           dex                             ; Decrement length
  2329 00:116D: D0 F8                        bne     CMOVE_GT_1              ; .. and repeat until done
  2330 00:116F: C2 20                        long_a
  2331                        CMOVE_GT_2:
  2332 00:1171: 7B                           tdc                             ; Clean up the stack
  2333 00:1172: 18                           clc
  2334 00:1173: 69 06 00                     adc     #6
  2335 00:1176: 5B                           tcd
  2336 00:1177: BB C8 C8 7C                  CONTINUE                        ; Done
       00:117B: 00 00 
  2337                        
  2338                        ; COMPARE ( c-addr1 u1 c-addr2 u2 -- n )
  2339                        ;
  2340                        ; Compare the string specified by c-addr1 u1 to the string specified by c-addr2
  2341                        ; u2. The strings are compared, beginning at the given addresses, character by
  2342                        ; character, up to the length of the shorter string or until a difference is
  2343                        ; found. If the two strings are identical, n is zero. If the two strings are
  2344                        ; identical up to the length of the shorter string, n is minus-one (-1) if u1
  2345                        ; is less than u2 and one (1) otherwise. If the two strings are not identical
  2346                        ; up to the length of the shorter string, n is minus-one (-1) if the first
  2347                        ; non-matching character in the string specified by c-addr1 u1 has a lesser
  2348                        ; numeric value than the corresponding character in the string specified by
  2349                        ; c-addr2 u2 and one (1) otherwise.
  2350                        
  2351 00:117D: 57 11 00 07                  HEADER  7,"COMPARE",NORMAL
       00:1181: 43 4F 4D 50 
  Fri Mar 18 2016 23:20                                                                                                    Page 48


       00:1185: 41 52 45 
  2352                        COMPARE:
  2353 00:1188: 5A                           phy
  2354                        
  2355                        ; TODO
  2356                        
  2357 00:1189: 7B                           tdc
  2358 00:118A: 18                           clc
  2359 00:118B: 69 06 00                     adc     #6
  2360 00:118E: 5B                           tcd
  2361 00:118F: 86 01                        stx     <1
  2362 00:1191: 7A                           ply
  2363 00:1192: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1196: 00 00 
  2364                        
  2365                        ; COUNT
  2366                        ;
  2367                        ; In this implementation it is defined as
  2368                        ;
  2369                        ;   DUP CHAR+ SWAP C@
  2370                        
  2371 00:1198: 80 11 00 05                  HEADER  5,"COUNT",NORMAL
       00:119C: 43 4F 55 4E 
       00:11A0: 54 
  2372 00:11A1: 20 1D 12     COUNT:          jsr     DO_COLON
  2373 00:11A4: 60 07                        dw      DUP
  2374 00:11A6: 9C 06                        dw      CHAR_PLUS
  2375 00:11A8: 99 07                        dw      SWAP
  2376 00:11AA: 2E 06                        dw      C_FETCH
  2377 00:11AC: C7 0C                        dw      EXIT
  2378                        
  2379                        ; SEARCH
  2380                        
  2381                        
  2382                        
  2383                        
  2384                        ;==============================================================================
  2385                        ; Compiling Words
  2386                        ;------------------------------------------------------------------------------
  2387                        
  2388                        ; +LOOP ( -- )
  2389                        
  2390 00:11AE: 9B 11 80 05                  HEADER  5,"+LOOP",IMMEDIATE
       00:11B2: 2B 4C 4F 4F 
       00:11B6: 50 
  2391 00:11B7: 20 1D 12     PLUS_LOOP:      jsr     DO_COLON
  2392                        
  2393 00:11BA: C7 0C                        dw      EXIT
  2394                        
  2395                        ; ( ( -- )
  2396                        
  2397                        ;  [ HEX ] 29 WORD DROP ; IMMEDIATE
  2398                        
  2399 00:11BC: B1 11 80 01                  HEADER  1,"(",IMMEDIATE
       00:11C0: 28 
  2400 00:11C1: 20 1D 12                     jsr     DO_COLON
  2401 00:11C4: DF 12 29 00                  dw      DO_LITERAL,')'
  2402 00:11C8: B5 10                        dw      WORD
  Fri Mar 18 2016 23:20                                                                                                    Page 49


  2403 00:11CA: 4F 07                        dw      DROP
  2404 00:11CC: C7 0C                        dw      EXIT
  2405                        
  2406                        ; (+LOOP)
  2407                        
  2408 00:11CE: BF 11 00 07                  HEADER  7,"(+LOOP)",NORMAL
       00:11D2: 28 2B 4C 4F 
       00:11D6: 4F 50 29 
  2409                        DO_PLUS_LOOP:
  2410                        
  2411 00:11D9: BB C8 C8 7C                  CONTINUE
       00:11DD: 00 00 
  2412                        
  2413                        ; (BRANCH) ( -- )
  2414                        ;
  2415                        ; Cause the IP to be loaded with the word following the link to this word.
  2416                        
  2417 00:11DF: D1 11 00 08                  HEADER  8,"(BRANCH)",NORMAL
       00:11E3: 28 42 52 41 
       00:11E7: 4E 43 48 29 
  2418                        BRANCH:
  2419 00:11EB: B9 00 00                     lda     !0,y                    ; Load branch address into IP
  2420 00:11EE: A8                           tay
  2421 00:11EF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:11F3: 00 00 
  2422                        
  2423                        ; (?BRANCH) ( flag -- )
  2424                        ;
  2425                        ; If flag is false then cause the IP to be loaded with the word following the
  2426                        ; link to this word, otherwise skip over it.
  2427                        
  2428 00:11F5: E2 11 00 09                  HEADER  9,"(?BRANCH)",NORMAL
       00:11F9: 28 3F 42 52 
       00:11FD: 41 4E 43 48 
       00:1201: 29 
  2429                        QUERY_BRANCH:
  2430 00:1202: A6 01                        ldx     <1                      ; Pull the top of stack value
  2431 00:1204: 7B                           tdc
  2432 00:1205: 1A                           inc     a                       ; Drop top item
  2433 00:1206: 1A                           inc     a
  2434 00:1207: 5B                           tcd
  2435 00:1208: 8A                           txa
  2436 00:1209: F0 E0                        beq     BRANCH                  ; Branch if top was zero
  2437 00:120B: C8                           iny                             ; Otherwise skip address
  2438 00:120C: C8                           iny
  2439 00:120D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1211: 00 00 
  2440                        
  2441                        ; : ( -- )
  2442                        
  2443 00:1213: F8 11 00 01                  HEADER  1,":",NORMAL
       00:1217: 3A 
  2444 00:1218: 20 1D 12     COLON:          jsr     DO_COLON
  2445                        
  2446 00:121B: C7 0C                        dw      EXIT
  2447                        
  2448                        DO_COLON:
  2449 00:121D: FA                           plx                             ; Pull new word IP-1
  Fri Mar 18 2016 23:20                                                                                                    Page 50


  2450 00:121E: 5A                           phy                             ; Save the old IP
  2451 00:121F: E8                           inx                             ; Work out new IP
  2452 00:1220: 9B                           txy
  2453 00:1221: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1225: 00 00 
  2454                        
  2455                        ; AGAIN
  2456                        
  2457 00:1227: 16 12 80 05                  HEADER  5,"AGAIN",IMMEDIATE
       00:122B: 41 47 41 49 
       00:122F: 4E 
  2458 00:1230: 20 1D 12     AGAIN:          jsr     DO_COLON
  2459                        
  2460 00:1233: C7 0C                        dw      EXIT
  2461                        
  2462                        ; BEGIN
  2463                        
  2464 00:1235: 2A 12 80 05                  HEADER  5,"BEGIN",IMMEDIATE
       00:1239: 42 45 47 49 
       00:123D: 4E 
  2465 00:123E: 20 1D 12     BEGIN:          jsr     DO_COLON
  2466                        
  2467 00:1241: C7 0C                        dw      EXIT
  2468                        
  2469                        ; CONSTANT ( x <spaces>name -- )
  2470                        ;
  2471                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2472                        ; definition for name with the execution semantics defined below.
  2473                        
  2474 00:1243: 38 12 00 08                  HEADER  8,"CONSTANT",NORMAL
       00:1247: 43 4F 4E 53 
       00:124B: 54 41 4E 54 
  2475 00:124F: 20 1D 12     CONSTANT:       jsr     DO_COLON
  2476 00:1252: 96 0C                        dw      CREATE
  2477 00:1254: DF 12 6C 12                  dw      DO_LITERAL,DO_CONSTANT
  2478 00:1258: 7F 0C                        dw      BUILD
  2479 00:125A: 9B 05                        dw      COMMA
  2480 00:125C: C7 0C                        dw      EXIT
  2481                        
  2482                        ; (CONSTANT) ( -- x )
  2483                        
  2484 00:125E: 46 12 00 0A                  HEADER  10,"(CONSTANT)",NORMAL
       00:1262: 28 43 4F 4E 
       00:1266: 53 54 41 4E 
       00:126A: 54 29 
  2485                        DO_CONSTANT:
  2486 00:126C: FA                           plx
  2487 00:126D: 7B                           tdc
  2488 00:126E: 3A                           dec     a
  2489 00:126F: 3A                           dec     a
  2490 00:1270: 5B                           tcd
  2491 00:1271: BD 01 00                     lda     !1,x
  2492 00:1274: 85 01                        sta     <1
  2493 00:1276: BB C8 C8 7C                  CONTINUE                        ; Done
       00:127A: 00 00 
  2494                        
  2495                        ; DO ( -- )
  2496                        
  Fri Mar 18 2016 23:20                                                                                                    Page 51


  2497 00:127C: 61 12 80 02                  HEADER  2,"DO",IMMEDIATE
       00:1280: 44 4F 
  2498 00:1282: 20 1D 12     DO:             jsr     DO_COLON
  2499                        
  2500 00:1285: C7 0C                        dw      EXIT
  2501                        
  2502                        ; (DO) ( -- )
  2503                        
  2504 00:1287: 7F 12 00 04                  HEADER  4,"(DO)",NORMAL
       00:128B: 28 44 4F 29 
  2505 00:128F: 00                           db
  2506                        DO_DO:
  2507 00:1290: A5 03                        lda     <3
  2508 00:1292: 48                           pha
  2509 00:1293: A5 01                        lda     <1
  2510 00:1295: 48                           pha
  2511 00:1296: 7B                           tdc
  2512 00:1297: 1A                           inc     a
  2513 00:1298: 1A                           inc     a
  2514 00:1299: 1A                           inc     a
  2515 00:129A: 1A                           inc     a
  2516 00:129B: 5B                           tcd
  2517 00:129C: BB C8 C8 7C                  CONTINUE
       00:12A0: 00 00 
  2518                        
  2519                        ; ELSE
  2520                        
  2521 00:12A2: 8A 12 80 04                  HEADER  4,"ELSE",IMMEDIATE
       00:12A6: 45 4C 53 45 
  2522 00:12AA: 20 1D 12     ELSE:           jsr     DO_COLON
  2523                        
  2524 00:12AD: C7 0C                        dw      EXIT
  2525                        
  2526                        ; IF
  2527                        
  2528 00:12AF: A5 12 80 02                  HEADER  2,"IF",IMMEDIATE
       00:12B3: 49 46 
  2529 00:12B5: 20 1D 12     IF:             jsr     DO_COLON
  2530                        
  2531 00:12B8: C7 0C                        dw      EXIT
  2532                        
  2533                        ; LITERAL ( x -- )
  2534                        ;
  2535                        ; Append the run-time semantics given below to the current definition.
  2536                        
  2537 00:12BA: B2 12 80 07                  HEADER  7,"LITERAL",IMMEDIATE
       00:12BE: 4C 49 54 45 
       00:12C2: 52 41 4C 
  2538 00:12C5: 20 1D 12     LITERAL:        jsr     DO_COLON
  2539 00:12C8: DF 12 DF 12                  dw      DO_LITERAL,DO_LITERAL
  2540 00:12CC: 9B 05                        dw      COMMA
  2541 00:12CE: 9B 05                        dw      COMMA
  2542 00:12D0: C7 0C                        dw      EXIT
  2543                        
  2544                        ; (LITERAL) ( -- x )
  2545                        ;
  2546                        ; Place x on the stack.
  2547                        
  Fri Mar 18 2016 23:20                                                                                                    Page 52


  2548 00:12D2: BD 12 00 09                  HEADER  9,"(LITERAL)",NORMAL
       00:12D6: 28 4C 49 54 
       00:12DA: 45 52 41 4C 
       00:12DE: 29 
  2549                        DO_LITERAL:
  2550 00:12DF: 7B                           tdc
  2551 00:12E0: 3A                           dec     a
  2552 00:12E1: 3A                           dec     a
  2553 00:12E2: 5B                           tcd
  2554 00:12E3: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  2555 00:12E6: C8                           iny
  2556 00:12E7: C8                           iny
  2557 00:12E8: 85 01                        sta     <1
  2558 00:12EA: BB C8 C8 7C                  CONTINUE                        ; Done
       00:12EE: 00 00 
  2559                        
  2560                        ; LOOP
  2561                        
  2562 00:12F0: D5 12 80 04                  HEADER  4,"LOOP",IMMEDIATE
       00:12F4: 4C 4F 4F 50 
  2563 00:12F8: 20 1D 12     LOOP:           jsr     DO_COLON
  2564                        
  2565 00:12FB: C7 0C                        dw      EXIT
  2566                        
  2567                        ; (LOOP)
  2568                        
  2569 00:12FD: F3 12 00 06                  HEADER  6,"(LOOP)",NORMAL
       00:1301: 28 4C 4F 4F 
       00:1305: 50 29 
  2570                        DO_LOOP
  2571 00:1307: A3 01                        lda     1,s                     ; Add one to loop counter
  2572 00:1309: 1A                           inc     a
  2573 00:130A: 83 01                        sta     1,s
  2574 00:130C: C3 03                        cmp     3,s                     ; Reached limit?
  2575 00:130E: B0 0A                        bcs     DO_LOOP_END             ; Yes
  2576 00:1310: B9 00 00                     lda     !0,y                    ; No, branch back to start
  2577 00:1313: A8                           tay
  2578 00:1314: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1318: 00 00 
  2579                        
  2580 00:131A: C8           DO_LOOP_END:    iny                             ; Skip over address
  2581 00:131B: C8                           iny
  2582 00:131C: 68                           pla                             ; Drop loop variables
  2583 00:131D: 68                           pla
  2584 00:131E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1322: 00 00 
  2585                        
  2586                        ; RECURSE
  2587                        
  2588 00:1324: 00 13 80 07                  HEADER  7,"RECURSE",IMMEDIATE
       00:1328: 52 45 43 55 
       00:132C: 52 53 45 
  2589 00:132F: 20 1D 12                     jsr     DO_COLON
  2590 00:1332: 9B 04                        dw      LATEST
  2591 00:1334: DB 05                        dw      FETCH
  2592 00:1336: 87 0F                        dw      NFA_TO_CFA
  2593 00:1338: 9B 05                        dw      COMMA
  2594 00:133A: C7 0C                        dw      EXIT
  Fri Mar 18 2016 23:20                                                                                                    Page 53


  2595                        
  2596                        ; S"
  2597                        
  2598 00:133C: 27 13 80                     LINK    IMMEDIATE
  2599 00:133F: 02 53 22                     db      2,"S",'"'
  2600 00:1342: 20 1D 12     S_QUOTE:        jsr     DO_COLON
  2601 00:1345: C7 0C                        dw      EXIT
  2602                        
  2603                        ; (S") ( -- c-addr u )
  2604                        
  2605                        DO_S_QUOTE:
  2606 00:1347: 7B                           tdc
  2607 00:1348: 3A                           dec     a                       ; Reserve space for values
  2608 00:1349: 3A                           dec     a
  2609 00:134A: 3A                           dec     a
  2610 00:134B: 3A                           dec     a
  2611 00:134C: 5B                           tcd
  2612 00:134D: E2 20                        short_a
  2613 00:134F: B9 00 00                     lda     !0,y                    ; Fetch the length
  2614 00:1352: 85 01                        sta     <1
  2615 00:1354: 64 02                        stz     <2
  2616 00:1356: C2 20                        long_a
  2617 00:1358: C8                           iny
  2618 00:1359: 98                           tya                             ; Save the text address
  2619 00:135A: 85 03                        sta     <3
  2620 00:135C: 18                           clc                             ; And update IP
  2621 00:135D: 65 01                        adc     <1
  2622 00:135F: A8                           tay
  2623 00:1360: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1364: 00 00 
  2624                        
  2625                        ; USER
  2626                        
  2627 00:1366: 3F 13 00 04                  HEADER  4,"USER",NORMAL
       00:136A: 55 53 45 52 
  2628 00:136E: 20 1D 12     USER:           jsr     DO_COLON
  2629 00:1371: 96 0C                        dw      CREATE
  2630 00:1373: DF 12 87 13                  dw      DO_LITERAL,DO_USER
  2631 00:1377: 7F 0C                        dw      BUILD
  2632 00:1379: 9B 05                        dw      COMMA
  2633 00:137B: C7 0C                        dw      EXIT
  2634                        
  2635 00:137D: 69 13 00 06                  HEADER  6,"(USER)",NORMAL
       00:1381: 28 55 53 45 
       00:1385: 52 29 
  2636                        DO_USER:
  2637 00:1387: 7B                           tdc
  2638 00:1388: 3A                           dec     a                       ; Push on data stack
  2639 00:1389: 3A                           dec     a
  2640 00:138A: 5B                           tcd
  2641 00:138B: FA                           plx
  2642 00:138C: 18                           clc
  2643 00:138D: BD 01 00                     lda     !1,x
  2644 00:1390: 69 00 00                     adc     #USER_AREA
  2645 00:1393: 85 01                        sta     <1
  2646 00:1395: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1399: 00 00 
  2647                        
  Fri Mar 18 2016 23:20                                                                                                    Page 54


  2648                        ; VARIABLE ( <spaces>name -- )
  2649                        ;
  2650                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2651                        ; definition for name with the execution semantics defined below. Reserve one
  2652                        ; cell of data space at an aligned address.
  2653                        
  2654 00:139B: 80 13 00                     LINK    NORMAL
  2655 00:139E: 08 56 41 52                  db      8,"VARIABLE"
       00:13A2: 49 41 42 4C 
       00:13A6: 45 
  2656 00:13A7: 20 1D 12     VARIABLE:       jsr     DO_COLON
  2657 00:13AA: 96 0C                        dw      CREATE
  2658 00:13AC: DF 12 BC 13                  dw      DO_LITERAL,DO_VARIABLE
  2659 00:13B0: 7F 0C                        dw      BUILD
  2660 00:13B2: DF 12 01 00                  dw      DO_LITERAL,1
  2661 00:13B6: 8B 06                        dw      CELLS
  2662 00:13B8: EE 05                        dw      ALLOT
  2663 00:13BA: C7 0C                        dw      EXIT
  2664                        
  2665                        DO_VARIABLE:
  2666 00:13BC: 7B                           tdc
  2667 00:13BD: 3A                           dec     a
  2668 00:13BE: 3A                           dec     a
  2669 00:13BF: 5B                           tcd
  2670 00:13C0: 68                           pla
  2671 00:13C1: 1A                           inc     a
  2672 00:13C2: 85 01                        sta     <1
  2673 00:13C4: BB C8 C8 7C                  CONTINUE
       00:13C8: 00 00 
  2674                        
  2675                        ; WORDS
  2676                        ;
  2677                        ;   LATEST @ BEGIN
  2678                        ;       DUP COUNT TYPE SPACE
  2679                        ;       NFA>LFA @
  2680                        ;   DUP 0= UNTIL
  2681                        ;   DROP ;
  2682                        
  2683 00:13CA: 9E 13 00 05                  HEADER  5,"WORDS",NORMAL
       00:13CE: 57 4F 52 44 
       00:13D2: 53 
  2684 00:13D3: 20 1D 12                     jsr     DO_COLON
  2685 00:13D6: 9B 04                        dw      LATEST
  2686 00:13D8: DB 05                        dw      FETCH
  2687 00:13DA: 60 07        WORDS_1:        dw      DUP
  2688 00:13DC: A1 11                        dw      COUNT
  2689 00:13DE: 97 14                        dw      TYPE
  2690 00:13E0: 65 14                        dw      SPACE
  2691 00:13E2: 9B 0F                        dw      NFA_TO_LFA
  2692 00:13E4: DB 05                        dw      FETCH
  2693 00:13E6: 60 07                        dw      DUP
  2694 00:13E8: F6 0A                        dw      ZERO_EQUAL
  2695 00:13EA: 02 12 DA 13                  dw      QUERY_BRANCH,WORDS_1
  2696 00:13EE: 4F 07                        dw      DROP
  2697 00:13F0: C7 0C                        dw      EXIT
  2698                        
  2699                        ; [
  2700                        ;
  Fri Mar 18 2016 23:20                                                                                                    Page 55


  2701                        ; In this implementation it is defined as
  2702                        ;
  2703                        ;   0 STATE !
  2704                        
  2705 00:13F2: CD 13 80 01                  HEADER  1,"[",IMMEDIATE
       00:13F6: 5B 
  2706 00:13F7: 20 1D 12                     jsr     DO_COLON
  2707 00:13FA: F0 04                        dw      ZERO
  2708 00:13FC: DA 04                        dw      STATE
  2709 00:13FE: 6D 05                        dw      STORE
  2710 00:1400: C7 0C                        dw      EXIT
  2711                        
  2712                        ; ]
  2713                        ;
  2714                        ; In this implementation it is defined as
  2715                        ;
  2716                        ;   -1 STATE !
  2717 00:1402: F5 13 00 01                  HEADER  1,"]",NORMAL
       00:1406: 5D 
  2718 00:1407: 20 1D 12                     jsr     DO_COLON
  2719 00:140A: DF 12 FF FF                  dw      DO_LITERAL,-1
  2720 00:140E: DA 04                        dw      STATE
  2721 00:1410: 6D 05                        dw      STORE
  2722 00:1412: C7 0C                        dw      EXIT
  2723                        
  2724                        ;==============================================================================
  2725                        ; I/O Operations
  2726                        ;------------------------------------------------------------------------------
  2727                        
  2728                        ; CR ( -- )
  2729                        ;
  2730                        ; Cause subsequent output to appear at the beginning of the next line.
  2731                        ;
  2732                        ; In this implementation it is defined as
  2733                        ;
  2734                        ;   13 EMIT 10 EMIT
  2735                        
  2736 00:1414: 05 14 00 02                  HEADER  2,"CR",NORMAL
       00:1418: 43 52 
  2737 00:141A: 20 1D 12     CR:             jsr     DO_COLON
  2738 00:141D: DF 12 0D 00                  dw      DO_LITERAL,13
  2739 00:1421: 33 14                        dw      EMIT
  2740 00:1423: DF 12 0A 00                  dw      DO_LITERAL,10
  2741 00:1427: 33 14                        dw      EMIT
  2742 00:1429: C7 0C                        dw      EXIT
  2743                        
  2744                        ; EMIT ( x -- )
  2745                        ;
  2746                        ; If x is a graphic character in the implementation-defined character set,
  2747                        ; display x. The effect of EMIT for all other values of x is implementation
  2748                        ; -defined.
  2749                        
  2750 00:142B: 17 14 00 04                  HEADER  4,"EMIT",NORMAL
       00:142F: 45 4D 49 54 
  2751                                        extern  UartTx
  2752                        EMIT:
  2753 00:1433: A5 01                        lda     <1                      ; Fetch character from stack
  2754 00:1435: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  Fri Mar 18 2016 23:20                                                                                                    Page 56


  2755 00:1438: 7B                           tdc
  2756 00:1439: 1A                           inc     a                       ; Drop the character
  2757 00:143A: 1A                           inc     a
  2758 00:143B: 5B                           tcd
  2759 00:143C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1440: 00 00 
  2760                        
  2761                        ; KEY ( -- char )
  2762                        ;
  2763                        ; Receive one character char, a member of the implementation-defined character
  2764                        ; set. Keyboard events that do not correspond to such characters are discarded
  2765                        ; until a valid character is received, and those events are subsequently
  2766                        ; unavailable.
  2767                        ;
  2768                        ; All standard characters can be received. Characters received by KEY are not
  2769                        ; displayed.
  2770                        
  2771 00:1442: 2E 14 00 03                  HEADER  3,"KEY",NORMAL
       00:1446: 4B 45 59 
  2772                                        extern  UartRx
  2773                        KEY:
  2774 00:1449: 20 xx xx                     jsr     UartRx                  ; Receive a character
  2775 00:144C: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  2776 00:144F: AA                           tax
  2777 00:1450: 7B                           tdc
  2778 00:1451: 3A                           dec     a                       ; And push to stack
  2779 00:1452: 3A                           dec     a
  2780 00:1453: 5B                           tcd
  2781 00:1454: 86 01                        stx     <1
  2782 00:1456: BB C8 C8 7C                  CONTINUE                        ; Done
       00:145A: 00 00 
  2783                        
  2784                        ; SPACE ( -- )
  2785                        ;
  2786                        ; Display one space.
  2787                        ;
  2788                        ; In this implementation it is defined as
  2789                        ;
  2790                        ;   BL EMIT
  2791                        
  2792 00:145C: 45 14 00 05                  HEADER  5,"SPACE",NORMAL
       00:1460: 53 50 41 43 
       00:1464: 45 
  2793 00:1465: 20 1D 12     SPACE:          jsr     DO_COLON
  2794 00:1468: 02 05                        dw      BL
  2795 00:146A: 33 14                        dw      EMIT
  2796 00:146C: C7 0C                        dw      EXIT
  2797                        
  2798                        ; SPACES ( n -- )
  2799                        ;
  2800                        ; If n is greater than zero, display n spaces.
  2801                        ;
  2802                        ; In this implementation it is defined as
  2803                        ;
  2804                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  2805                        
  2806 00:146E: 5F 14 00 06                  HEADER  6,"SPACES",NORMAL
       00:1472: 53 50 41 43 
  Fri Mar 18 2016 23:20                                                                                                    Page 57


       00:1476: 45 53 
  2807 00:1478: 20 1D 12     SPACES:         jsr     DO_COLON
  2808 00:147B: 60 07        SPACES_1:       dw      DUP
  2809 00:147D: 0A 0B                        dw      ZERO_GREATER
  2810 00:147F: 02 12 8B 14                  dw      QUERY_BRANCH,SPACES_2
  2811 00:1483: 65 14                        dw      SPACE
  2812 00:1485: 00 09                        dw      ONE_MINUS
  2813 00:1487: EB 11 7B 14                  dw      BRANCH,SPACES_1
  2814 00:148B: 4F 07        SPACES_2:       dw      DROP
  2815 00:148D: C7 0C                        dw      EXIT
  2816                        
  2817                        ; TYPE ( c-addr u -- )
  2818                        ;
  2819                        ; If u is greater than zero, display the character string specified by c-addr
  2820                        ; and u.
  2821                        ;
  2822                        ; In this implementation it is defined as
  2823                        ;
  2824                        ;   ?DUP IF
  2825                        ;     OVER + SWAP DO I C@ EMIT LOOP
  2826                        ;   ELSE DROP THEN
  2827                        
  2828 00:148F: 71 14 00 04                  HEADER  4,"TYPE",NORMAL
       00:1493: 54 59 50 45 
  2829 00:1497: 20 1D 12     TYPE:           jsr     DO_COLON
  2830 00:149A: 3D 07                        dw      QUERY_DUP
  2831 00:149C: 02 12 B6 14                  dw      QUERY_BRANCH,TYPE_2
  2832 00:14A0: 83 07                        dw      OVER
  2833 00:14A2: A9 08                        dw      PLUS
  2834 00:14A4: 99 07                        dw      SWAP
  2835 00:14A6: 90 12                        dw      DO_DO
  2836 00:14A8: 36 08        TYPE_1:         dw      I
  2837 00:14AA: 2E 06                        dw      C_FETCH
  2838 00:14AC: 33 14                        dw      EMIT
  2839 00:14AE: 07 13 A8 14                  dw      DO_LOOP,TYPE_1
  2840 00:14B2: EB 11 B8 14                  dw      BRANCH,TYPE_3
  2841 00:14B6: 4F 07        TYPE_2          dw      DROP
  2842 00:14B8: C7 0C        TYPE_3          dw      EXIT
  2843                        
  2844                        ;================================================================================
  2845                        ;--------------------------------------------------------------------------------
  2846                        
  2847                        ; #
  2848                        ; #>
  2849                        ; #S
  2850                        ; SIGN
  2851                        
  2852                        ;================================================================================
  2853                        ; Debugging Words
  2854                        ;--------------------------------------------------------------------------------
  2855                        
  2856                        ; .NYBBLE
  2857                        
  2858 00:14BA: 92 14 00 07                  HEADER  7,".NYBBLE",NORMAL
       00:14BE: 2E 4E 59 42 
       00:14C2: 42 4C 45 
  2859                        DOT_NYBBLE:
  2860 00:14C5: A5 01                        lda     <1
  Fri Mar 18 2016 23:20                                                                                                    Page 58


  2861 00:14C7: 29 0F 00                     and     #$000f
  2862 00:14CA: 09 30 00                     ora     #$0030
  2863 00:14CD: C9 3A 00                     cmp     #$003a
  2864 00:14D0: 90 03                        bcc     $+5
  2865 00:14D2: 69 06 00                     adc     #$0006
  2866 00:14D5: 20 xx xx                     jsr     UartTx
  2867 00:14D8: 4C 4F 07                     jmp     DROP
  2868                        
  2869                        ; .BYTE
  2870                        
  2871 00:14DB: BD 14 00 05                  HEADER  5,".BYTE",NORMAL
       00:14DF: 2E 42 59 54 
       00:14E3: 45 
  2872 00:14E4: 20 1D 12     DOT_BYTE:       jsr     DO_COLON
  2873 00:14E7: 60 07                        dw      DUP
  2874 00:14E9: DF 12 04 00                  dw      DO_LITERAL,4
  2875 00:14ED: 21 0C                        dw      RSHIFT
  2876 00:14EF: C5 14                        dw      DOT_NYBBLE
  2877 00:14F1: C5 14                        dw      DOT_NYBBLE
  2878 00:14F3: 65 14                        dw      SPACE
  2879 00:14F5: C7 0C                        dw      EXIT
  2880                        
  2881                        ; .WORD
  2882                        
  2883 00:14F7: DE 14 00 05                  HEADER  5,".WORD",NORMAL
       00:14FB: 2E 57 4F 52 
       00:14FF: 44 
  2884 00:1500: 20 1D 12     DOT_WORD:       jsr     DO_COLON
  2885 00:1503: 60 07                        dw      DUP
  2886 00:1505: DF 12 0C 00                  dw      DO_LITERAL,12
  2887 00:1509: 21 0C                        dw      RSHIFT
  2888 00:150B: C5 14                        dw      DOT_NYBBLE
  2889 00:150D: 60 07                        dw      DUP
  2890 00:150F: DF 12 08 00                  dw      DO_LITERAL,8
  2891 00:1513: 21 0C                        dw      RSHIFT
  2892 00:1515: C5 14                        dw      DOT_NYBBLE
  2893 00:1517: 60 07                        dw      DUP
  2894 00:1519: DF 12 04 00                  dw      DO_LITERAL,4
  2895 00:151D: 21 0C                        dw      RSHIFT
  2896 00:151F: C5 14                        dw      DOT_NYBBLE
  2897 00:1521: C5 14                        dw      DOT_NYBBLE
  2898 00:1523: 65 14                        dw      SPACE
  2899 00:1525: C7 0C                        dw      EXIT
  2900                        
  2901                        ; .DP
  2902                        
  2903 00:1527: FA 14 00 03                  HEADER  3,".DP",NORMAL
       00:152B: 2E 44 50 
  2904 00:152E: 20 1D 12                     jsr     DO_COLON
  2905 00:1531: 4E 15                        dw      AT_DP
  2906 00:1533: 00 15                        dw      DOT_WORD
  2907 00:1535: C7 0C                        dw      EXIT
  2908                        
  2909 00:1537: 2A 15 00 03                  HEADER  3,".RP",NORMAL
       00:153B: 2E 52 50 
  2910 00:153E: 20 1D 12                     jsr     DO_COLON
  2911 00:1541: 63 15                        dw      AT_RP
  2912 00:1543: 00 15                        dw      DOT_WORD
  Fri Mar 18 2016 23:20                                                                                                    Page 59


  2913 00:1545: C7 0C                        dw      EXIT
  2914                        
  2915 00:1547: 3A 15 00 03                  HEADER  3,"@DP",NORMAL
       00:154B: 40 44 50 
  2916                        AT_DP:
  2917 00:154E: 0B                           phd
  2918 00:154F: 7B                           tdc
  2919 00:1550: 3A                           dec     a
  2920 00:1551: 3A                           dec     a
  2921 00:1552: 5B                           tcd
  2922 00:1553: 68                           pla
  2923 00:1554: 85 01                        sta     <1
  2924 00:1556: BB C8 C8 7C                  CONTINUE
       00:155A: 00 00 
  2925                        
  2926 00:155C: 4A 15 00 03                  HEADER  3,"@RP",NORMAL
       00:1560: 40 52 50 
  2927                        AT_RP:
  2928 00:1563: 7B                           tdc
  2929 00:1564: 3A                           dec     a
  2930 00:1565: 3A                           dec     a
  2931 00:1566: 5B                           tcd
  2932 00:1567: BA                           tsx
  2933 00:1568: 86 01                        stx     <1
  2934 00:156A: BB C8 C8 7C                  CONTINUE
       00:156E: 00 00 
  2935                        
  2936                                        include "device.asm"
     1                        ;===============================================================================
     2                        ; Device Specific Words
     3                        ;-------------------------------------------------------------------------------
     4                        
     5 00:1570: 20 1D 12     TITLE:		jsr	DO_COLON	
     6 00:1573: 47 13                        dw      DO_S_QUOTE
     7 00:1575: 1C 57 36 35                  db      28,"W65C816SXB ANS-Forth [16.03]"
       00:1579: 43 38 31 36 
       00:157D: 53 58 42 20 
       00:1581: 41 4E 53 2D 
       00:1585: 46 6F 72 74 
       00:1589: 68 20 5B 31 
       00:158D: 36 2E 30 33 
       00:1591: 5D 
     8 00:1592: C7 0C        		dw	EXIT
     9                        		
    10                        ;-------------------------------------------------------------------------------
    11                        		
    12 00:1594: 5F 15 00 08  		HEADER	8,"ACIA$RXD",NORMAL
       00:1598: 41 43 49 41 
       00:159C: 24 52 58 44 
    13 00:15A0: 20 6C 12     		jsr	DO_CONSTANT
    14 00:15A3: 80 7F        		dw	$7f80
    15                        		
    16 00:15A5: 97 15 00 08  		HEADER	8,"ACIA$TXD",NORMAL
       00:15A9: 41 43 49 41 
       00:15AD: 24 54 58 44 
    17 00:15B1: 20 6C 12     		jsr	DO_CONSTANT
    18 00:15B4: 80 7F        		dw	$7f80
    19                        		
  Fri Mar 18 2016 23:20                                                                                                    Page 60


    20 00:15B6: A8 15 00 07  		HEADER	7,"ACIA$SR",NORMAL
       00:15BA: 41 43 49 41 
       00:15BE: 24 53 52 
    21 00:15C1: 20 6C 12     		jsr	DO_CONSTANT
    22 00:15C4: 81 7F        		dw     	$7f81
    23                        		
    24 00:15C6: B9 15 00 08  		HEADER	8,"ACIA$CMD",NORMAL
       00:15CA: 41 43 49 41 
       00:15CE: 24 43 4D 44 
    25 00:15D2: 20 6C 12     		jsr	DO_CONSTANT
    26 00:15D5: 82 7F        		dw     	$7f82
    27                        		
    28 00:15D7: C9 15 00 08  		HEADER	8,"ACIA$CTL",NORMAL
       00:15DB: 41 43 49 41 
       00:15DF: 24 43 54 4C 
    29 00:15E3: 20 6C 12     		jsr	DO_CONSTANT
    30 00:15E6: 83 7F        		dw	$7f83
    31                        
    32                        ;-------------------------------------------------------------------------------
    33                        
    34 00:15E8: DA 15 00 07  		HEADER	7,"PIA$PIA",NORMAL
       00:15EC: 50 49 41 24 
       00:15F0: 50 49 41 
    35 00:15F3: 20 6C 12     		jsr	DO_CONSTANT
    36 00:15F6: A0 7F        		dw      $7fa0
    37                        		
    38 00:15F8: EB 15 00 08  		HEADER	8,"PIA$DDRA",NORMAL
       00:15FC: 50 49 41 24 
       00:1600: 44 44 52 41 
    39 00:1604: 20 6C 12     		jsr	DO_CONSTANT
    40 00:1607: A0 7F        		dw	$7fa0
    41                        		
    42 00:1609: FB 15 00 07  		HEADER	7,"PIA$CRA",NORMAL
       00:160D: 50 49 41 24 
       00:1611: 43 52 41 
    43 00:1614: 20 6C 12     		jsr	DO_CONSTANT
    44 00:1617: A1 7F        		dw      $7fa1
    45                        		
    46 00:1619: 0C 16 00 07  		HEADER	7,"PIA$PIB",NORMAL
       00:161D: 50 49 41 24 
       00:1621: 50 49 42 
    47 00:1624: 20 6C 12     		jsr	DO_CONSTANT
    48 00:1627: A2 7F        		dw      $7fa2
    49                        		
    50 00:1629: 1C 16 00 08  		HEADER	8,"PIA$DDRB",NORMAL
       00:162D: 50 49 41 24 
       00:1631: 44 44 52 42 
    51 00:1635: 20 6C 12     		jsr	DO_CONSTANT
    52 00:1638: A2 7F        		dw      $7fa2
    53                        		
    54 00:163A: 2C 16 00 07  		HEADER	7,"PIA$CRB",NORMAL
       00:163E: 50 49 41 24 
       00:1642: 43 52 42 
    55 00:1645: 20 6C 12     		jsr	DO_CONSTANT
    56 00:1648: A3 7F        		dw      $7fa3
    57                        
    58                        ;-------------------------------------------------------------------------------
    59                        
  Fri Mar 18 2016 23:20                                                                                                    Page 61


    60 00:164A: 3D 16 00 08  		HEADER	8,"VIA1$ORB",NORMAL
       00:164E: 56 49 41 31 
       00:1652: 24 4F 52 42 
    61 00:1656: 20 6C 12     		jsr	DO_CONSTANT
    62 00:1659: C0 7F        		dw      $7fc0
    63                        		
    64 00:165B: C0 7F        VIA1_IRB        dw      $7fc0
    65 00:165D: C1 7F        VIA1_ORA        dw      $7fc1
    66 00:165F: C1 7F        VIA1_IRA        dw      $7fc1
    67 00:1661: C2 7F        VIA1_DDRB       dw      $7fc2
    68 00:1663: C3 7F        VIA1_DDRA       dw      $7fc3
    69 00:1665: C4 7F        VIA1_T1CL       dw      $7fc4
    70 00:1667: C5 7F        VIA1_T1CH       dw      $7fc5
    71 00:1669: C6 7F        VIA1_T1LL       dw      $7fc6
    72 00:166B: C7 7F        VIA1_T1LH       dw      $7fc7
    73 00:166D: C8 7F        VIA1_T2CL       dw      $7fc8
    74 00:166F: C9 7F        VIA1_T2CH       dw      $7fc9
    75 00:1671: CA 7F        VIA1_SR         dw      $7fca
    76 00:1673: CB 7F        VIA1_ACR        dw      $7fcb
    77 00:1675: CC 7F        VIA1_PCR        dw      $7fcc
    78 00:1677: CD 7F        VIA1_IFR        dw      $7fcd
    79 00:1679: CE 7F        VIA1_IER        dw      $7fce
    80 00:167B: CF 7F        VIA1_ORAN       dw      $7fcf
    81 00:167D: CF 7F        VIA1_IRAN       dw      $7fcf
    82                        
    83                        ;-------------------------------------------------------------------------------
    84                        
    85 00:167F: E0 7F        VIA2_ORB        dw      $7fe0
    86 00:1681: E0 7F        VIA2_IRB        dw      $7fe0
    87 00:1683: E1 7F        VIA2_ORA        dw      $7fe1
    88 00:1685: E1 7F        VIA2_IRA        dw      $7fe1
    89 00:1687: E2 7F        VIA2_DDRB       dw      $7fe2
    90 00:1689: E3 7F        VIA2_DDRA       dw      $7fe3
    91 00:168B: E4 7F        VIA2_T1CL       dw      $7fe4
    92 00:168D: E5 7F        VIA2_T1CH       dw      $7fe5
    93 00:168F: E6 7F        VIA2_T1LL       dw      $7fe6
    94 00:1691: E7 7F        VIA2_T1LH       dw      $7fe7
    95 00:1693: E8 7F        VIA2_T2CL       dw      $7fe8
    96 00:1695: E9 7F        VIA2_T2CH       dw      $7fe9
    97 00:1697: EA 7F        VIA2_SR         dw      $7fea
    98 00:1699: EB 7F        VIA2_ACR        dw      $7feb
    99 00:169B: EC 7F        VIA2_PCR        dw      $7fec
   100 00:169D: ED 7F        VIA2_IFR        dw      $7fed
   101 00:169F: EE 7F        VIA2_IER        dw      $7fee
   102 00:16A1: EF 7F        VIA2_ORAN       dw      $7fef
   103 00:16A3: EF 7F        VIA2_IRAN       dw      $7fef
  2937                        
  2938                                        TRAILER
  2939                        NEXT_WORD:
  2940                        
  2941                                        end


      Lines assembled: 4644
      Errors: 0
