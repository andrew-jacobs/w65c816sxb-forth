  Mon Apr 18 2016 23:59                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;===============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;-------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The Forth data stack is DP
    27                        ;
    28                        ; The Y register holds the forth instruction pointer and the direct page
    29                        ; register is used to access the word address pointer and user variables.
    30                        ;
    31                        ; Some of the high-level definitions are based on Bradford J. Rodriguez's
    32                        ; CamelForth implementations.
    33                        ;
    34                        ;-------------------------------------------------------------------------------
    35                        
    36                                        pw      132
    37                                        inclist on
    38                                        maclist off
    39                        
    40                                        chip    65816
    41                                        longi   off
    42                                        longa   off
    43                        
    44                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
     7                        ;
     8                        ; Western Design Center W65C816 device definitions                                          
  Mon Apr 18 2016 23:59                                                                                                    Page 2


     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;===============================================================================
    25                        ; Revision History:
    26                        ;
    27                        ; 2015-12-18 AJ Initial version
    28                        ;-------------------------------------------------------------------------------
    29                        ; $Id$
    30                        ;-------------------------------------------------------------------------------
    31                        
    32                        ;==============================================================================
    33                        ; Status Register Bits
    34                        ;------------------------------------------------------------------------------
    35                        
    36             00000080   N_FLAG          equ     1<<7
    37             00000040   V_FLAG          equ     1<<6
    38             00000020   M_FLAG          equ     1<<5
    39             00000010   X_FLAG          equ     1<<4
    40             00000010   B_FLAG          equ     1<<4
    41             00000008   D_FLAG          equ     1<<3
    42             00000004   I_FLAG          equ     1<<2
    43             00000002   Z_FLAG          equ     1<<1
    44             00000001   C_FLAG          equ     1<<0
    45                        
    46                        ;==============================================================================
    47                        ; Macros
    48                        ;------------------------------------------------------------------------------
    49                        
    50                        ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
    51                        ; is fixed at $0100-$01ff. 
    52                        
    53                        emulate         macro
    54                                        sec
    55                                        xce
    56                                        endm
    57                        
    58                        ; Puts the processor in native mode. The size of the memory and index register
    59                        ; operations is not controlled by the M & X bits in the status register.
    60                        
    61                        native          macro
    62                                        clc
    63                                        xce
    64                                        endm
    65                        
    66                        ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
  Mon Apr 18 2016 23:59                                                                                                    Page 3


    67                         
    68                        long_a          macro
    69                                        rep     #M_FLAG
    70                                        longa   on
    71                                        endm
    72                        
    73                        ; Resets the X bit making the index registers 16-bits wide
    74                        
    75                        long_i          macro
    76                                        rep     #X_FLAG
    77                                        longi   on
    78                                        endm
    79                        
    80                        ; Resets the M and X bits making the accumulator, memory accesses and index
    81                        ; registers 16-bits wide.
    82                                        
    83                        long_ai         macro
    84                                        rep     #M_FLAG|X_FLAG
    85                                        longa   on
    86                                        longi   on
    87                                        endm
    88                        
    89                        ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
    90                        
    91                        short_a         macro
    92                                        sep     #M_FLAG
    93                                        longa   off
    94                                        endm
    95                        
    96                        ; Sets the X bit making the index registers 8-bits wide.
    97                        
    98                        short_i         macro
    99                                        sep     #X_FLAG
   100                                        longi   off
   101                                        endm
   102                                        
   103                        ; Sets the M & X bits making the accumulator, memory accesses and index
   104                        ; registers 8-bits wide.
   105                        
   106                        short_ai        macro
   107                                        sep     #M_FLAG|X_FLAG
   108                                        longa   off
   109                                        longi   off
   110                                        endm
    45                        
    46                        ;===============================================================================
    47                        ; Macros
    48                        ;-------------------------------------------------------------------------------
    49                        
    50                        ; The LINK macro deposits the link section of a word header automatically
    51                        ; linking the new word to the last.
    52                        
    53             00000000   WORDZ           set     0                       ; Word counter
    54             00000000   WORD0           equ     0                       ; Null address for first word
    55                        
    56                        LINK            macro   TYPE
    57                                        dw      WORD@<WORDZ>            ; Link
    58                                        db      TYPE                    ; Type
  Mon Apr 18 2016 23:59                                                                                                    Page 4


    59                        WORDZ           set     WORDZ+1
    60                        WORD@<WORDZ>:
    61                                        endm
    62                        
    63                        ; Deposits a word header containing the name which is linked back to the
    64                        ; previous word.
    65                        ;
    66                        ; The WDC assembler does not handle string parameters to macros very well,
    67                        ; stopping at the first comma or space in them, so some headers must be
    68                        ; manually constructed.
    69                        
    70             00000000   NORMAL          equ     $00
    71             00000080   IMMEDIATE       equ     $80
    72                        
    73                        HEADER          macro   LEN,NAME,TYPE
    74                                        LINK    TYPE
    75                                        db      LEN,NAME
    76                                        endm
    77                        
    78                        ; The CONTINUE macro is used at the end of a native word to invoke the next
    79                        ; word pointer.
    80                        
    81                        CONTINUE        macro
    82                                        tyx                             ; Copy IP to X
    83                                        iny
    84                                        iny
    85                                        jmp     (0,x)                   ; Then execute word
    86                                        endm
    87                        
    88                        TRAILER         macro
    89                        LAST_WORD       equ     WORD@<WORDZ>
    90                                        endm
    91                        
    92                        ;===============================================================================
    93                        ; Definitions
    94                        ;-------------------------------------------------------------------------------
    95                        
    96             00000014   USER_SIZE       equ     20
    97             00000080   DSTACK_SIZE     equ     128
    98             00000080   RSTACK_SIZE     equ     128
    99                        
   100             00000000   TO_IN_OFFSET    equ     0
   101             00000002   BASE_OFFSET     equ     2
   102             00000004   BLK_OFFSET      equ     4
   103             00000006   DP_OFFSET       equ     6
   104             00000008   LATEST_OFFSET   equ     8
   105             0000000A   SCR_OFFSET      equ     10
   106             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
   107             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
   108             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
   109             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
   110                        
   111             00000080   TIB_SIZE        equ     128
   112                        
   113                        ;===============================================================================
   114                        ; Data Areas
   115                        ;-------------------------------------------------------------------------------
   116                        
  Mon Apr 18 2016 23:59                                                                                                    Page 5


   117                                        page0
   118                                        org     $00
   119                        
   120 00:0000:              USER_AREA       ds      USER_SIZE               ; User Variables
   121                        
   122                        
   123             00000100   DSTACK_START    equ     $0100
   124             00000180   DSTACK_END      equ     DSTACK_START+DSTACK_SIZE
   125                        
   126             00000180   RSTACK_START    equ     $0180
   127             00000200   RSTACK_END      equ     RSTACK_START+RSTACK_SIZE
   128                        
   129                        
   130                                        data
   131                                        org     $0200
   132                        
   133 00:0200:              TIB_AREA        ds      TIB_SIZE                ; Terminal Input Buffer
   134                        
   135                        ;===============================================================================
   136                        ; Forth Entry Point
   137                        ;-------------------------------------------------------------------------------
   138                        
   139                        FORTH           section OFFSET $0400
   140                        
   141                                        public  Start
   142                        Start:
   143 00:0400: 18 FB                        native                          ; Go to native mode
   144 00:0402: C2 30                        long_ai                         ; And all 16-bit registers
   145 00:0404: A9 FF 01                     lda     #RSTACK_END-1           ; Initialise return stack
   146 00:0407: 1B                           tcs
   147 00:0408: A9 7F 01                     lda     #DSTACK_END-1           ; .. and data stack
   148 00:040B: 5B                           tcd
   149                        
   150 00:040C: A0 15 04                     ldy     #COLD                   ; Then perform COLD start
   151 00:040F: BB C8 C8 7C                  CONTINUE
       00:0413: 00 00 
   152                        
   153                        COLD:
   154 00:0415: 20 05                        dw      DECIMAL
   155 00:0417: C9 04                        dw      ZERO
   156 00:0419: 70 04                        dw      BLK
   157 00:041B: 46 05                        dw      STORE
   158 00:041D: F3 04                        dw      FALSE
   159 00:041F: B3 04                        dw      STATE
   160 00:0421: 46 05                        dw      STORE
   161 00:0423: 08 16                        dw      DO_LITERAL
   162 00:0425: CC 1C                        dw      NEXT_WORD
   163 00:0427: 80 04                        dw      DP
   164 00:0429: 46 05                        dw      STORE
   165 00:042B: 08 16                        dw      DO_LITERAL
   166 00:042D: BD 1C                        dw      LAST_WORD
   167 00:042F: 8F 04                        dw      LATEST
   168 00:0431: 46 05                        dw      STORE
   169 00:0433: B7 17                        dw      CR
   170 00:0435: B7 17                        dw      CR
   171 00:0437: 35 19                        dw      DO_TITLE
   172 00:0439: 34 18                        dw      TYPE
   173 00:043B: B7 17                        dw      CR
  Mon Apr 18 2016 23:59                                                                                                    Page 6


   174 00:043D: B7 17                        dw      CR
   175 00:043F: 4A 0E                        dw      ABORT
   176                        
   177                        ;===============================================================================
   178                        ; System/User Variables
   179                        ;-------------------------------------------------------------------------------
   180                        
   181                        ; #TIB ( -- a-addr )
   182                        ;
   183                        ; a-addr is the address of a cell containing the number of characters in the
   184                        ; terminal input buffer.
   185                        
   186 00:0441: 00 00 00 04                  HEADER  4,"#TIB",NORMAL
       00:0445: 23 54 49 42 
   187 00:0449: 20 4C 15     HASH_TIB:       jsr     DO_CONSTANT
   188 00:044C: 4E 04                        dw      $+2
   189 00:044E: 7E 00                        dw      TIB_SIZE-2
   190                        
   191                        ; >IN ( -- a-addr )
   192                        ;
   193                        ; a-addr is the address of a cell containing the offset in characters from the
   194                        ; start of the input buffer to the start of the parse area.
   195                        
   196 00:0450: 44 04 00 03                  HEADER  3,">IN",NORMAL
       00:0454: 3E 49 4E 
   197 00:0457: 20 12 17     TO_IN:          jsr     DO_USER
   198 00:045A: 00 00                        dw      TO_IN_OFFSET
   199                        
   200                        ; BASE ( -- a-addr )
   201                        ;
   202                        ; a-addr is the address of a cell containing the current number-conversion
   203                        ; radix {{2...36}}.
   204                        
   205 00:045C: 53 04 00 04                  HEADER  4,"BASE",NORMAL
       00:0460: 42 41 53 45 
   206 00:0464: 20 12 17     BASE:           jsr     DO_USER
   207 00:0467: 02 00                        dw      BASE_OFFSET
   208                        
   209                        ; BLK ( -- a-addr )
   210                        ;
   211                        ; a-addr is the address of a cell containing zero or the number of the mass-
   212                        ; storage block being interpreted. If BLK contains zero, the input source is
   213                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   214                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   215                        
   216 00:0469: 5F 04 00 03                  HEADER  3,"BLK",NORMAL
       00:046D: 42 4C 4B 
   217 00:0470: 20 12 17     BLK:            jsr     DO_USER
   218 00:0473: 04 00                        dw      BLK_OFFSET
   219                        
   220                        ; (BUFFER)
   221                        
   222                        ;               HEADER  8,"(BUFFER)",NORMAL
   223 00:0475: 20 12 17     BUFFER:         jsr     DO_USER
   224 00:0478: 10 00                        dw      BUFFER_OFFSET
   225                        
   226                        ; DP ( -- a-addr )
   227                        ;
  Mon Apr 18 2016 23:59                                                                                                    Page 7


   228                        ; Dictionary Pointer
   229                        
   230 00:047A: 6C 04 00 02                  HEADER  2,"DP",NORMAL
       00:047E: 44 50 
   231 00:0480: 20 12 17     DP:             jsr     DO_USER
   232 00:0483: 06 00                        dw      DP_OFFSET
   233                        
   234                        ; LATEST ( -- a-addr )
   235                        
   236 00:0485: 7D 04 00 06                  HEADER  6,"LATEST",NORMAL
       00:0489: 4C 41 54 45 
       00:048D: 53 54 
   237 00:048F: 20 12 17     LATEST:         jsr     DO_USER
   238 00:0492: 08 00                        dw      LATEST_OFFSET
   239                        
   240                        ; (LENGTH)
   241                        
   242                        ;               HEADER  8,"(LENGTH)",NORMAL
   243 00:0494: 20 12 17     LENGTH:         jsr     DO_USER
   244 00:0497: 12 00                        dw      LENGTH_OFFSET
   245                        
   246                        ; SCR ( -- a-addr )
   247                        ;
   248                        ; a-addr is the address of a cell containing the block number of the block most
   249                        ; recently LISTed.
   250                        
   251 00:0499: 88 04 00 03                  HEADER  3,"SCR",NORMAL
       00:049D: 53 43 52 
   252 00:04A0: 20 12 17     SCR:            jsr     DO_USER
   253 00:04A3: 0A 00                        dw      SCR_OFFSET
   254                        
   255                        ; (SOURCE-ID)
   256                        
   257                        ;               HEADER  11,"(SOURCE-ID)",NORMAL
   258 00:04A5: 20 12 17     SOURCEID:       jsr     DO_USER
   259 00:04A8: 0C 00                        dw      SOURCEID_OFFSET
   260                        
   261                        ; STATE ( -- a-addr )
   262                        ;
   263                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   264                        ; is true when in compilation state, false otherwise. The true value in STATE
   265                        ; is non-zero, but is otherwise implementation-defined.
   266                        
   267 00:04AA: 9C 04 00 05                  HEADER  5,"STATE",NORMAL
       00:04AE: 53 54 41 54 
       00:04B2: 45 
   268 00:04B3: 20 12 17     STATE:          jsr     DO_USER
   269 00:04B6: 0E 00                        dw      STATE_OFFSET
   270                        
   271                        ; TIB ( -- c-addr )
   272                        ;
   273                        ; c-addr is the address of the terminal input buffer.
   274                        
   275 00:04B8: AD 04 00 03                  HEADER  3,"TIB",NORMAL
       00:04BC: 54 49 42 
   276 00:04BF: 20 4C 15     TIB:            jsr     DO_CONSTANT
   277 00:04C2: 00 02                        dw      TIB_AREA
   278                        
  Mon Apr 18 2016 23:59                                                                                                    Page 8


   279                        ;===============================================================================
   280                        ; Constants
   281                        ;-------------------------------------------------------------------------------
   282                        
   283                        ; 0 ( -- 0 )
   284                        ;
   285                        ; Push the constant value zero on the stack
   286                        
   287 00:04C4: BB 04 00 01                  HEADER  1,"0",NORMAL
       00:04C8: 30 
   288                        ZERO:
   289 00:04C9: 7B                           tdc
   290 00:04CA: 3A                           dec     a                       ; Make space on the stack
   291 00:04CB: 3A                           dec     a
   292 00:04CC: 5B                           tcd
   293 00:04CD: 64 01                        stz     <1                      ; And create a zero value
   294 00:04CF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04D3: 00 00 
   295                        
   296                        ; BL ( -- char )
   297                        ;
   298                        ; char is the character value for a space.
   299                        
   300 00:04D5: C7 04 00 02                  HEADER  2,"BL",NORMAL
       00:04D9: 42 4C 
   301                        BL:
   302 00:04DB: 7B                           tdc
   303 00:04DC: 3A                           dec     a                       ; Make space on the stack
   304 00:04DD: 3A                           dec     a
   305 00:04DE: 5B                           tcd
   306 00:04DF: A9 20 00                     lda     #' '                    ; And save a space value
   307 00:04E2: 85 01                        sta     <1
   308 00:04E4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04E8: 00 00 
   309                        
   310                        ; FALSE ( -- false )
   311                        ;
   312                        ; Return a false flag.
   313                        
   314 00:04EA: D8 04 00 05                  HEADER  5,"FALSE",NORMAL
       00:04EE: 46 41 4C 53 
       00:04F2: 45 
   315                        FALSE:
   316 00:04F3: 7B                           tdc
   317 00:04F4: 3A                           dec     a                       ; Make space on the stack
   318 00:04F5: 3A                           dec     a
   319 00:04F6: 5B                           tcd
   320 00:04F7: 64 01                        stz     <1                      ; And create a false value
   321 00:04F9: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04FD: 00 00 
   322                        
   323                        ; TRUE ( -- true )
   324                        ;
   325                        ; Return a true flag, a single-cell value with all bits set.
   326                        
   327 00:04FF: ED 04 00 04                  HEADER  4,"TRUE",NORMAL
       00:0503: 54 52 55 45 
   328                        TRUE:
  Mon Apr 18 2016 23:59                                                                                                    Page 9


   329 00:0507: 7B                           tdc
   330 00:0508: 3A                           dec     a                       ; Make space on the stack
   331 00:0509: 3A                           dec     a
   332 00:050A: 5B                           tcd
   333 00:050B: 64 01                        stz     <1                      ; And create a true value
   334 00:050D: C6 01                        dec     <1
   335 00:050F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0513: 00 00 
   336                        
   337                        ;===============================================================================
   338                        ; Radix
   339                        ;-------------------------------------------------------------------------------
   340                        
   341                        ; DECIMAL ( -- )
   342                        ;
   343                        ; Set the numeric conversion radix to ten (decimal).
   344                        
   345 00:0515: 02 05 00 07                  HEADER  7,"DECIMAL",NORMAL
       00:0519: 44 45 43 49 
       00:051D: 4D 41 4C 
   346 00:0520: 20 32 14     DECIMAL:        jsr     DO_COLON
   347 00:0523: 08 16 0A 00                  dw      DO_LITERAL,10
   348 00:0527: 64 04                        dw      BASE
   349 00:0529: 46 05                        dw      STORE
   350 00:052B: AD 0E                        dw      EXIT
   351                        
   352                        ; HEX ( -- )
   353                        ;
   354                        ; Set contents of BASE to sixteen.
   355                        
   356 00:052D: 18 05 00 03                  HEADER  3,"HEX",NORMAL
       00:0531: 48 45 58 
   357 00:0534: 20 32 14     HEX:            jsr     DO_COLON
   358 00:0537: 08 16 10 00                  dw      DO_LITERAL,16
   359 00:053B: 64 04                        dw      BASE
   360 00:053D: 46 05                        dw      STORE
   361 00:053F: AD 0E                        dw      EXIT
   362                        
   363                        ;===============================================================================
   364                        ; Memory Operations
   365                        ;-------------------------------------------------------------------------------
   366                        
   367                        ; ! ( x a-addr -- )
   368                        ;
   369                        ; Store x at a-addr.
   370                        
   371 00:0541: 30 05 00 01                  HEADER  1,"!",NORMAL
       00:0545: 21 
   372                        STORE:
   373 00:0546: A5 03                        lda     <3                      ; Fetch data value
   374 00:0548: 92 01                        sta     (1)                     ; .. and store
   375 00:054A: 7B                           tdc                             ; Clean up data stack
   376 00:054B: 1A                           inc     a
   377 00:054C: 1A                           inc     a
   378 00:054D: 1A                           inc     a
   379 00:054E: 1A                           inc     a
   380 00:054F: 5B                           tcd
   381 00:0550: BB C8 C8 7C                  CONTINUE                        ; Done
  Mon Apr 18 2016 23:59                                                                                                    Page 10


       00:0554: 00 00 
   382                        
   383                        ; +! ( n|u a-addr -- )
   384                        ;
   385                        ; Add n|u to the single-cell number at a-addr.
   386                        
   387 00:0556: 44 05 00 02                  HEADER  2,"+!",NORMAL
       00:055A: 2B 21 
   388                        PLUS_STORE:
   389 00:055C: 18                           clc
   390 00:055D: A5 03                        lda     <3                      ; Fetch data value
   391 00:055F: 72 01                        adc     (1)
   392 00:0561: 92 01                        sta     (1)
   393 00:0563: 7B                           tdc                             ; Clean up data stack
   394 00:0564: 1A                           inc     a
   395 00:0565: 1A                           inc     a
   396 00:0566: 1A                           inc     a
   397 00:0567: 1A                           inc     a
   398 00:0568: 5B                           tcd
   399 00:0569: BB C8 C8 7C                  CONTINUE                        ; Done
       00:056D: 00 00 
   400                        
   401                        ; , ( x -- )
   402                        ;
   403                        ; Reserve one cell of data space and store x in the cell. If the data-space
   404                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   405                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   406                        ; is not aligned prior to execution of ,.
   407                        ;
   408                        ;   HERE ! 1 CELLS ALLOT
   409                        
   410 00:056F: 59 05 00                     LINK    NORMAL
   411 00:0572: 01 2C                        db      1,","
   412 00:0574: 20 32 14     COMMA:          jsr     DO_COLON
   413 00:0577: 1F 06                        dw      HERE
   414 00:0579: 46 05                        dw      STORE
   415 00:057B: 08 16 01 00                  dw      DO_LITERAL,1
   416 00:057F: 64 06                        dw      CELLS
   417 00:0581: C7 05                        dw      ALLOT
   418 00:0583: AD 0E                        dw      EXIT
   419                        
   420                        ; 2! ( x1 x2 a-addr -- )
   421                        ;
   422                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   423                        ; consecutive cell. It is equivalent to the sequence SWAP OVER ! CELL+ !.
   424                        
   425 00:0585: 72 05 00 02                  HEADER  2,"2!",NORMAL
       00:0589: 32 21 
   426 00:058B: 20 32 14     TWO_STORE:      jsr     DO_COLON
   427 00:058E: F6 07                        dw      SWAP
   428 00:0590: A3 07                        dw      OVER
   429 00:0592: 46 05                        dw      STORE
   430 00:0594: 51 06                        dw      CELL_PLUS
   431 00:0596: 46 05                        dw      STORE
   432 00:0598: AD 0E                        dw      EXIT
   433                        
   434                        ; 2@ ( a-addr -- x1 x2 )
   435                        ;
  Mon Apr 18 2016 23:59                                                                                                    Page 11


   436                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   437                        ; the next consecutive cell. It is equivalent to the sequence DUP CELL+ @ SWAP
   438                        ; @.
   439                        
   440 00:059A: 88 05 00 02                  HEADER  2,"2@",NORMAL
       00:059E: 32 40 
   441 00:05A0: 20 32 14     TWO_FETCH:      jsr     DO_COLON
   442 00:05A3: 80 07                        dw      DUP
   443 00:05A5: 51 06                        dw      CELL_PLUS
   444 00:05A7: B4 05                        dw      FETCH
   445 00:05A9: F6 07                        dw      SWAP
   446 00:05AB: B4 05                        dw      FETCH
   447 00:05AD: AD 0E                        dw      EXIT
   448                        
   449                        ; @ ( a-addr -- x )
   450                        ;
   451                        ; x is the value stored at a-addr.
   452                        
   453 00:05AF: 9D 05 00 01                  HEADER  1,"@",NORMAL
       00:05B3: 40 
   454                        FETCH:
   455 00:05B4: B2 01                        lda     (1)                     ; Fetch from memory
   456 00:05B6: 85 01                        sta     <1                      ; .. and replace top value
   457 00:05B8: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05BC: 00 00 
   458                        
   459                        ; ALLOT ( n -- )
   460                        ;
   461                        ; If n is greater than zero, reserve n address units of data space. If n is
   462                        ; less than zero, release |n| address units of data space. If n is zero, leave
   463                        ; the data-space pointer unchanged.
   464                        ;
   465                        ; In this implementation its is defined as:
   466                        ;
   467                        ;   DP +!
   468                        
   469 00:05BE: B2 05 00 05                  HEADER  5,"ALLOT",NORMAL
       00:05C2: 41 4C 4C 4F 
       00:05C6: 54 
   470 00:05C7: 20 32 14     ALLOT:          jsr     DO_COLON
   471 00:05CA: 80 04                        dw      DP
   472 00:05CC: 5C 05                        dw      PLUS_STORE
   473 00:05CE: AD 0E                        dw      EXIT
   474                        
   475                        ; C! ( char c-addr -- )
   476                        ;
   477                        ; Store char at c-addr. When character size is smaller than cell size, only the
   478                        ; number of low-order bits corresponding to character size are transferred.
   479                        
   480 00:05D0: C1 05 00 02                  HEADER  2,"C!",NORMAL
       00:05D4: 43 21 
   481                        C_STORE:
   482 00:05D6: A5 03                        lda     <3                      ; Fetch the data value
   483 00:05D8: E2 20                        short_a
   484 00:05DA: 92 01                        sta     (1)                     ; And store it
   485 00:05DC: C2 20                        long_a
   486 00:05DE: 7B                           tdc                             ; Clean up the stack
   487 00:05DF: 1A                           inc     a
  Mon Apr 18 2016 23:59                                                                                                    Page 12


   488 00:05E0: 1A                           inc     a
   489 00:05E1: 1A                           inc     a
   490 00:05E2: 1A                           inc     a
   491 00:05E3: 5B                           tcd
   492 00:05E4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05E8: 00 00 
   493                        
   494                        ; C, ( char -- )
   495                        ;
   496                        ; Reserve space for one character in the data space and store char in the
   497                        ; space. If the data-space pointer is character aligned when C, begins
   498                        ; execution, it will remain character aligned when C, finishes execution.
   499                        ; An ambiguous condition exists if the data-space pointer is not character-
   500                        ; aligned prior to execution of C,
   501                        ;
   502                        ;   HERE C! 1 CHARS ALLOT
   503                        
   504 00:05EA: D3 05 00                     LINK    NORMAL
   505 00:05ED: 02 43 2C                     db      2,"C,"
   506 00:05F0: 20 32 14     C_COMMA:        jsr     DO_COLON
   507 00:05F3: 1F 06                        dw      HERE
   508 00:05F5: D6 05                        dw      C_STORE
   509 00:05F7: 08 16 01 00                  dw      DO_LITERAL,1
   510 00:05FB: 97 06                        dw      CHARS
   511 00:05FD: C7 05                        dw      ALLOT
   512 00:05FF: AD 0E                        dw      EXIT
   513                        
   514                        ; C@ ( c-addr -- char )
   515                        ;
   516                        ; Fetch the character stored at c-addr. When the cell size is greater than
   517                        ; character size, the unused high-order bits are all zeroes.
   518                        
   519 00:0601: ED 05 00 02                  HEADER  2,"C@",NORMAL
       00:0605: 43 40 
   520                        C_FETCH:
   521 00:0607: E2 20                        short_a
   522 00:0609: B2 01                        lda     (1)                     ; Fetch the data byte
   523 00:060B: 85 01                        sta     <1                      ; .. and replace stack value
   524 00:060D: 64 02                        stz     <2
   525 00:060F: C2 20                        long_a
   526 00:0611: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0615: 00 00 
   527                        
   528                        ; HERE ( -- addr )
   529                        ;
   530                        ; addr is the data-space pointer.
   531                        
   532 00:0617: 04 06 00 04                  HEADER  4,"HERE",NORMAL
       00:061B: 48 45 52 45 
   533 00:061F: 20 32 14     HERE:           jsr     DO_COLON
   534 00:0622: 80 04                        dw      DP
   535 00:0624: B4 05                        dw      FETCH
   536 00:0626: AD 0E                        dw      EXIT
   537                        
   538                        ;===============================================================================
   539                        ; Alignment
   540                        ;-------------------------------------------------------------------------------
   541                        
  Mon Apr 18 2016 23:59                                                                                                    Page 13


   542                        ; ALIGN ( -- )
   543                        ;
   544                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   545                        
   546 00:0628: 1A 06 00 05                  HEADER  5,"ALIGN",NORMAL
       00:062C: 41 4C 49 47 
       00:0630: 4E 
   547                        ALIGN:
   548 00:0631: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0635: 00 00 
   549                        
   550                        ; ALIGNED ( addr -- a-addr )
   551                        ;
   552                        ; a-addr is the first aligned address greater than or equal to addr.
   553                        
   554 00:0637: 2B 06 00 07                  HEADER  7,"ALIGNED",NORMAL
       00:063B: 41 4C 49 47 
       00:063F: 4E 45 44 
   555                        ALIGNED:
   556 00:0642: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0646: 00 00 
   557                        
   558                        ; CELL+ ( a-addr1 -- a-addr2 )
   559                        ;
   560                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   561                        
   562 00:0648: 3A 06 00 05                  HEADER  5,"CELL+",NORMAL
       00:064C: 43 45 4C 4C 
       00:0650: 2B 
   563                        CELL_PLUS:
   564 00:0651: E6 01                        inc     <1                      ; Bump the address by two
   565 00:0653: E6 01                        inc     <1
   566 00:0655: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0659: 00 00 
   567                        
   568                        ; CELLS ( n1 -- n2 )
   569                        ;
   570                        ; n2 is the size in address units of n1 cells.
   571                        
   572 00:065B: 4B 06 00 05                  HEADER  5,"CELLS",NORMAL
       00:065F: 43 45 4C 4C 
       00:0663: 53 
   573                        CELLS:
   574 00:0664: 06 01                        asl     <1                      ; Two bytes per cell
   575 00:0666: BB C8 C8 7C                  CONTINUE                        ; Done
       00:066A: 00 00 
   576                        
   577                        ; CHAR+ ( c-addr1 -- c-addr2 )
   578                        ;
   579                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
   580                        
   581 00:066C: 5E 06 00 05                  HEADER  5,"CHAR+",NORMAL
       00:0670: 43 48 41 52 
       00:0674: 2B 
   582                        CHAR_PLUS:
   583 00:0675: E6 01                        inc     <1                      ; Bump the address by one
   584 00:0677: BB C8 C8 7C                  CONTINUE                        ; Done
       00:067B: 00 00 
  Mon Apr 18 2016 23:59                                                                                                    Page 14


   585                        
   586                        ; CHAR- ( c-addr1 -- c-addr2 )
   587                        ;
   588                        ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
   589                        
   590 00:067D: 6F 06 00 05                  HEADER  5,"CHAR-",NORMAL
       00:0681: 43 48 41 52 
       00:0685: 2D 
   591                        CHAR_MINUS:
   592 00:0686: C6 01                        dec     <1
   593 00:0688: BB C8 C8 7C                  CONTINUE                        ; Done
       00:068C: 00 00 
   594                        
   595                        ; CHARS ( n1 -- n2 )
   596                        ;
   597                        ; n2 is the size in address units of n1 characters.
   598                        
   599 00:068E: 80 06 00 05                  HEADER  5,"CHARS",NORMAL
       00:0692: 43 48 41 52 
       00:0696: 53 
   600                        CHARS:
   601 00:0697: BB C8 C8 7C                  CONTINUE                        ; Done
       00:069B: 00 00 
   602                        
   603                        ;===============================================================================
   604                        ; Stack Operations
   605                        ;-------------------------------------------------------------------------------
   606                        
   607                        ; 2DROP ( x1 x2 -- )
   608                        ;
   609                        ; Drop cell pair x1 x2 from the stack.
   610                        
   611 00:069D: 91 06 00 05                  HEADER  5,"2DROP",NORMAL
       00:06A1: 32 44 52 4F 
       00:06A5: 50 
   612                        TWO_DROP:
   613 00:06A6: 7B                           tdc                             ; Removed two words from stack
   614 00:06A7: 1A                           inc     a
   615 00:06A8: 1A                           inc     a
   616 00:06A9: 1A                           inc     a
   617 00:06AA: 1A                           inc     a
   618 00:06AB: 5B                           tcd
   619 00:06AC: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06B0: 00 00 
   620                        
   621                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   622                        ;
   623                        ; Duplicate cell pair x1 x2.
   624                        
   625 00:06B2: A0 06 00 04                  HEADER  4,"2DUP",NORMAL
       00:06B6: 32 44 55 50 
   626                        TWO_DUP:
   627 00:06BA: 7B                           tdc                             ; Make space for new value
   628 00:06BB: 3A                           dec     a
   629 00:06BC: 3A                           dec     a
   630 00:06BD: 3A                           dec     a
   631 00:06BE: 3A                           dec     a
   632 00:06BF: 5B                           tcd
  Mon Apr 18 2016 23:59                                                                                                    Page 15


   633 00:06C0: A5 05                        lda     <5                      ; Copy top two values
   634 00:06C2: 85 01                        sta     <1
   635 00:06C4: A5 07                        lda     <7
   636 00:06C6: 85 03                        sta     <3
   637 00:06C8: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06CC: 00 00 
   638                        
   639                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   640                        ;
   641                        ; Copy cell pair x1 x2 to the top of the stack.
   642                        
   643 00:06CE: B5 06 00 05                  HEADER  5,"2OVER",NORMAL
       00:06D2: 32 4F 56 45 
       00:06D6: 52 
   644                        TWO_OVER:
   645 00:06D7: 7B                           tdc                             ; Make space for new value
   646 00:06D8: 3A                           dec     a
   647 00:06D9: 3A                           dec     a
   648 00:06DA: 3A                           dec     a
   649 00:06DB: 3A                           dec     a
   650 00:06DC: 5B                           tcd
   651 00:06DD: A5 09                        lda     <9                      ; Ciopy top two values
   652 00:06DF: 85 01                        sta     <1
   653 00:06E1: A5 0B                        lda     <11
   654 00:06E3: 85 03                        sta     <3
   655 00:06E5: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06E9: 00 00 
   656                        
   657                        ; 2ROT ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
   658                        ;
   659                        ; Rotate the top three cell pairs on the stack bringing cell pair x1 x2 to
   660                        ; the top of the stack.
   661                        
   662 00:06EB: D1 06 00 04                  HEADER  4,"2ROT",NORMAL
       00:06EF: 32 52 4F 54 
   663 00:06F3: 20 32 14     TWO_ROT:        jsr     DO_COLON
   664 00:06F6: A5 0B                        lda     <11                     ; Save x1
   665 00:06F8: 48                           pha
   666 00:06F9: A5 09                        lda     <9                      ; Save x2
   667 00:06FB: 48                           pha
   668 00:06FC: A5 07                        lda     <7                      ; Move x3
   669 00:06FE: 85 0B                        sta     <11
   670 00:0700: A5 05                        lda     <5                      ; Move x4
   671 00:0702: 85 09                        sta     <9
   672 00:0704: A5 03                        lda     <3                      ; Move x5
   673 00:0706: 85 07                        sta     <7
   674 00:0708: A5 01                        lda     <1                      ; Move x6
   675 00:070A: 85 05                        sta     <5
   676 00:070C: 68                           pla                             ; Restore x2
   677 00:070D: 85 01                        sta     <1
   678 00:070F: 68                           pla                             ; Restore x1
   679 00:0710: 85 03                        sta     <3
   680 00:0712: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0716: 00 00 
   681                        
   682                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   683                        ;
   684                        ; Exchange the top two cell pairs.
  Mon Apr 18 2016 23:59                                                                                                    Page 16


   685                        
   686 00:0718: EE 06 00 05                  HEADER  5,"2SWAP",NORMAL
       00:071C: 32 53 57 41 
       00:0720: 50 
   687                        TWO_SWAP:
   688 00:0721: A5 03                        lda     <3                      ; Save x3
   689 00:0723: 48                           pha
   690 00:0724: A5 01                        lda     <1                      ; Save x4
   691 00:0726: 48                           pha
   692 00:0727: A5 07                        lda     <7                      ; Move x1
   693 00:0729: 85 03                        sta     <3
   694 00:072B: A5 05                        lda     <5                      ; Move x2
   695 00:072D: 85 01                        sta     <1
   696 00:072F: 68                           pla                             ; Move x4
   697 00:0730: 85 05                        sta     <5
   698 00:0732: 68                           pla                             ; Move x3
   699 00:0733: 85 07                        sta     <7
   700 00:0735: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0739: 00 00 
   701                        
   702                        ; ?DUP ( x -- 0 | x x )
   703                        ;
   704                        ; Duplicate x if it is non-zero.
   705                        
   706 00:073B: 1B 07 00 04                  HEADER  4,"?DUP",NORMAL
       00:073F: 3F 44 55 50 
   707                        QUERY_DUP:
   708 00:0743: A5 01                        lda     <1                      ; Fetch top value
   709 00:0745: D0 39                        bne     DUP                     ; Non-zero value?
   710 00:0747: BB C8 C8 7C                  CONTINUE                        ; Done
       00:074B: 00 00 
   711                        
   712                        ; DEPTH ( -- n )
   713                        
   714 00:074D: 3E 07 00 05                  HEADER  5,"DEPTH",NORMAL
       00:0751: 44 45 50 54 
       00:0755: 48 
   715 00:0756: 20 32 14     DEPTH:          jsr     DO_COLON
   716 00:0759: 13 19                        dw      AT_DP
   717 00:075B: 08 16 7F 01                  dw      DO_LITERAL,DSTACK_END-1
   718 00:075F: F6 07                        dw      SWAP
   719 00:0761: 10 09                        dw      MINUS
   720 00:0763: 74 09                        dw      TWO_SLASH
   721 00:0765: AD 0E                        dw      EXIT
   722                        
   723                        ; DROP ( x -- )
   724                        ;
   725                        ; Remove x from the stack.
   726                        
   727 00:0767: 50 07 00 04                  HEADER  4,"DROP",NORMAL
       00:076B: 44 52 4F 50 
   728                        DROP:
   729 00:076F: 7B                           tdc                             ; Drop the top value
   730 00:0770: 1A                           inc     a
   731 00:0771: 1A                           inc     a
   732 00:0772: 5B                           tcd
   733 00:0773: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0777: 00 00 
  Mon Apr 18 2016 23:59                                                                                                    Page 17


   734                        
   735                        ; DUP ( x -- x x )
   736                        ;
   737                        ; Duplicate x.
   738                        
   739 00:0779: 6A 07 00 03                  HEADER  3,"DUP",NORMAL
       00:077D: 44 55 50 
   740                        DUP:
   741 00:0780: 7B                           tdc
   742 00:0781: 3A                           dec     a
   743 00:0782: 3A                           dec     a
   744 00:0783: 5B                           tcd
   745 00:0784: A5 03                        lda     <3                      ; Fetch top value
   746 00:0786: 85 01                        sta     <1                      ; And make a copy
   747 00:0788: BB C8 C8 7C                  CONTINUE                        ; Done
       00:078C: 00 00 
   748                        
   749                        ; NIP ( x1 x2 -- x2 )
   750                        ;
   751                        ; Drop the first item below the top of stack.
   752                        
   753 00:078E: 7C 07 00 03                  HEADER  3,"NIP",NORMAL
       00:0792: 4E 49 50 
   754                        NIP:
   755 00:0795: A5 01                        lda     <1                      ; Copy x2 over x1
   756 00:0797: 85 03                        sta     <3
   757 00:0799: 80 D4                        bra     DROP
   758                        
   759                        ; OVER ( x1 x2 -- x1 x2 x1 )
   760                        ;
   761                        ; Place a copy of x1 on top of the stack.
   762                        
   763 00:079B: 91 07 00 04                  HEADER  4,"OVER",NORMAL
       00:079F: 4F 56 45 52 
   764                        OVER:
   765 00:07A3: 7B                           tdc
   766 00:07A4: 3A                           dec     a
   767 00:07A5: 3A                           dec     a
   768 00:07A6: 5B                           tcd
   769 00:07A7: A5 05                        lda     <5                      ; Fetch second value
   770 00:07A9: 85 01                        sta     <1                      ; And make a copy
   771 00:07AB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07AF: 00 00 
   772                        
   773                        ; PICK ( xu ... x1 x0 u -- xu ... x1 x0 xu )
   774                        ;
   775                        ; Remove u. Copy the xu to the top of the stack. An ambiguous condition exists
   776                        ; if there are less than u+2 items on the stack before PICK is executed.
   777                        
   778 00:07B1: 9E 07 00 04                  HEADER  4,"PICK",NORMAL
       00:07B5: 50 49 43 4B 
   779                        PICK:
   780 00:07B9: A5 01                        lda     <1                      ; Fetch the index
   781 00:07BB: 0A                           asl     a
   782 00:07BC: AA                           tax
   783 00:07BD: B5 03                        lda     <3,x                    ; Load the target value
   784 00:07BF: 85 01                        sta     <1                      ; .. and save
   785 00:07C1: BB C8 C8 7C                  CONTINUE                        ; Done
  Mon Apr 18 2016 23:59                                                                                                    Page 18


       00:07C5: 00 00 
   786                        
   787                        ; ROLL ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
   788                        ;
   789                        ; Remove u. Rotate u+1 items on the top of the stack. An ambiguous condition
   790                        ; exists if there are less than u+2 items on the stack before ROLL is executed.
   791                        
   792                        ; TODO
   793                        
   794 00:07C7: B4 07 00 04                  HEADER  4,"ROLL",NORMAL
       00:07CB: 52 4F 4C 4C 
   795                        ROLL:
   796 00:07CF: BB C8 C8 7C                  CONTINUE
       00:07D3: 00 00 
   797                        
   798                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   799                        ;
   800                        ; Rotate the top three stack entries.
   801                        
   802 00:07D5: CA 07 00 03                  HEADER  3,"ROT",NORMAL
       00:07D9: 52 4F 54 
   803                        ROT:
   804 00:07DC: A6 05                        ldx     <5                      ; Save x1
   805 00:07DE: A5 03                        lda     <3                      ; Move x2
   806 00:07E0: 85 05                        sta     <5
   807 00:07E2: A5 01                        lda     <1                      ; Move x3
   808 00:07E4: 85 03                        sta     <3
   809 00:07E6: 86 01                        stx     <1                      ; Restore x1
   810 00:07E8: BB C8 C8 7C                  CONTINUE
       00:07EC: 00 00 
   811                        
   812                        ; SWAP ( x1 x2 -- x2 x1 )
   813                        ;
   814                        ; Exchange the top two stack items.
   815                        
   816 00:07EE: D8 07 00 04                  HEADER  4,"SWAP",NORMAL
       00:07F2: 53 57 41 50 
   817                        SWAP:
   818 00:07F6: A5 01                        lda     <1                      ; Switch top two words
   819 00:07F8: A6 03                        ldx     <3
   820 00:07FA: 85 03                        sta     <3
   821 00:07FC: 86 01                        stx     <1
   822 00:07FE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0802: 00 00 
   823                        
   824                        ; TUCK ( x1 x2 -- x2 x1 x2 )
   825                        ;
   826                        ; Copy the first (top) stack item below the second stack item.
   827                        
   828 00:0804: F1 07 00 04                  HEADER  4,"TUCK",NORMAL
       00:0808: 54 55 43 4B 
   829 00:080C: 20 32 14     TUCK:           jsr     DO_COLON
   830 00:080F: F6 07                        dw      SWAP
   831 00:0811: A3 07                        dw      OVER
   832 00:0813: AD 0E                        dw      EXIT
   833                        
   834                        ;===============================================================================
   835                        ; Return Stack Operations
  Mon Apr 18 2016 23:59                                                                                                    Page 19


   836                        ;-------------------------------------------------------------------------------
   837                        
   838                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   839                        ;
   840                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   841                        ; SWAP >R >R.
   842                        
   843 00:0815: 07 08 00 03                  HEADER  3,"2>R",NORMAL
       00:0819: 32 3E 52 
   844                        TWO_TO_R:
   845 00:081C: A5 03                        lda     <3                      ; Transfer x1
   846 00:081E: 48                           pha
   847 00:081F: A5 01                        lda     <1                      ; Transfer x2
   848 00:0821: 48                           pha
   849 00:0822: 7B                           tdc
   850 00:0823: 1A                           inc     a                       ; Clean up data stack
   851 00:0824: 1A                           inc     a
   852 00:0825: 1A                           inc     a
   853 00:0826: 1A                           inc     a
   854 00:0827: 5B                           tcd
   855 00:0828: BB C8 C8 7C                  CONTINUE                        ; Done
       00:082C: 00 00 
   856                        
   857                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   858                        ;
   859                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   860                        ; R> SWAP.
   861                        
   862 00:082E: 18 08 00 03                  HEADER  3,"2R>",NORMAL
       00:0832: 32 52 3E 
   863                        TWO_R_FROM:
   864 00:0835: 7B                           tdc
   865 00:0836: 3A                           dec     a                       ; Make space for values
   866 00:0837: 3A                           dec     a
   867 00:0838: 3A                           dec     a
   868 00:0839: 3A                           dec     a
   869 00:083A: 5B                           tcd
   870 00:083B: 68                           pla                             ; Transfer x2
   871 00:083C: 85 01                        sta     <1
   872 00:083E: 68                           pla                             ; Transfer x1
   873 00:083F: 85 03                        sta     <3
   874 00:0841: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0845: 00 00 
   875                        
   876                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
   877                        ;
   878                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   879                        ; 2DUP >R >R SWAP.
   880                        
   881 00:0847: 31 08 00 03                  HEADER  3,"2R@",NORMAL
       00:084B: 32 52 40 
   882                        TWO_R_FETCH:
   883 00:084E: 7B                           tdc
   884 00:084F: 3A                           dec     a                       ; Make space for values
   885 00:0850: 3A                           dec     a
   886 00:0851: 3A                           dec     a
   887 00:0852: 3A                           dec     a
   888 00:0853: 5B                           tcd
  Mon Apr 18 2016 23:59                                                                                                    Page 20


   889 00:0854: A3 01                        lda     1,s                     ; Transfer x2
   890 00:0856: 85 01                        sta     <1
   891 00:0858: A3 03                        lda     3,s                     ; Transfer x1
   892 00:085A: 85 03                        sta     <3
   893 00:085C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0860: 00 00 
   894                        
   895                        ; >R ( x -- ) ( R: -- x )
   896                        ;
   897                        ; Move x to the return stack.
   898                        
   899 00:0862: 4A 08 00 02                  HEADER  2,">R",NORMAL
       00:0866: 3E 52 
   900                        TO_R:
   901 00:0868: A5 01                        lda     <1                      ; Transfer top value
   902 00:086A: 48                           pha                             ; .. to return stack
   903 00:086B: 7B                           tdc
   904 00:086C: 1A                           inc     a
   905 00:086D: 1A                           inc     a
   906 00:086E: 5B                           tcd
   907 00:086F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0873: 00 00 
   908                        
   909                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   910                        ;
   911                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   912                        ; exists if the loop control parameters are unavailable.
   913                        
   914 00:0875: 65 08 00 01                  HEADER  1,"I",NORMAL
       00:0879: 49 
   915                        I:
   916 00:087A: 7B                           tdc
   917 00:087B: 3A                           dec     a
   918 00:087C: 3A                           dec     a
   919 00:087D: 5B                           tcd
   920 00:087E: A3 01                        lda     1,s
   921 00:0880: 85 01                        sta     <1
   922 00:0882: BB C8 C8 7C                  CONTINUE
       00:0886: 00 00 
   923                        
   924                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   925                        ;
   926                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   927                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   928                        ; unavailable.
   929                        
   930 00:0888: 78 08 00 01                  HEADER  1,"J",NORMAL
       00:088C: 4A 
   931                        J:
   932 00:088D: 7B                           tdc
   933 00:088E: 3A                           dec     a
   934 00:088F: 3A                           dec     a
   935 00:0890: 5B                           tcd
   936 00:0891: A3 05                        lda     5,s
   937 00:0893: 85 01                        sta     <1
   938 00:0895: BB C8 C8 7C                  CONTINUE
       00:0899: 00 00 
   939                        
  Mon Apr 18 2016 23:59                                                                                                    Page 21


   940                        ; R> ( -- x ) ( R: x -- )
   941                        ;
   942                        ; Move x from the return stack to the data stack.
   943                        
   944 00:089B: 8B 08 00 02                  HEADER  2,"R>",NORMAL
       00:089F: 52 3E 
   945                        R_FROM:
   946 00:08A1: 7B                           tdc
   947 00:08A2: 3A                           dec     a
   948 00:08A3: 3A                           dec     a
   949 00:08A4: 5B                           tcd
   950 00:08A5: 68                           pla                             ; Fetch return stack value
   951 00:08A6: 85 01                        sta     <1
   952 00:08A8: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08AC: 00 00 
   953                        
   954                        ; R@ ( -- x ) ( R: x -- x )
   955                        ;
   956                        ; Copy x from the return stack to the data stack.
   957                        
   958 00:08AE: 9E 08 00 02                  HEADER  2,"R@",NORMAL
       00:08B2: 52 40 
   959                        R_FETCH:
   960 00:08B4: 7B                           tdc
   961 00:08B5: 3A                           dec     a
   962 00:08B6: 3A                           dec     a
   963 00:08B7: 5B                           tcd
   964 00:08B8: A3 01                        lda     1,s
   965 00:08BA: 85 01                        sta     <1
   966 00:08BC: BB C8 C8 7C                  CONTINUE
       00:08C0: 00 00 
   967                        
   968                        ;===============================================================================
   969                        ; Single Precision Arithmetic
   970                        ;-------------------------------------------------------------------------------
   971                        
   972                        ; * ( n1|u1 n2|u2 -- n3|u3 )
   973                        ;
   974                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
   975                        ;
   976                        ;	M* DROP
   977                        
   978 00:08C2: B1 08 00 01                  HEADER  1,"*",NORMAL
       00:08C6: 2A 
   979 00:08C7: 20 32 14     STAR:		jsr	DO_COLON
   980 00:08CA: AF 0B        		dw	M_STAR
   981 00:08CC: 6F 07        		dw	DROP
   982 00:08CE: AD 0E        		dw	EXIT
   983                        
   984                        ; */
   985                        ;
   986                        ;	*/MOD NIP
   987                        
   988 00:08D0: C5 08 00 02                  HEADER  2,"*/",NORMAL
       00:08D4: 2A 2F 
   989 00:08D6: 20 32 14     STAR_SLASH:	jsr	DO_COLON
   990 00:08D9: E8 08        		dw	STAR_SLASH_MOD
   991 00:08DB: 95 07        		dw	NIP
  Mon Apr 18 2016 23:59                                                                                                    Page 22


   992 00:08DD: AD 0E                        dw	EXIT
   993                        
   994                        ; */MOD
   995                        ;
   996                        ;	>R M* R> FM/MOD
   997                        
   998 00:08DF: D3 08 00 05                  HEADER  5,"*/MOD",NORMAL
       00:08E3: 2A 2F 4D 4F 
       00:08E7: 44 
   999 00:08E8: 20 32 14     STAR_SLASH_MOD:	jsr	DO_COLON
  1000 00:08EB: 68 08        		dw	TO_R
  1001 00:08ED: AF 0B        		dw	M_STAR
  1002 00:08EF: A1 08        		dw	R_FROM
  1003 00:08F1: AA 09        		dw	FM_SLASH_MOD
  1004 00:08F3: AD 0E                        dw	EXIT
  1005                        
  1006                        ; + ( n1|u1 n2|u2 -- n3|u3 )
  1007                        ;
  1008                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
  1009                        
  1010 00:08F5: E2 08 00 01                  HEADER  1,"+",NORMAL
       00:08F9: 2B 
  1011                        PLUS:
  1012 00:08FA: 18                           clc                             ; Add top two values
  1013 00:08FB: A5 03                        lda     <3
  1014 00:08FD: 65 01                        adc     <1
  1015 00:08FF: 85 03                        sta     <3                      ; Save result
  1016 00:0901: 7B                           tdc
  1017 00:0902: 1A                           inc     a                       ; Clean up data stack
  1018 00:0903: 1A                           inc     a
  1019 00:0904: 5B                           tcd
  1020 00:0905: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0909: 00 00 
  1021                        
  1022                        ; - ( n1|u1 n2|u2 -- n3|u3 )
  1023                        ;
  1024                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
  1025                        
  1026 00:090B: F8 08 00 01                  HEADER  1,"-",NORMAL
       00:090F: 2D 
  1027                        MINUS:
  1028 00:0910: 38                           sec                             ; Subtract top two values
  1029 00:0911: A5 03                        lda     <3
  1030 00:0913: E5 01                        sbc     <1
  1031 00:0915: 85 03                        sta     <3                      ; Save result
  1032 00:0917: 7B                           tdc
  1033 00:0918: 1A                           inc     a                       ; Clean up data stack
  1034 00:0919: 1A                           inc     a
  1035 00:091A: 5B                           tcd
  1036 00:091B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:091F: 00 00 
  1037                        
  1038                        ; /
  1039                        ;
  1040                        ;	/MOD NIP
  1041                        
  1042 00:0921: 0E 09 00 01                  HEADER  1,"/",NORMAL
       00:0925: 2F 
  Mon Apr 18 2016 23:59                                                                                                    Page 23


  1043 00:0926: 20 32 14     SLASH:          jsr     DO_COLON
  1044 00:0929: 37 09                        dw      SLASH_MOD
  1045 00:092B: 95 07                        dw      NIP
  1046 00:092D: AD 0E                        dw      EXIT
  1047                        
  1048                        ; /MOD
  1049                        ;
  1050                        ;	>R S>D R> FM/MOD
  1051                        
  1052 00:092F: 24 09 00 04                  HEADER  4,"/MOD",NORMAL
       00:0933: 2F 4D 4F 44 
  1053 00:0937: 20 32 14     SLASH_MOD:	jsr	DO_COLON
  1054 00:093A: 68 08        		dw	TO_R
  1055 00:093C: EA 0B        		dw	S_TO_D
  1056 00:093E: A1 08        		dw	R_FROM
  1057 00:0940: AA 09        		dw	FM_SLASH_MOD
  1058 00:0942: AD 0E                        dw	EXIT
  1059                        
  1060                        ; 1+ ( n1|u1 -- n2|u2 )
  1061                        ;
  1062                        ; Add one (1) to n1|u1 giving the sum n2|u2.
  1063                        
  1064 00:0944: 32 09 00 02                  HEADER  2,"1+",NORMAL
       00:0948: 31 2B 
  1065                        ONE_PLUS:
  1066 00:094A: E6 01                        inc     <1                      ; Increment top of stack
  1067 00:094C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0950: 00 00 
  1068                        
  1069                        ; 1- ( n1|u1 -- n2|u2 )
  1070                        ;
  1071                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
  1072                        
  1073 00:0952: 47 09 00 02                  HEADER  2,"1-",NORMAL
       00:0956: 31 2D 
  1074                        ONE_MINUS:
  1075 00:0958: C6 01                        dec     <1                      ; Decrement top of stack
  1076 00:095A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:095E: 00 00 
  1077                        
  1078                        ; 2* ( x1 -- x2 )
  1079                        ;
  1080                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
  1081                        ; filling the vacated least-significant bit with zero.
  1082                        
  1083 00:0960: 55 09 00 02                  HEADER  2,"2*",NORMAL
       00:0964: 32 2A 
  1084                        TWO_STAR:
  1085 00:0966: 06 01                        asl     <1                      ; Multiply top value by two
  1086 00:0968: BB C8 C8 7C                  CONTINUE                        ; Done
       00:096C: 00 00 
  1087                        
  1088                        ; 2/ ( x1 -- x2 )
  1089                        ;
  1090                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
  1091                        ; leaving the most-significant bit unchanged.
  1092                        
  1093 00:096E: 63 09 00 02                  HEADER  2,"2/",NORMAL
  Mon Apr 18 2016 23:59                                                                                                    Page 24


       00:0972: 32 2F 
  1094                        TWO_SLASH:
  1095 00:0974: A5 01                        lda     <1                      ; Load the top value
  1096 00:0976: 2A                           rol     a                       ; Extract the top bit
  1097 00:0977: 66 01                        ror     <1                      ; And shift back into value
  1098 00:0979: BB C8 C8 7C                  CONTINUE
       00:097D: 00 00 
  1099                        
  1100                        ; ?NEGATE
  1101                        ;
  1102                        ;	0< IF NEGATE THEN
  1103                        
  1104 00:097F: 20 32 14     QUERY_NEGATE:	jsr	DO_COLON
  1105 00:0982: A3 0C        		dw	ZERO_LESS
  1106 00:0984: C1 15 8A 09  		dw	QUERY_BRANCH,QUERY_NEGATE_1
  1107 00:0988: 33 0A        		dw	NEGATE
  1108 00:098A: AD 0E        QUERY_NEGATE_1:	dw	EXIT
  1109                        
  1110                        ; ABS ( n -- u )
  1111                        ;
  1112                        ; u is the absolute value of n.
  1113                        
  1114 00:098C: 71 09 00 03                  HEADER  3,"ABS",NORMAL
       00:0990: 41 42 53 
  1115                        ABS:
  1116 00:0993: A5 01                        lda     <1
  1117 00:0995: 10 03                        bpl	ABS_1
  1118 00:0997: 4C 33 0A     		jmp	NEGATE
  1119 00:099A: BB C8 C8 7C  ABS_1:          CONTINUE                        ; Done
       00:099E: 00 00 
  1120                        
  1121                        ; FM/MOD
  1122                        ;
  1123                        ;   DUP >R	      divisor 
  1124                        ;   2DUP XOR >R	 sign of quotient 
  1125                        ;   >R		  divisor 
  1126                        ;   DABS R@ ABS UM/MOD 
  1127                        ;   SWAP R> ?NEGATE SWAP	apply sign to remainder 
  1128                        ;   R> 0< IF			if quotient negative, 
  1129                        ;       NEGATE 
  1130                        ;       OVER IF			if remainder nonzero, 
  1131                        ;	R@ ROT - SWAP 1-	adjust rem,quot 
  1132                        ;       THEN 
  1133                        ;   THEN  R> DROP ; 
  1134                        
  1135 00:09A0: 8F 09 00 06  		HEADER	6,"FM/MOD",NORMAL
       00:09A4: 46 4D 2F 4D 
       00:09A8: 4F 44 
  1136 00:09AA: 20 32 14     FM_SLASH_MOD:	jsr	DO_COLON
  1137 00:09AD: 80 07        		dw	DUP
  1138 00:09AF: 68 08        		dw	TO_R
  1139 00:09B1: BA 06        		dw	TWO_DUP
  1140 00:09B3: 20 0E        		dw	XOR
  1141 00:09B5: 68 08        		dw	TO_R
  1142 00:09B7: 68 08        		dw	TO_R
  1143 00:09B9: 33 0B        		dw	DABS
  1144 00:09BB: B4 08        		dw	R_FETCH
  1145 00:09BD: 93 09        		dw	ABS
  Mon Apr 18 2016 23:59                                                                                                    Page 25


  1146 00:09BF: 7C 0C        		dw	UM_SLASH_MOD
  1147 00:09C1: F6 07        		dw	SWAP
  1148 00:09C3: A1 08        		dw	R_FROM
  1149 00:09C5: 7F 09        		dw	QUERY_NEGATE
  1150 00:09C7: F6 07        		dw	SWAP
  1151 00:09C9: A1 08        		dw	R_FROM
  1152 00:09CB: A3 0C        		dw	ZERO_LESS
  1153 00:09CD: C1 15 E3 09  		dw	QUERY_BRANCH,FM_SLASH_MOD_1
  1154 00:09D1: 33 0A        		dw	NEGATE
  1155 00:09D3: A3 07        		dw	OVER
  1156 00:09D5: C1 15 E3 09  		dw	QUERY_BRANCH,FM_SLASH_MOD_1
  1157 00:09D9: B4 08        		dw	R_FETCH
  1158 00:09DB: DC 07        		dw	ROT
  1159 00:09DD: 10 09        		dw	MINUS
  1160 00:09DF: F6 07        		dw	SWAP
  1161 00:09E1: 58 09        		dw	ONE_MINUS
  1162 00:09E3: A1 08        FM_SLASH_MOD_1:	dw	R_FROM
  1163 00:09E5: 6F 07        		dw	DROP
  1164 00:09E7: AD 0E        		dw	EXIT
  1165                        		
  1166                        ; MAX
  1167                        
  1168 00:09E9: A3 09 00 03                  HEADER  3,"MAX",NORMAL
       00:09ED: 4D 41 58 
  1169 00:09F0: 20 32 14     MAX:            jsr     DO_COLON
  1170 00:09F3: BA 06                        dw      TWO_DUP
  1171 00:09F5: F5 0C                        dw      LESS
  1172 00:09F7: C1 15 FD 09                  dw      QUERY_BRANCH,MAX_1
  1173 00:09FB: F6 07                        dw      SWAP
  1174 00:09FD: 6F 07        MAX_1:          dw      DROP
  1175 00:09FF: AD 0E                        dw      EXIT
  1176                        
  1177                        ; MIN
  1178                        
  1179 00:0A01: EC 09 00 03                  HEADER  3,"MIN",NORMAL
       00:0A05: 4D 49 4E 
  1180 00:0A08: 20 32 14     MIN:            jsr     DO_COLON
  1181 00:0A0B: BA 06                        dw      TWO_DUP
  1182 00:0A0D: 49 0D                        dw      GREATER
  1183 00:0A0F: C1 15 15 0A                  dw      QUERY_BRANCH,MIN_1
  1184 00:0A13: F6 07                        dw      SWAP
  1185 00:0A15: 6F 07        MIN_1:          dw      DROP
  1186 00:0A17: AD 0E                        dw      EXIT
  1187                        
  1188                        ; MOD
  1189                        
  1190 00:0A19: 04 0A 00 03                  HEADER  3,"MOD",NORMAL
       00:0A1D: 4D 4F 44 
  1191 00:0A20: 20 32 14     MOD:            jsr     DO_COLON
  1192 00:0A23: 37 09                        dw      SLASH_MOD
  1193 00:0A25: 6F 07                        dw      DROP
  1194 00:0A27: AD 0E                        dw      EXIT
  1195                        
  1196                        ; NEGATE ( n1 -- n2 )
  1197                        ;
  1198                        ; Negate n1, giving its arithmetic inverse n2.
  1199                        
  1200 00:0A29: 1C 0A 00 06                  HEADER  6,"NEGATE",NORMAL
  Mon Apr 18 2016 23:59                                                                                                    Page 26


       00:0A2D: 4E 45 47 41 
       00:0A31: 54 45 
  1201                        NEGATE:
  1202 00:0A33: 38                           sec                             ; Negate the top of stack
  1203 00:0A34: A9 00 00                     lda     #0
  1204 00:0A37: E5 01                        sbc     <1
  1205 00:0A39: 85 01                        sta     <1
  1206 00:0A3B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A3F: 00 00 
  1207                        
  1208                        ; UMAX ( x1 x2 -- x1|x2 )
  1209                        
  1210 00:0A41: 2C 0A 00 04                  HEADER  4,"UMAX",NORMAL
       00:0A45: 55 4D 41 58 
  1211                        UMAX:
  1212 00:0A49: A5 01                        lda     <1                      ; Compare the top values
  1213 00:0A4B: C5 03                        cmp     <3
  1214 00:0A4D: B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
  1215 00:0A4F: 4C 6F 07                     jmp     DROP                    ; No, x1 is
  1216 00:0A52: 4C 95 07     UMAX_EXIT:      jmp     NIP
  1217                        
  1218                        ; UMIN ( x1 x2 -- x1|x2 )
  1219                        
  1220 00:0A55: 44 0A 00 04                  HEADER  4,"UMIN",NORMAL
       00:0A59: 55 4D 49 4E 
  1221                        UMIN:
  1222 00:0A5D: A5 01                        lda     <1                      ; Compare the top values
  1223 00:0A5F: C5 03                        cmp     <3
  1224 00:0A61: 90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
  1225 00:0A63: 4C 6F 07                     jmp     DROP                    ; No, x1 is
  1226 00:0A66: 4C 95 07     UMIN_EXIT:      jmp     NIP
  1227                        
  1228                        ;===============================================================================
  1229                        ; Double Precision Arithmetic
  1230                        ;-------------------------------------------------------------------------------
  1231                        
  1232                        ; ?DNEGATE
  1233                        
  1234 00:0A69: 20 32 14     QUERY_DNEGATE:	jsr	DO_COLON
  1235 00:0A6C: A3 0C        		dw	ZERO_LESS
  1236 00:0A6E: C1 15 74 0A  		dw	QUERY_BRANCH,QUERY_DNEG_1
  1237 00:0A72: 83 0B        		dw	DNEGATE
  1238 00:0A74: AD 0E        QUERY_DNEG_1:	dw	EXIT		
  1239                        
  1240                        ; D+ ( d1|ud1 d2|ud2 -- d3|ud3 )
  1241                        ;
  1242                        ; Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
  1243                        
  1244 00:0A76: 58 0A 00 02                  HEADER  2,"D+",NORMAL
       00:0A7A: 44 2B 
  1245                        D_PLUS:
  1246 00:0A7C: 18                           clc
  1247 00:0A7D: A5 07                        lda     <7                      ; Add low words
  1248 00:0A7F: 65 03                        adc     <3
  1249 00:0A81: 85 07                        sta     <7
  1250 00:0A83: A5 05                        lda     <5                      ; Then the high words
  1251 00:0A85: 65 01                        adc     <1
  1252 00:0A87: 85 05                        sta     <5
  Mon Apr 18 2016 23:59                                                                                                    Page 27


  1253 00:0A89: 7B                           tdc                             ; Drop top double
  1254 00:0A8A: 1A                           inc     a
  1255 00:0A8B: 1A                           inc     a
  1256 00:0A8C: 1A                           inc     a
  1257 00:0A8D: 1A                           inc     a
  1258 00:0A8E: 5B                           tcd
  1259 00:0A8F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A93: 00 00 
  1260                        
  1261                        ; D- ( d1|ud1 d2|ud2 -- d3|ud3 )
  1262                        ;
  1263                        ; Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
  1264                        
  1265 00:0A95: 79 0A 00 02                  HEADER  2,"D-",NORMAL
       00:0A99: 44 2D 
  1266                        D_MINUS:
  1267 00:0A9B: 38                           sec
  1268 00:0A9C: A5 07                        lda     <7                      ; Subtract low words
  1269 00:0A9E: E5 03                        sbc     <3
  1270 00:0AA0: 85 07                        sta     <7
  1271 00:0AA2: A5 05                        lda     <5                      ; Then the high words
  1272 00:0AA4: E5 01                        sbc     <1
  1273 00:0AA6: 85 05                        sta     <5
  1274 00:0AA8: 7B                           tdc                             ; Drop top double
  1275 00:0AA9: 1A                           inc     a
  1276 00:0AAA: 1A                           inc     a
  1277 00:0AAB: 1A                           inc     a
  1278 00:0AAC: 1A                           inc     a
  1279 00:0AAD: 5B                           tcd
  1280 00:0AAE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0AB2: 00 00 
  1281                        
  1282                        ; D0<
  1283                        
  1284 00:0AB4: 98 0A 00 03  		HEADER	3,"D0<",NORMAL
       00:0AB8: 44 30 3C 
  1285                        D_ZERO_LESS:
  1286 00:0ABB: A6 01        		ldx	<1			; Fetch sign
  1287 00:0ABD: 7B           		tdc				; Drop a word
  1288 00:0ABE: 1A           		inc	a
  1289 00:0ABF: 1A           		inc	a
  1290 00:0AC0: 5B           		tcd
  1291 00:0AC1: 64 00        		stz	<0			; Assume false
  1292 00:0AC3: 8A           		txa
  1293 00:0AC4: 10 02        		bpl	D_ZERO_LESS_1
  1294 00:0AC6: C6 00        		dec	<0
  1295 00:0AC8: BB C8 C8 7C  D_ZERO_LESS_1:	CONTINUE
       00:0ACC: 00 00 
  1296                        
  1297                        ; D0=
  1298                        
  1299 00:0ACE: B7 0A 00 03  		HEADER	3,"D0=",NORMAL
       00:0AD2: 44 30 3D 
  1300                        D_ZERO_EQUAL:
  1301 00:0AD5: A6 01        		ldx	<1			; Fetch sign
  1302 00:0AD7: 7B           		tdc				; Drop a word
  1303 00:0AD8: 1A           		inc	a
  1304 00:0AD9: 1A           		inc	a
  Mon Apr 18 2016 23:59                                                                                                    Page 28


  1305 00:0ADA: 5B           		tcd
  1306 00:0ADB: 64 00        		stz	<0			; Assume false
  1307 00:0ADD: 8A           		txa
  1308 00:0ADE: D0 02        		bne	D_ZERO_EQUAL_1
  1309 00:0AE0: C6 00        		dec	<0
  1310 00:0AE2: BB C8 C8 7C  D_ZERO_EQUAL_1:	CONTINUE
       00:0AE6: 00 00 
  1311                        		
  1312                        ; D2* ( xd1 -- xd2 )
  1313                        ;
  1314                        ; xd2 is the result of shifting xd1 one bit toward the most-significant bit,
  1315                        ; filling the vacated least-significant bit with zero.
  1316                        
  1317 00:0AE8: D1 0A 00 03                  HEADER  3,"D2*",NORMAL
       00:0AEC: 44 32 2A 
  1318                        D_TWO_STAR:
  1319 00:0AEF: 06 03                        asl     <3
  1320 00:0AF1: 26 01                        rol     <1
  1321 00:0AF3: BB C8 C8 7C                  CONTINUE
       00:0AF7: 00 00 
  1322                        
  1323                        ; D2/ ( xd1 -- xd2 )
  1324                        ;
  1325                        ; xd2 is the result of shifting xd1 one bit toward the least-significant bit,
  1326                        ; leaving the most-significant bit unchanged.
  1327                        
  1328 00:0AF9: EB 0A 00 03                  HEADER  3,"D2/",NORMAL
       00:0AFD: 44 32 2F 
  1329                        D_TWO_SLASH:
  1330 00:0B00: A5 01                        lda     <1
  1331 00:0B02: 2A                           rol     a
  1332 00:0B03: 66 01                        ror     <1
  1333 00:0B05: 66 03                        ror     <3
  1334 00:0B07: BB C8 C8 7C                  CONTINUE
       00:0B0B: 00 00 
  1335                        
  1336                        ; D<
  1337                        
  1338 00:0B0D: FC 0A 00 02  		HEADER	2,"D<",NORMAL
       00:0B11: 44 3C 
  1339 00:0B13: 20 32 14     D_LESS:		jsr	DO_COLON
  1340 00:0B16: 9B 0A        		dw	D_MINUS
  1341 00:0B18: BB 0A        		dw	D_ZERO_LESS
  1342 00:0B1A: AD 0E        		dw	EXIT
  1343                        
  1344                        ; D=
  1345                        
  1346 00:0B1C: 10 0B 00 02  		HEADER	2,"D=",NORMAL
       00:0B20: 44 3D 
  1347 00:0B22: 20 32 14     D_EQUAL:	jsr	DO_COLON
  1348 00:0B25: 9B 0A        		dw	D_MINUS
  1349 00:0B27: D5 0A        		dw	D_ZERO_EQUAL
  1350 00:0B29: AD 0E        		dw	EXIT
  1351                        		
  1352                        ; DABS
  1353                        
  1354 00:0B2B: 1F 0B 00 04  		HEADER	4,"DABS",NORMAL
       00:0B2F: 44 41 42 53 
  Mon Apr 18 2016 23:59                                                                                                    Page 29


  1355                        DABS:
  1356 00:0B33: A5 01        		lda	<1
  1357 00:0B35: 10 03        		bpl	DABS_1
  1358 00:0B37: 4C 83 0B     		jmp	DNEGATE
  1359 00:0B3A: BB C8 C8 7C  DABS_1:		CONTINUE
       00:0B3E: 00 00 
  1360                        
  1361                        ; DMAX
  1362                        
  1363 00:0B40: 2E 0B 00 04  		HEADER	4,"DMAX",NORMAL
       00:0B44: 44 4D 41 58 
  1364 00:0B48: 20 32 14     DMAX:		jsr	DO_COLON
  1365 00:0B4B: D7 06        		dw	TWO_OVER
  1366 00:0B4D: D7 06        		dw	TWO_OVER
  1367 00:0B4F: 13 0B        		dw	D_LESS
  1368 00:0B51: C1 15 57 0B  		dw	QUERY_BRANCH,DMAX_1
  1369 00:0B55: 21 07        		dw	TWO_SWAP
  1370 00:0B57: A6 06        DMAX_1:		dw	TWO_DROP
  1371 00:0B59: AD 0E        		dw	EXIT
  1372                        
  1373                        ; DMIN
  1374                        
  1375 00:0B5B: 43 0B 00 04  		HEADER	4,"DMIN",NORMAL
       00:0B5F: 44 4D 49 4E 
  1376 00:0B63: 20 32 14     DMIN:		jsr	DO_COLON
  1377 00:0B66: D7 06        		dw	TWO_OVER
  1378 00:0B68: D7 06        		dw	TWO_OVER
  1379 00:0B6A: 13 0B        		dw	D_LESS
  1380 00:0B6C: 9E 0D        		dw	INVERT
  1381 00:0B6E: C1 15 74 0B  		dw	QUERY_BRANCH,DMIN_1
  1382 00:0B72: 21 07        		dw	TWO_SWAP
  1383 00:0B74: A6 06        DMIN_1:		dw	TWO_DROP
  1384 00:0B76: AD 0E        		dw	EXIT
  1385                        
  1386                        ; DNEGATE ( d1 -- d2 )
  1387                        ;
  1388                        ; d2 is the negation of d1.
  1389                        
  1390 00:0B78: 5E 0B 00 07                  HEADER  7,"DNEGATE",NORMAL
       00:0B7C: 44 4E 45 47 
       00:0B80: 41 54 45 
  1391                        DNEGATE:
  1392 00:0B83: 38                           sec
  1393 00:0B84: A9 00 00                     lda     #0                      ; Subtract low word from zero
  1394 00:0B87: E5 03                        sbc     <3
  1395 00:0B89: 85 03                        sta     <3
  1396 00:0B8B: A9 00 00                     lda     #0                      ; Then the high word
  1397 00:0B8E: E5 01                        sbc     <1
  1398 00:0B90: 85 01                        sta     <1
  1399 00:0B92: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0B96: 00 00 
  1400                        
  1401                        ;===============================================================================
  1402                        ; Mixed Arithmetic
  1403                        ;-------------------------------------------------------------------------------
  1404                        
  1405                        ; D>S ( d -- n )
  1406                        ;
  Mon Apr 18 2016 23:59                                                                                                    Page 30


  1407                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1408                        ; range of a signed single-cell number.
  1409                        
  1410 00:0B98: 7B 0B 00 03                  HEADER  3,"D>S",NORMAL
       00:0B9C: 44 3E 53 
  1411                        D_TO_S:
  1412 00:0B9F: 7B                           tdc
  1413 00:0BA0: 1A                           inc     a                       ; Drop the high word
  1414 00:0BA1: 1A                           inc     a
  1415 00:0BA2: 5B                           tcd
  1416 00:0BA3: BB C8 C8 7C                  CONTINUE
       00:0BA7: 00 00 
  1417                        
  1418                        ; M*
  1419                        ;
  1420                        ;   2DUP XOR >R	carries sign of the result
  1421                        ;   SWAP ABS SWAP ABS UM*
  1422                        ;   R> ?DNEGATE
  1423                        
  1424 00:0BA9: 9B 0B 00 02  		HEADER	2,"M*",NORMAL
       00:0BAD: 4D 2A 
  1425 00:0BAF: 20 32 14     M_STAR:		jsr	DO_COLON
  1426 00:0BB2: BA 06        		dw	TWO_DUP
  1427 00:0BB4: 20 0E        		dw	XOR
  1428 00:0BB6: 68 08        		dw	TO_R
  1429 00:0BB8: F6 07        		dw	SWAP
  1430 00:0BBA: 93 09        		dw	ABS
  1431 00:0BBC: F6 07        		dw	SWAP
  1432 00:0BBE: 93 09        		dw	ABS
  1433 00:0BC0: 50 0C        		dw	UM_STAR
  1434 00:0BC2: A1 08        		dw	R_FROM
  1435 00:0BC4: 69 0A        		dw	QUERY_DNEGATE
  1436 00:0BC6: AD 0E        		dw	EXIT
  1437                        		
  1438                        ; M*/
  1439                        
  1440                        
  1441                        
  1442                        
  1443                        
  1444                        ; M+ ( d1|ud1 n -- d2|ud2 )
  1445                        ;
  1446                        ; Add n to d1|ud1, giving the sum d2|ud2.
  1447                        
  1448 00:0BC8: AC 0B 00 02                  HEADER  2,"M+",NORMAL
       00:0BCC: 4D 2B 
  1449                        M_PLUS:
  1450 00:0BCE: 18                           clc
  1451 00:0BCF: A5 01                        lda     <1
  1452 00:0BD1: 65 05                        adc     <5
  1453 00:0BD3: 85 05                        sta     <5
  1454 00:0BD5: 90 02                        bcc     $+4
  1455 00:0BD7: E6 03                        inc     <3
  1456 00:0BD9: 7B                           tdc
  1457 00:0BDA: 1A                           inc     a
  1458 00:0BDB: 1A                           inc     a
  1459 00:0BDC: 5B                           tcd
  1460 00:0BDD: BB C8 C8 7C                  CONTINUE
  Mon Apr 18 2016 23:59                                                                                                    Page 31


       00:0BE1: 00 00 
  1461                        
  1462                        ; S>D ( n -- d )
  1463                        ;
  1464                        ; Convert the number n to the double-cell number d with the same numerical
  1465                        ; value.
  1466                        
  1467 00:0BE3: CB 0B 00 03                  HEADER  3,"S>D",NORMAL
       00:0BE7: 53 3E 44 
  1468                        S_TO_D:
  1469 00:0BEA: 7B                           tdc
  1470 00:0BEB: 3A                           dec     a                       ; Assume n is positive
  1471 00:0BEC: 3A                           dec     a
  1472 00:0BED: 5B                           tcd
  1473 00:0BEE: 64 01                        stz     <1                      ; .. push a zero value
  1474 00:0BF0: A5 03                        lda     <3                      ; Test the number
  1475 00:0BF2: 10 02                        bpl     S_TO_D_1
  1476 00:0BF4: C6 01                        dec     <1                      ; Make top -1 if negative
  1477 00:0BF6: BB C8 C8 7C  S_TO_D_1        CONTINUE                        ; Done
       00:0BFA: 00 00 
  1478                        
  1479                        ; SM/REM
  1480                        ;
  1481                        ;   2DUP XOR >R			sign of quotient
  1482                        ;   OVER >R			sign of remainder
  1483                        ;   ABS >R DABS R> UM/MOD
  1484                        ;   SWAP R> ?NEGATE
  1485                        ;   SWAP R> ?NEGATE ;
  1486                        
  1487 00:0BFC: E6 0B 00 06  		HEADER	6,"SM/REM",NORMAL
       00:0C00: 53 4D 2F 52 
       00:0C04: 45 4D 
  1488 00:0C06: 20 32 14     SM_SLASH_REM:	jsr	DO_COLON
  1489 00:0C09: BA 06        		dw	TWO_DUP
  1490 00:0C0B: 20 0E        		dw	XOR
  1491 00:0C0D: 68 08        		dw	TO_R
  1492 00:0C0F: A3 07        		dw	OVER
  1493 00:0C11: 68 08        		dw	TO_R
  1494 00:0C13: 93 09        		dw	ABS
  1495 00:0C15: 68 08        		dw	TO_R
  1496 00:0C17: 33 0B        		dw	DABS
  1497 00:0C19: A1 08        		dw	R_FROM
  1498 00:0C1B: 7C 0C        		dw	UM_SLASH_MOD
  1499 00:0C1D: F6 07        		dw	SWAP
  1500 00:0C1F: A1 08        		dw	R_FROM
  1501 00:0C21: 7F 09        		dw	QUERY_NEGATE
  1502 00:0C23: F6 07        		dw	SWAP
  1503 00:0C25: A1 08        		dw	R_FROM
  1504 00:0C27: 7F 09        		dw	QUERY_NEGATE
  1505 00:0C29: AD 0E        		dw	EXIT
  1506                        
  1507                        ; UD* ( ud1 d2 -- ud3)
  1508                        ;
  1509                        ; 32*16->32 multiply
  1510                        ;
  1511                        ;   DUP >R UM* DROP  SWAP R> UM* ROT + ;
  1512                        
  1513 00:0C2B: FF 0B 00 03                  HEADER  3,"UD*",NORMAL
  Mon Apr 18 2016 23:59                                                                                                    Page 32


       00:0C2F: 55 44 2A 
  1514 00:0C32: 20 32 14     UD_STAR:        jsr     DO_COLON
  1515 00:0C35: 80 07                        dw      DUP
  1516 00:0C37: 68 08                        dw      TO_R
  1517 00:0C39: 50 0C                        dw      UM_STAR
  1518 00:0C3B: 6F 07                        dw      DROP
  1519 00:0C3D: F6 07                        dw      SWAP
  1520 00:0C3F: A1 08                        dw      R_FROM
  1521 00:0C41: 50 0C                        dw      UM_STAR
  1522 00:0C43: DC 07                        dw      ROT
  1523 00:0C45: FA 08                        dw      PLUS
  1524 00:0C47: AD 0E                        dw      EXIT
  1525                        
  1526                        ; UM* ( n1 n2 -- d )
  1527                        
  1528 00:0C49: 2E 0C 00 03                  HEADER  3,"UM*",NORMAL
       00:0C4D: 55 4D 2A 
  1529                        UM_STAR:
  1530 00:0C50: A5 01                        lda     <1                      ; Fetch multiplier
  1531 00:0C52: 48                           pha
  1532 00:0C53: 64 01                        stz     <1                      ; Clear the result
  1533 00:0C55: A2 10 00                     ldx     #16
  1534 00:0C58: A5 03        UM_STAR_1:      lda     <3                      ; Shift multiplier one bit
  1535 00:0C5A: 4A                           lsr     a
  1536 00:0C5B: 90 07                        bcc     UM_STAR_2               ; Not set, no add
  1537 00:0C5D: A3 01                        lda     1,s                     ; Fetch multiplicand
  1538 00:0C5F: 18                           clc
  1539 00:0C60: 65 01                        adc     <1
  1540 00:0C62: 85 01                        sta     <1
  1541 00:0C64: 66 01        UM_STAR_2:      ror     <1                      ; Rotate high word down
  1542 00:0C66: 66 03                        ror     <3
  1543 00:0C68: CA                           dex
  1544 00:0C69: D0 ED                        bne     UM_STAR_1
  1545 00:0C6B: 68                           pla
  1546 00:0C6C: BB C8 C8 7C                  CONTINUE   			; Done
       00:0C70: 00 00 
  1547                        
  1548                        ; UM/MOD ( ud u1 -- u2 u3 )
  1549                        ;
  1550                        ; Divide ud by u1, giving the quotient u3 and the remainder u2. All values and
  1551                        ; arithmetic are unsigned. An ambiguous condition exists if u1 is zero or if the
  1552                        ; quotient lies outside the range of a single-cell unsigned integer.
  1553                        
  1554 00:0C72: 4C 0C 00 06  		HEADER	6,"UM/MOD",NORMAL
       00:0C76: 55 4D 2F 4D 
       00:0C7A: 4F 44 
  1555                        UM_SLASH_MOD:
  1556 00:0C7C: A2 10 00     		ldx	#16
  1557 00:0C7F: 06 03        UM_SLASH_MOD_1:	asl	<3
  1558 00:0C81: 26 05        		rol	<5
  1559 00:0C83: 38           		sec
  1560 00:0C84: A5 05        		lda	<5
  1561 00:0C86: E5 01        		sbc	<1
  1562 00:0C88: F0 02        		beq	UM_SLASH_MOD_2
  1563 00:0C8A: 90 04        		bcc	UM_SLASH_MOD_3
  1564 00:0C8C: 85 05        UM_SLASH_MOD_2:	sta	<5
  1565 00:0C8E: E6 03        		inc	<3
  1566 00:0C90: CA           UM_SLASH_MOD_3:	dex
  Mon Apr 18 2016 23:59                                                                                                    Page 33


  1567 00:0C91: D0 EC        		bne	UM_SLASH_MOD_1
  1568 00:0C93: 7B           		tdc
  1569 00:0C94: 1A           		inc	a
  1570 00:0C95: 1A           		inc	a
  1571 00:0C96: 5B           		tcd
  1572 00:0C97: BB C8 C8 7C  		CONTINUE
       00:0C9B: 00 00 
  1573                        		
  1574                        ;===============================================================================
  1575                        ; Comparisons
  1576                        ;-------------------------------------------------------------------------------
  1577                        
  1578                        ; 0< ( n -- flag )
  1579                        ;
  1580                        ; flag is true if and only if n is less than zero.
  1581                        
  1582 00:0C9D: 75 0C 00 02                  HEADER  2,"0<",NORMAL
       00:0CA1: 30 3C 
  1583                        ZERO_LESS:
  1584 00:0CA3: A5 01                        lda     <1                      ; Test top of stack
  1585 00:0CA5: 64 01                        stz     <1                      ; Assume false result
  1586 00:0CA7: 10 02                        bpl     ZERO_LT_1               ; Was the value negative?
  1587 00:0CA9: C6 01                        dec     <1                      ; Yes, make true result
  1588 00:0CAB: BB C8 C8 7C  ZERO_LT_1:      CONTINUE                        ; Done
       00:0CAF: 00 00 
  1589                        
  1590                        ; 0<> ( x -- flag )
  1591                        ;
  1592                        ; flag is true if and only if x is not equal to zero.
  1593                        
  1594 00:0CB1: A0 0C 00 03                  HEADER  3,"0<>",NORMAL
       00:0CB5: 30 3C 3E 
  1595                        ZERO_NOT_EQUAL:
  1596 00:0CB8: A5 01                        lda     <1                      ; Test top of stack
  1597 00:0CBA: 64 01                        stz     <1                      ; Assume false result
  1598 00:0CBC: F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
  1599 00:0CBE: C6 01                        dec     <1                      ; Yes, make true result
  1600 00:0CC0: BB C8 C8 7C  ZERO_NE_1:      CONTINUE                        ; Done
       00:0CC4: 00 00 
  1601                        
  1602                        ; 0= ( x -- flag )
  1603                        ;
  1604                        ; flag is true if and only if x is equal to zero.
  1605                        
  1606 00:0CC6: B4 0C 00 02                  HEADER  2,"0=",NORMAL
       00:0CCA: 30 3D 
  1607                        ZERO_EQUAL:
  1608 00:0CCC: A5 01                        lda     <1                      ; Test top of stack
  1609 00:0CCE: 64 01                        stz     <1                      ; Assume false result
  1610 00:0CD0: D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
  1611 00:0CD2: C6 01                        dec     <1                      ; Yes, make true result
  1612 00:0CD4: BB C8 C8 7C  ZERO_EQ_1:      CONTINUE                        ; Done
       00:0CD8: 00 00 
  1613                        
  1614                        ; 0> ( n -- flag )
  1615                        ;
  1616                        ; flag is true if and only if n is greater than zero.
  1617                        
  Mon Apr 18 2016 23:59                                                                                                    Page 34


  1618 00:0CDA: C9 0C 00 02                  HEADER  2,"0>",NORMAL
       00:0CDE: 30 3E 
  1619                        ZERO_GREATER:
  1620 00:0CE0: A5 01                        lda     <1                      ; Test top of stack
  1621 00:0CE2: 64 01                        stz     <1                      ; Assume false result
  1622 00:0CE4: 30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
  1623 00:0CE6: F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
  1624 00:0CE8: C6 01                        dec     <1                      ; Yes, make true result
  1625 00:0CEA: BB C8 C8 7C  ZERO_GT_EXIT:   CONTINUE                        ; Done
       00:0CEE: 00 00 
  1626                        
  1627                        ; <
  1628                        
  1629 00:0CF0: DD 0C 00 01                  HEADER  1,"<",NORMAL
       00:0CF4: 3C 
  1630                        LESS:
  1631 00:0CF5: A6 01                        ldx     <1                      ; Pull x2 from stack
  1632 00:0CF7: 7B                           tdc
  1633 00:0CF8: 1A                           inc     a
  1634 00:0CF9: 1A                           inc     a
  1635 00:0CFA: 5B                           tcd
  1636 00:0CFB: 8A                           txa
  1637 00:0CFC: 38                           sec                             ; Compare with x1
  1638 00:0CFD: E5 01                        sbc     <1
  1639 00:0CFF: 64 01                        stz     <1                      ; Assume false result
  1640 00:0D01: 70 04                        bvs     LESS_1
  1641 00:0D03: 10 04                        bpl     LESS_2                  ; V == 0 && N == 0
  1642 00:0D05: 80 04                        bra     LESS_3
  1643 00:0D07: 10 02        LESS_1:         bpl     LESS_3                  ; V == 1 && N == 1
  1644 00:0D09: C6 01        LESS_2:         dec     <1
  1645 00:0D0B: BB C8 C8 7C  LESS_3:         CONTINUE
       00:0D0F: 00 00 
  1646                        
  1647                        ; <>
  1648                        
  1649 00:0D11: F3 0C 00 02                  HEADER  2,"<>",NORMAL
       00:0D15: 3C 3E 
  1650                        NOT_EQUAL:
  1651 00:0D17: A6 01                        ldx     <1                      ; Pull x2 from stack
  1652 00:0D19: 7B                           tdc
  1653 00:0D1A: 1A                           inc     a
  1654 00:0D1B: 1A                           inc     a
  1655 00:0D1C: 5B                           tcd
  1656 00:0D1D: E4 01                        cpx     <1                      ; Compare with x1
  1657 00:0D1F: 64 01                        stz     <1                      ; Assume equal
  1658 00:0D21: F0 02                        beq     NE_EXIT                 ; Test flags
  1659 00:0D23: C6 01                        dec     <1                      ; Make result true
  1660 00:0D25: BB C8 C8 7C  NE_EXIT:        CONTINUE                        ; Done
       00:0D29: 00 00 
  1661                        
  1662                        ; = ( x1 x2 -- flag )
  1663                        ;
  1664                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  1665                        
  1666 00:0D2B: 14 0D 00 01                  HEADER  1,"=",NORMAL
       00:0D2F: 3D 
  1667                        EQUAL:
  1668 00:0D30: A6 01                        ldx     <1                      ; Pull x2 from stack
  Mon Apr 18 2016 23:59                                                                                                    Page 35


  1669 00:0D32: 7B                           tdc
  1670 00:0D33: 1A                           inc     a
  1671 00:0D34: 1A                           inc     a
  1672 00:0D35: 5B                           tcd
  1673 00:0D36: E4 01                        cpx     <1                      ; Compare with x1
  1674 00:0D38: 64 01                        stz     <1                      ; Assume not equal
  1675 00:0D3A: D0 02                        bne     EQ_EXIT                 ; Test the flags
  1676 00:0D3C: C6 01                        dec     <1                      ; Make result true
  1677 00:0D3E: BB C8 C8 7C  EQ_EXIT:        CONTINUE                        ; Done
       00:0D42: 00 00 
  1678                        
  1679                        ; >
  1680                        
  1681 00:0D44: 2E 0D 00 01                  HEADER  1,">",NORMAL
       00:0D48: 3E 
  1682 00:0D49: 20 32 14     GREATER:        jsr     DO_COLON
  1683 00:0D4C: F6 07                        dw      SWAP
  1684 00:0D4E: F5 0C                        dw      LESS
  1685 00:0D50: AD 0E                        dw      EXIT
  1686                        
  1687                        ; U<
  1688                        
  1689 00:0D52: 47 0D 00 02                  HEADER  2,"U<",NORMAL
       00:0D56: 55 3C 
  1690                        U_LESS:
  1691 00:0D58: A6 01                        ldx     <1                      ; Pull x2
  1692 00:0D5A: 7B                           tdc                             ; Drop from stack
  1693 00:0D5B: 1A                           inc     a
  1694 00:0D5C: 1A                           inc     a
  1695 00:0D5D: 5B                           tcd
  1696 00:0D5E: E4 01                        cpx     <1                      ; Compare with x1
  1697 00:0D60: 64 01                        stz     <1                      ; Assume false
  1698 00:0D62: F0 04                        beq     U_LESS_1                ; Equal
  1699 00:0D64: 90 02                        bcc     U_LESS_1                ; Less
  1700 00:0D66: C6 01                        dec     <1
  1701 00:0D68: BB C8 C8 7C  U_LESS_1:       CONTINUE
       00:0D6C: 00 00 
  1702                        
  1703                        ; U>
  1704                        
  1705 00:0D6E: 55 0D 00 02                  HEADER  2,"U>",NORMAL
       00:0D72: 55 3E 
  1706 00:0D74: 20 32 14     U_GREATER:      jsr     DO_COLON
  1707 00:0D77: F6 07                        dw      SWAP
  1708 00:0D79: 58 0D                        dw      U_LESS
  1709 00:0D7B: AD 0E                        dw      EXIT
  1710                        
  1711                        ;===============================================================================
  1712                        ; Logical Operations
  1713                        ;-------------------------------------------------------------------------------
  1714                        
  1715                        ; AND ( x1 x2 -- x3 )
  1716                        ;
  1717                        ; x3 is the bit-by-bit logical and of x1 with x2.
  1718                        
  1719 00:0D7D: 71 0D 00 03                  HEADER  3,"AND",NORMAL
       00:0D81: 41 4E 44 
  1720                        AND:
  Mon Apr 18 2016 23:59                                                                                                    Page 36


  1721 00:0D84: A5 01                        lda     <1
  1722 00:0D86: 25 03                        and     <3
  1723 00:0D88: 85 03                        sta     <3
  1724 00:0D8A: 7B                           tdc
  1725 00:0D8B: 1A                           inc     a
  1726 00:0D8C: 1A                           inc     a
  1727 00:0D8D: 5B                           tcd
  1728 00:0D8E: BB C8 C8 7C                  CONTINUE
       00:0D92: 00 00 
  1729                        
  1730                        ; INVERT ( x1 -- x2 )
  1731                        ;
  1732                        ; Invert all bits of x1, giving its logical inverse x2.
  1733                        
  1734 00:0D94: 80 0D 00 06                  HEADER  6,"INVERT",NORMAL
       00:0D98: 49 4E 56 45 
       00:0D9C: 52 54 
  1735                        INVERT:
  1736 00:0D9E: A5 01                        lda     <1                      ; Fetch top value
  1737 00:0DA0: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1738 00:0DA3: 85 01                        sta     <1                      ; .. and write back
  1739 00:0DA5: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0DA9: 00 00 
  1740                        
  1741                        ; LSHIFT ( x1 u -- x2 )
  1742                        ;
  1743                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1744                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1745                        ; exists if u is greater than or equal to the number of bits in a cell.
  1746                        
  1747 00:0DAB: 97 0D 00 06                  HEADER  6,"LSHIFT",NORMAL
       00:0DAF: 4C 53 48 49 
       00:0DB3: 46 54 
  1748                        LSHIFT:
  1749 00:0DB5: A6 01                        ldx     <1                      ; Pull bit count
  1750 00:0DB7: 08                           php
  1751 00:0DB8: 7B                           tdc
  1752 00:0DB9: 1A                           inc     a                       ; .. from the stack
  1753 00:0DBA: 1A                           inc     a
  1754 00:0DBB: 5B                           tcd
  1755 00:0DBC: 28                           plp
  1756 00:0DBD: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1757 00:0DBF: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1758 00:0DC2: B0 0B                        bcs     LSHIFT_2                ; Yes, result will be zero
  1759 00:0DC4: 06 01        LSHIFT_1        asl     <1                      ; Shift one bit left
  1760 00:0DC6: CA                           dex                             ; Update count
  1761 00:0DC7: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  1762 00:0DC9: BB C8 C8 7C  LSHIFT_0        CONTINUE                        ; Done
       00:0DCD: 00 00 
  1763 00:0DCF: 64 01        LSHIFT_2        stz     <1                      ; Clear top value
  1764 00:0DD1: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0DD5: 00 00 
  1765                        
  1766                        ; OR ( x1 x2 -- x3 )
  1767                        ;
  1768                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1769                        
  1770 00:0DD7: AE 0D 00 02                  HEADER  2,"OR",NORMAL
  Mon Apr 18 2016 23:59                                                                                                    Page 37


       00:0DDB: 4F 52 
  1771                        OR:
  1772 00:0DDD: A5 01                        lda     <1
  1773 00:0DDF: 05 03                        ora     <3
  1774 00:0DE1: 85 03                        sta     <3
  1775 00:0DE3: 7B                           tdc
  1776 00:0DE4: 1A                           inc     a
  1777 00:0DE5: 1A                           inc     a
  1778 00:0DE6: 5B                           tcd
  1779 00:0DE7: BB C8 C8 7C                  CONTINUE
       00:0DEB: 00 00 
  1780                        
  1781                        ; RSHIFT ( x1 u -- x2 )
  1782                        ;
  1783                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1784                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1785                        ; exists if u is greater than or equal to the number of bits in a cell.
  1786                        
  1787 00:0DED: DA 0D 00 06                  HEADER  6,"RSHIFT",NORMAL
       00:0DF1: 52 53 48 49 
       00:0DF5: 46 54 
  1788                        RSHIFT:
  1789 00:0DF7: A6 01                        ldx     <1                      ; Pull bit count
  1790 00:0DF9: 08                           php
  1791 00:0DFA: 7B                           tdc
  1792 00:0DFB: 1A                           inc     a                       ; .. from the stack
  1793 00:0DFC: 1A                           inc     a
  1794 00:0DFD: 5B                           tcd
  1795 00:0DFE: 28                           plp
  1796 00:0DFF: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1797 00:0E01: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1798 00:0E04: B0 0B                        bcs     RSHIFT_2                ; Yes, result will be zero
  1799 00:0E06: 46 01        RSHIFT_1        lsr     <1                      ; Shift one bit left
  1800 00:0E08: CA                           dex                             ; Update count
  1801 00:0E09: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1802 00:0E0B: BB C8 C8 7C  RSHIFT_0        CONTINUE                        ; Done
       00:0E0F: 00 00 
  1803 00:0E11: 64 01        RSHIFT_2        stz     <1                      ; Clear top value
  1804 00:0E13: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0E17: 00 00 
  1805                        
  1806                        ; XOR ( x1 x2 -- x3 )
  1807                        ;
  1808                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1809                        
  1810 00:0E19: F0 0D 00 03                  HEADER  3,"XOR",NORMAL
       00:0E1D: 58 4F 52 
  1811                        XOR:
  1812 00:0E20: A5 01                        lda     <1
  1813 00:0E22: 45 03                        eor     <3
  1814 00:0E24: 85 03                        sta     <3
  1815 00:0E26: 7B                           tdc
  1816 00:0E27: 1A                           inc     a
  1817 00:0E28: 1A                           inc     a
  1818 00:0E29: 5B                           tcd
  1819 00:0E2A: BB C8 C8 7C                  CONTINUE
       00:0E2E: 00 00 
  1820                        
  Mon Apr 18 2016 23:59                                                                                                    Page 38


  1821                        ;===============================================================================
  1822                        ; Control Words
  1823                        ;-------------------------------------------------------------------------------
  1824                        
  1825                        ; ?ABORT
  1826                        ;
  1827                        ;   ROT IF TYPE ABORT THEN 2DROP ;
  1828                        
  1829 00:0E30: 20 32 14     QUERY_ABORT:	jsr	DO_COLON
  1830 00:0E33: DC 07        		dw	ROT
  1831 00:0E35: C1 15 3D 0E  		dw	QUERY_BRANCH,QUERY_ABORT_1
  1832 00:0E39: 34 18        		dw	TYPE
  1833 00:0E3B: 4A 0E        		dw	ABORT
  1834 00:0E3D: A6 06        QUERY_ABORT_1:	dw	TWO_DROP
  1835 00:0E3F: AD 0E        		dw	EXIT
  1836                        
  1837                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1838                        ;
  1839                        ; Empty the data stack and perform the function of QUIT, which includes
  1840                        ; emptying the return stack, without displaying a message.
  1841                        
  1842 00:0E41: 1C 0E 00 05                  HEADER  5,"ABORT",NORMAL
       00:0E45: 41 42 4F 52 
       00:0E49: 54 
  1843 00:0E4A: 20 32 14     ABORT:          jsr     DO_COLON
  1844 00:0E4D: 51 0E                        dw      DO_ABORT
  1845 00:0E4F: BC 0E                        dw      QUIT
  1846                        
  1847                        DO_ABORT:
  1848 00:0E51: A9 7F 01                     lda     #DSTACK_END-1
  1849 00:0E54: 5B                           tcd
  1850 00:0E55: BB C8 C8 7C                  CONTINUE
       00:0E59: 00 00 
  1851                        
  1852                        ; (BUILD) ( dtc-addr -- )
  1853                        ;
  1854                        ; Adds a jump the to exection function for the new word.
  1855                        
  1856                        ;               HEADER  7,"(BUILD)",NORMAL
  1857 00:0E5B: 20 32 14     BUILD:          jsr     DO_COLON
  1858 00:0E5E: 08 16 20 00                  dw      DO_LITERAL,$20
  1859 00:0E62: F0 05                        dw      C_COMMA
  1860 00:0E64: 74 05                        dw      COMMA
  1861 00:0E66: AD 0E                        dw      EXIT
  1862                        
  1863                        ; CREATE ( -- ) [TODO]
  1864                        ;
  1865                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1866                        ; definition for name with the execution semantics defined below. If the data-
  1867                        ; space pointer is not aligned, reserve enough data space to align it. The new
  1868                        ; data-space pointer defines names data field. CREATE does not allocate data
  1869                        ; space in names data field.
  1870                        
  1871 00:0E68: 44 0E 00 06                  HEADER  6,"CREATE",NORMAL
       00:0E6C: 43 52 45 41 
       00:0E70: 54 45 
  1872 00:0E72: 20 32 14     CREATE:         jsr     DO_COLON
  1873 00:0E75: 8F 04                        dw      LATEST
  Mon Apr 18 2016 23:59                                                                                                    Page 39


  1874 00:0E77: B4 05                        dw      FETCH
  1875 00:0E79: 74 05                        dw      COMMA
  1876 00:0E7B: C9 04                        dw      ZERO
  1877 00:0E7D: F0 05                        dw      C_COMMA
  1878 00:0E7F: 1F 06                        dw      HERE
  1879 00:0E81: 8F 04                        dw      LATEST
  1880 00:0E83: 46 05                        dw      STORE
  1881 00:0E85: DB 04                        dw      BL
  1882 00:0E87: 7B 12                        dw      WORD
  1883 00:0E89: 07 06                        dw      C_FETCH
  1884 00:0E8B: 4A 09                        dw      ONE_PLUS
  1885 00:0E8D: C7 05                        dw      ALLOT
  1886 00:0E8F: AD 0E                        dw      EXIT
  1887                        
  1888                        ; EXECUTE ( i*x xt -- j*x )
  1889                        ;
  1890                        ; Remove xt from the stack and perform the semantics identified by it. Other
  1891                        ; stack effects are due to the word EXECUTEd.
  1892                        
  1893 00:0E91: 6B 0E 00 07                  HEADER  7,"EXECUTE",NORMAL
       00:0E95: 45 58 45 43 
       00:0E99: 55 54 45 
  1894                        EXECUTE:
  1895 00:0E9C: A6 01                        ldx     <1
  1896 00:0E9E: 7B                           tdc
  1897 00:0E9F: 1A                           inc     a
  1898 00:0EA0: 1A                           inc     a
  1899 00:0EA1: 5B                           tcd
  1900 00:0EA2: CA                           dex
  1901 00:0EA3: DA                           phx
  1902 00:0EA4: 60                           rts
  1903                        
  1904                        ; EXIT ( -- ) ( R: nest-sys -- )
  1905                        ;
  1906                        ; Return control to the calling definition specified by nest-sys. Before
  1907                        ; executing EXIT within a do-loop, a program shall discard the loop-control
  1908                        ; parameters by executing UNLOOP.
  1909                        
  1910 00:0EA5: 94 0E 00 04                  HEADER  4,"EXIT",NORMAL
       00:0EA9: 45 58 49 54 
  1911                        EXIT:
  1912 00:0EAD: 7A                           ply
  1913 00:0EAE: BB C8 C8 7C                  CONTINUE
       00:0EB2: 00 00 
  1914                        
  1915                        ; QUIT ( -- ) ( R: i*x -- )
  1916                        ;
  1917                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  1918                        ; user input device the input source, and enter interpretation state. Do not
  1919                        ; display a message. Repeat the following:
  1920                        ;  Accept a line from the input source into the input buffer, set >IN to zero,
  1921                        ;   and interpret.
  1922                        ;  Display the implementation-defined system prompt if in interpretation state,
  1923                        ;   all processing has been completed, and no ambiguous condition exists.
  1924                        ;
  1925                        ; In this implementation it is defined as:
  1926                        ;
  1927                        ;   DO_QUIT 0 STATE !
  Mon Apr 18 2016 23:59                                                                                                    Page 40


  1928                        ;   0 (SOURCE-ID) !
  1929                        ;   BEGIN
  1930                        ;     REFILL
  1931                        ;     WHILE SOURCE EVALUATE
  1932                        ;     STATE @ 0= IF S" Ok" CR TYPE THEN
  1933                        ;   AGAIN ;
  1934                        
  1935 00:0EB4: A8 0E 00 04                  HEADER  4,"QUIT",NORMAL
       00:0EB8: 51 55 49 54 
  1936 00:0EBC: 20 32 14     QUIT:           jsr     DO_COLON
  1937 00:0EBF: EC 0E                        dw      DO_QUIT
  1938 00:0EC1: C9 04                        dw      ZERO
  1939 00:0EC3: B3 04                        dw      STATE
  1940 00:0EC5: 46 05                        dw      STORE
  1941 00:0EC7: C9 04                        dw      ZERO
  1942 00:0EC9: A5 04                        dw      SOURCEID
  1943 00:0ECB: 46 05                        dw      STORE
  1944 00:0ECD: 76 11        QUIT_1:         dw      REFILL
  1945 00:0ECF: C1 15 D5 0E                  dw      QUERY_BRANCH,QUIT_2
  1946 00:0ED3: AD 10                        dw      INTERPRET
  1947 00:0ED5: B3 04        QUIT_2:         dw      STATE
  1948 00:0ED7: B4 05                        dw      FETCH
  1949 00:0ED9: CC 0C                        dw      ZERO_EQUAL
  1950 00:0EDB: C1 15 E8 0E                  dw      QUERY_BRANCH,QUIT_3
  1951 00:0EDF: B7 16                        dw      DO_S_QUOTE
  1952 00:0EE1: 02 4F 6B                     db      2,"Ok"
  1953 00:0EE4: 34 18                        dw      TYPE
  1954 00:0EE6: B7 17                        dw      CR
  1955 00:0EE8: A0 15 CD 0E  QUIT_3:         dw      BRANCH,QUIT_1
  1956                        
  1957                        DO_QUIT:
  1958 00:0EEC: A9 FF 01                     lda     #RSTACK_END-1           ; Reset the return stack
  1959 00:0EEF: 1B                           tcs
  1960 00:0EF0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0EF4: 00 00 
  1961                        
  1962                        ;===============================================================================
  1963                        ; Parser & Interpreter
  1964                        ;-------------------------------------------------------------------------------
  1965                        
  1966                        ; ?NUMBER
  1967                        ;
  1968                        ;   DUP  0 0 ROT COUNT      -- ca ud adr n
  1969                        ;   ?SIGN >R  >NUMBER       -- ca ud adr' n'
  1970                        ;   IF   R> 2DROP 2DROP 0   -- ca 0   (error)
  1971                        ;   ELSE 2DROP NIP R>
  1972                        ;       IF NEGATE THEN  -1  -- n -1   (ok)
  1973                        ;   THEN ;
  1974                        
  1975 00:0EF6: B7 0E 00 07                  HEADER  7,"?NUMBER",NORMAL
       00:0EFA: 3F 4E 55 4D 
       00:0EFE: 42 45 52 
  1976 00:0F01: 20 32 14     QUERY_NUMBER:   jsr     DO_COLON
  1977 00:0F04: 80 07                        dw      DUP
  1978 00:0F06: C9 04                        dw      ZERO
  1979 00:0F08: C9 04                        dw      ZERO
  1980 00:0F0A: DC 07                        dw      ROT
  1981 00:0F0C: 8A 13                        dw      COUNT
  Mon Apr 18 2016 23:59                                                                                                    Page 41


  1982 00:0F0E: 3F 0F                        dw      QUERY_SIGN
  1983 00:0F10: 68 08                        dw      TO_R
  1984 00:0F12: 86 0F                        dw      TO_NUMBER
  1985 00:0F14: C1 15 24 0F                  dw      QUERY_BRANCH,QNUM_1
  1986 00:0F18: A1 08                        dw      R_FROM
  1987 00:0F1A: A6 06                        dw      TWO_DROP
  1988 00:0F1C: A6 06                        dw      TWO_DROP
  1989 00:0F1E: C9 04                        dw      ZERO
  1990 00:0F20: A0 15 34 0F                  dw      BRANCH,QNUM_3
  1991 00:0F24: A6 06        QNUM_1:         dw      TWO_DROP
  1992 00:0F26: 95 07                        dw      NIP
  1993 00:0F28: A1 08                        dw      R_FROM
  1994 00:0F2A: C1 15 30 0F                  dw      QUERY_BRANCH,QNUM_2
  1995 00:0F2E: 33 0A                        dw      NEGATE
  1996 00:0F30: 08 16 FF FF  QNUM_2:         dw      DO_LITERAL,-1
  1997 00:0F34: AD 0E        QNUM_3:         dw      EXIT
  1998                        
  1999                        ; ?SIGN ( c-addr n -- adr' n' f )
  2000                        ;
  2001                        ;   OVER C@                 -- adr n c
  2002                        ;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else 0
  2003                        ;   DUP IF 1+               -- +=0, -=+2
  2004                        ;       >R 1 /STRING R>     -- adr' n' f
  2005                        ;   THEN ;
  2006                        
  2007 00:0F36: F9 0E 00 05                  HEADER  5,"?SIGN",NORMAL
       00:0F3A: 3F 53 49 47 
       00:0F3E: 4E 
  2008 00:0F3F: 20 32 14     QUERY_SIGN:     jsr     DO_COLON
  2009 00:0F42: A3 07                        dw      OVER
  2010 00:0F44: 07 06                        dw      C_FETCH
  2011 00:0F46: 08 16 2D 00                  dw      DO_LITERAL,'-'
  2012 00:0F4A: 10 09                        dw      MINUS
  2013 00:0F4C: 80 07                        dw      DUP
  2014 00:0F4E: 93 09                        dw      ABS
  2015 00:0F50: 08 16 01 00                  dw      DO_LITERAL,1
  2016 00:0F54: 30 0D                        dw      EQUAL
  2017 00:0F56: 84 0D                        dw      AND
  2018 00:0F58: 80 07                        dw      DUP
  2019 00:0F5A: C1 15 6A 0F                  dw      QUERY_BRANCH,QSIGN_1
  2020 00:0F5E: 4A 09                        dw      ONE_PLUS
  2021 00:0F60: 68 08                        dw      TO_R
  2022 00:0F62: 08 16 01 00                  dw      DO_LITERAL,1
  2023 00:0F66: DF 12                        dw      SLASH_STRING
  2024 00:0F68: A1 08                        dw      R_FROM
  2025 00:0F6A: AD 0E        QSIGN_1:        dw      EXIT
  2026                        
  2027                        ; >COUNTED ( c-addr n -- )
  2028                        ;
  2029                        ;   2DUP C! CHAR+ SWAP CMOVE
  2030                        
  2031 00:0F6C: 20 32 14     TO_COUNTED:     jsr     DO_COLON
  2032 00:0F6F: BA 06                        dw      TWO_DUP
  2033 00:0F71: D6 05                        dw      C_STORE
  2034 00:0F73: 75 06                        dw      CHAR_PLUS
  2035 00:0F75: F6 07                        dw      SWAP
  2036 00:0F77: 23 13                        dw      CMOVE
  2037 00:0F79: AD 0E                        dw      EXIT
  Mon Apr 18 2016 23:59                                                                                                    Page 42


  2038                        
  2039                        ; >NUMBER ( ud adr u -- ud' adr' u' )
  2040                        ;
  2041                        ;
  2042                        ;   BEGIN
  2043                        ;   DUP WHILE
  2044                        ;       OVER C@ DIGIT?
  2045                        ;       0= IF DROP EXIT THEN
  2046                        ;       >R 2SWAP BASE @ UD*
  2047                        ;       R> M+ 2SWAP
  2048                        ;       1 /STRING
  2049                        ;   REPEAT ;
  2050                        
  2051 00:0F7B: 39 0F 00 07                  HEADER  7,">NUMBER",NORMAL
       00:0F7F: 3E 4E 55 4D 
       00:0F83: 42 45 52 
  2052 00:0F86: 20 32 14     TO_NUMBER:      jsr     DO_COLON
  2053 00:0F89: 80 07        TO_NUM_1:       dw      DUP
  2054 00:0F8B: C1 15 B9 0F                  dw      QUERY_BRANCH,TO_NUM_3
  2055 00:0F8F: A3 07                        dw      OVER
  2056 00:0F91: 07 06                        dw      C_FETCH
  2057 00:0F93: 38 10                        dw      DIGIT_QUERY
  2058 00:0F95: CC 0C                        dw      ZERO_EQUAL
  2059 00:0F97: C1 15 9F 0F                  dw      QUERY_BRANCH,TO_NUM_2
  2060 00:0F9B: 6F 07                        dw      DROP
  2061 00:0F9D: AD 0E                        dw      EXIT
  2062 00:0F9F: 68 08        TO_NUM_2:       dw      TO_R
  2063 00:0FA1: 21 07                        dw      TWO_SWAP
  2064 00:0FA3: 64 04                        dw      BASE
  2065 00:0FA5: B4 05                        dw      FETCH
  2066 00:0FA7: 32 0C                        dw      UD_STAR
  2067 00:0FA9: A1 08                        dw      R_FROM
  2068 00:0FAB: CE 0B                        dw      M_PLUS
  2069 00:0FAD: 21 07                        dw      TWO_SWAP
  2070 00:0FAF: 08 16 01 00                  dw      DO_LITERAL,1
  2071 00:0FB3: DF 12                        dw      SLASH_STRING
  2072 00:0FB5: A0 15 89 0F                  dw      BRANCH,TO_NUM_1
  2073 00:0FB9: AD 0E        TO_NUM_3:       dw      EXIT
  2074                        
  2075                        ; ACCEPT ( c-addr +n1 -- +n2 )
  2076                        ;
  2077                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  2078                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  2079                        ; received. A program that depends on the presence or absence of non-graphic
  2080                        ; characters in the string has an environmental dependency. The editing
  2081                        ; functions, if any, that the system performs in order to construct the string
  2082                        ; are implementation-defined.
  2083                        ;
  2084                        ; Input terminates when an implementation-defined line terminator is received.
  2085                        ; When input terminates, nothing is appended to the string, and the display is
  2086                        ; maintained in an implementation-defined way.
  2087                        ;
  2088                        ; +n2 is the length of the string stored at c-addr.
  2089                        ;
  2090                        ;   OVER + 1- OVER      -- sa ea a
  2091                        ;   BEGIN KEY           -- sa ea a c
  2092                        ;   DUP 0D <> WHILE
  2093                        ;     DUP 8 = OVER 127 = OR IF
  Mon Apr 18 2016 23:59                                                                                                    Page 43


  2094                        ;       DROP 1-
  2095                        ;       >R OVER R> UMAX
  2096                        ;       8 EMIT SPACE 8 EMIT
  2097                        ;     ELSE
  2098                        ;       DUP EMIT        -- sa ea a c
  2099                        ;       OVER C! 1+ OVER UMIN
  2100                        ;     THEN              -- sa ea a
  2101                        ;   REPEAT              -- sa ea a c
  2102                        ;   DROP NIP SWAP - ;
  2103                        
  2104 00:0FBB: 7E 0F 00 06                  HEADER  6,"ACCEPT",NORMAL
       00:0FBF: 41 43 43 45 
       00:0FC3: 50 54 
  2105 00:0FC5: 20 32 14     ACCEPT:         jsr     DO_COLON
  2106 00:0FC8: A3 07                        dw      OVER
  2107 00:0FCA: FA 08                        dw      PLUS
  2108 00:0FCC: 58 09                        dw      ONE_MINUS
  2109 00:0FCE: A3 07                        dw      OVER
  2110 00:0FD0: E6 17        ACCEPT_1:       dw      KEY
  2111 00:0FD2: 80 07                        dw      DUP
  2112 00:0FD4: 08 16 0D 00                  dw      DO_LITERAL,$0D
  2113 00:0FD8: 17 0D                        dw      NOT_EQUAL
  2114 00:0FDA: C1 15 24 10                  dw      QUERY_BRANCH,ACCEPT_4
  2115 00:0FDE: 80 07                        dw      DUP
  2116 00:0FE0: 08 16 08 00                  dw      DO_LITERAL,$08
  2117 00:0FE4: 30 0D                        dw      EQUAL
  2118 00:0FE6: A3 07                        dw      OVER
  2119 00:0FE8: 08 16 7F 00                  dw      DO_LITERAL,$7f
  2120 00:0FEC: 30 0D                        dw      EQUAL
  2121 00:0FEE: DD 0D                        dw      OR
  2122 00:0FF0: C1 15 12 10                  dw      QUERY_BRANCH,ACCEPT_2
  2123 00:0FF4: 6F 07                        dw      DROP
  2124 00:0FF6: 58 09                        dw      ONE_MINUS
  2125 00:0FF8: 68 08                        dw      TO_R
  2126 00:0FFA: A3 07                        dw      OVER
  2127 00:0FFC: A1 08                        dw      R_FROM
  2128 00:0FFE: 49 0A                        dw      UMAX
  2129 00:1000: 08 16 08 00                  dw      DO_LITERAL,8
  2130 00:1004: D0 17                        dw      EMIT
  2131 00:1006: 02 18                        dw      SPACE
  2132 00:1008: 08 16 08 00                  dw      DO_LITERAL,8
  2133 00:100C: D0 17                        dw      EMIT
  2134 00:100E: A0 15 20 10                  dw      BRANCH,ACCEPT_3
  2135 00:1012: 80 07        ACCEPT_2:       dw      DUP
  2136 00:1014: D0 17                        dw      EMIT
  2137 00:1016: A3 07                        dw      OVER
  2138 00:1018: D6 05                        dw      C_STORE
  2139 00:101A: 4A 09                        dw      ONE_PLUS
  2140 00:101C: A3 07                        dw      OVER
  2141 00:101E: 5D 0A                        dw      UMIN
  2142 00:1020: A0 15 D0 0F  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  2143 00:1024: 6F 07        ACCEPT_4:       dw      DROP
  2144 00:1026: 95 07                        dw      NIP
  2145 00:1028: F6 07                        dw      SWAP
  2146 00:102A: 10 09                        dw      MINUS
  2147 00:102C: AD 0E                        dw      EXIT
  2148                        
  2149                        ; DIGIT?
  Mon Apr 18 2016 23:59                                                                                                    Page 44


  2150                        ;
  2151                        ;   [ HEX ] DUP 39 > 100 AND +     silly looking
  2152                        ;   DUP 140 > 107 AND -   30 -     but it works!
  2153                        ;   DUP BASE @ U< ;
  2154                        
  2155 00:102E: BE 0F 00 06                  HEADER  6,"DIGIT?",NORMAL
       00:1032: 44 49 47 49 
       00:1036: 54 3F 
  2156 00:1038: 20 32 14     DIGIT_QUERY:    jsr     DO_COLON
  2157 00:103B: 80 07                        dw      DUP
  2158 00:103D: 08 16 39 00                  dw      DO_LITERAL,'9'
  2159 00:1041: 49 0D                        dw      GREATER
  2160 00:1043: 08 16 00 01                  dw      DO_LITERAL,$100
  2161 00:1047: 84 0D                        dw      AND
  2162 00:1049: FA 08                        dw      PLUS
  2163 00:104B: 80 07                        dw      DUP
  2164 00:104D: 08 16 40 01                  dw      DO_LITERAL,$140
  2165 00:1051: 49 0D                        dw      GREATER
  2166 00:1053: 08 16 07 01                  dw      DO_LITERAL,$107
  2167 00:1057: 84 0D                        dw      AND
  2168 00:1059: 10 09                        dw      MINUS
  2169 00:105B: 08 16 30 00                  dw      DO_LITERAL,'0'
  2170 00:105F: 10 09                        dw      MINUS
  2171 00:1061: 80 07                        dw      DUP
  2172 00:1063: 64 04                        dw      BASE
  2173 00:1065: B4 05                        dw      FETCH
  2174 00:1067: 58 0D                        dw      U_LESS
  2175 00:1069: AD 0E                        dw      EXIT
  2176                        
  2177                        ; EVALUATE ( i*x c-addr u -- j*x )
  2178                        ;
  2179                        ; Save the current input source specification. Store minus-one (-1) in
  2180                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  2181                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  2182                        ; parse area is empty, restore the prior input source specification. Other
  2183                        ; stack effects are due to the words EVALUATEd.
  2184                        ;
  2185                        ;   >R >R SAVE-INPUT
  2186                        ;   -1 (SOURCE-ID) !
  2187                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  2188                        ;   INTERPRET
  2189                        ;   RESTORE-INPUT DROP
  2190                        
  2191 00:106B: 31 10 00 08                  HEADER  8,"EVALUATE",NORMAL
       00:106F: 45 56 41 4C 
       00:1073: 55 41 54 45 
  2192 00:1077: 20 32 14     EVALUATE:       jsr     DO_COLON
  2193 00:107A: 68 08                        dw      TO_R
  2194 00:107C: 68 08                        dw      TO_R
  2195 00:107E: 03 12                        dw      SAVE_INPUT
  2196 00:1080: A1 08                        dw      R_FROM
  2197 00:1082: A1 08                        dw      R_FROM
  2198 00:1084: 07 05                        dw      TRUE
  2199 00:1086: A5 04                        dw      SOURCEID
  2200 00:1088: 46 05                        dw      STORE
  2201 00:108A: C9 04                        dw      ZERO
  2202 00:108C: 57 04                        dw      TO_IN
  2203 00:108E: 46 05                        dw      STORE
  Mon Apr 18 2016 23:59                                                                                                    Page 45


  2204 00:1090: 94 04                        dw      LENGTH
  2205 00:1092: 46 05                        dw      STORE
  2206 00:1094: 75 04                        dw      BUFFER
  2207 00:1096: 46 05                        dw      STORE
  2208 00:1098: AD 10                        dw      INTERPRET
  2209 00:109A: B4 11                        dw      RESTORE_INPUT
  2210 00:109C: 6F 07                        dw      DROP
  2211 00:109E: AD 0E                        dw      EXIT
  2212                        
  2213                        ; INTERPRET ( -- )
  2214                        ;
  2215                        ;
  2216                        ;   BEGIN
  2217                        ;   BL WORD DUP C@ WHILE        -- textadr
  2218                        ;       FIND                    -- a 0/1/-1
  2219                        ;       ?DUP IF                 -- xt 1/-1
  2220                        ;           1+ STATE @ 0= OR    immed or interp?
  2221                        ;           IF EXECUTE ELSE , THEN
  2222                        ;       ELSE                    -- textadr
  2223                        ;           ?NUMBER
  2224                        ;           IF STATE @
  2225                        ;               IF POSTPONE LITERAL THEN     converted ok
  2226                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  2227                        ;           THEN
  2228                        ;       THEN
  2229                        ;   REPEAT DROP ;
  2230                        
  2231 00:10A0: 6E 10 00 09                  HEADER  9,"INTERPRET",NORMAL
       00:10A4: 49 4E 54 45 
       00:10A8: 52 50 52 45 
       00:10AC: 54 
  2232 00:10AD: 20 32 14     INTERPRET:      jsr     DO_COLON
  2233 00:10B0: DB 04        INTERPRET_1:    dw      BL
  2234 00:10B2: 7B 12                        dw      WORD
  2235 00:10B4: 80 07                        dw      DUP
  2236 00:10B6: 07 06                        dw      C_FETCH
  2237 00:10B8: C1 15 04 11                  dw      QUERY_BRANCH,INTERPRET_7
  2238 00:10BC: 10 11                        dw      FIND
  2239 00:10BE: 43 07                        dw      QUERY_DUP
  2240 00:10C0: C1 15 DE 10                  dw      QUERY_BRANCH,INTERPRET_4
  2241 00:10C4: 4A 09                        dw      ONE_PLUS
  2242 00:10C6: B3 04                        dw      STATE
  2243 00:10C8: B4 05                        dw      FETCH
  2244 00:10CA: CC 0C                        dw      ZERO_EQUAL
  2245 00:10CC: DD 0D                        dw      OR
  2246 00:10CE: C1 15 D8 10                  dw      QUERY_BRANCH,INTERPRET_2
  2247 00:10D2: 9C 0E                        dw      EXECUTE
  2248 00:10D4: A0 15 DA 10                  dw      BRANCH,INTERPRET_3
  2249 00:10D8: 74 05        INTERPRET_2:    dw      COMMA
  2250 00:10DA: A0 15 00 11  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  2251 00:10DE: 01 0F        INTERPRET_4:    dw      QUERY_NUMBER
  2252 00:10E0: C1 15 F2 10                  dw      QUERY_BRANCH,INTERPRET_5
  2253 00:10E4: B3 04                        dw      STATE
  2254 00:10E6: B4 05                        dw      FETCH
  2255 00:10E8: C1 15 00 11                  dw      QUERY_BRANCH,INTERPRET_6
  2256 00:10EC: FB 15                        dw      LITERAL
  2257 00:10EE: A0 15 00 11                  dw      BRANCH,INTERPRET_6
  2258 00:10F2: 8A 13        INTERPRET_5:    dw      COUNT
  Mon Apr 18 2016 23:59                                                                                                    Page 46


  2259 00:10F4: 34 18                        dw      TYPE
  2260 00:10F6: 08 16 3F 00                  dw      DO_LITERAL,$3f
  2261 00:10FA: D0 17                        dw      EMIT
  2262 00:10FC: B7 17                        dw      CR
  2263 00:10FE: 4A 0E                        dw      ABORT
  2264 00:1100: A0 15 B0 10  INTERPRET_6     dw      BRANCH,INTERPRET_1
  2265 00:1104: 6F 07        INTERPRET_7:    dw      DROP
  2266 00:1106: AD 0E                        dw      EXIT
  2267                        
  2268                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  2269                        ;
  2270                        ; Find the definition named in the counted string at c-addr. If the definition
  2271                        ; is not found, return c-addr and zero. If the definition is found, return its
  2272                        ; execution token xt. If the definition is immediate, also return one (1),
  2273                        ; otherwise also return minus-one (-1). For a given string, the values returned
  2274                        ; by FIND while compiling may differ from those returned while not compiling.
  2275                        ;
  2276                        ;   LATEST @ BEGIN             -- a nfa
  2277                        ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
  2278                        ;       S=                     -- a nfa f
  2279                        ;       DUP IF
  2280                        ;           DROP
  2281                        ;           NFA>LFA @ DUP      -- a link link
  2282                        ;       THEN
  2283                        ;   0= UNTIL                   -- a nfa  OR  a 0
  2284                        ;   DUP IF
  2285                        ;       NIP DUP NFA>CFA        -- nfa xt
  2286                        ;       SWAP IMMED?            -- xt iflag
  2287                        ;       0= 1 OR                -- xt 1/-1
  2288                        ;   THEN ;
  2289                        
  2290 00:1108: A3 10 00 04                  HEADER  4,"FIND",NORMAL
       00:110C: 46 49 4E 44 
  2291 00:1110: 20 32 14     FIND:           jsr     DO_COLON
  2292 00:1113: 8F 04                        dw      LATEST
  2293 00:1115: B4 05                        dw      FETCH
  2294 00:1117: BA 06        FIND1:          dw      TWO_DUP
  2295 00:1119: A3 07                        dw      OVER
  2296 00:111B: 07 06                        dw      C_FETCH
  2297 00:111D: 75 06                        dw      CHAR_PLUS
  2298 00:111F: CB 11                        dw      S_EQUAL
  2299 00:1121: 80 07                        dw      DUP
  2300 00:1123: C1 15 2F 11                  dw      QUERY_BRANCH,FIND2
  2301 00:1127: 6F 07                        dw      DROP
  2302 00:1129: 61 11                        dw      NFA_TO_LFA
  2303 00:112B: B4 05                        dw      FETCH
  2304 00:112D: 80 07                        dw      DUP
  2305 00:112F: CC 0C        FIND2:          dw      ZERO_EQUAL
  2306 00:1131: C1 15 17 11                  dw      QUERY_BRANCH,FIND1
  2307 00:1135: 80 07                        dw      DUP
  2308 00:1137: C1 15 4D 11                  dw      QUERY_BRANCH,FIND3
  2309 00:113B: 95 07                        dw      NIP
  2310 00:113D: 80 07                        dw      DUP
  2311 00:113F: 58 11                        dw      NFA_TO_CFA
  2312 00:1141: F6 07                        dw      SWAP
  2313 00:1143: 4F 11                        dw      IMMED_QUERY
  2314 00:1145: CC 0C                        dw      ZERO_EQUAL
  2315 00:1147: 08 16 01 00                  dw      DO_LITERAL,1
  Mon Apr 18 2016 23:59                                                                                                    Page 47


  2316 00:114B: DD 0D                        dw      OR
  2317 00:114D: AD 0E        FIND3:          dw      EXIT
  2318                        
  2319                        ; IMMED? ( nfa -- f )
  2320                        
  2321                        ;               HEADER  6,"IMMED?",NORMAL
  2322 00:114F: 20 32 14     IMMED_QUERY:    jsr     DO_COLON
  2323 00:1152: 58 09                        dw      ONE_MINUS
  2324 00:1154: 07 06                        dw      C_FETCH
  2325 00:1156: AD 0E                        dw      EXIT
  2326                        
  2327                        ; NFA>CFA ( nfa -- cfa )
  2328                        
  2329                        ;               HEADER  7,"NFA>CFA",NORMAL
  2330 00:1158: 20 32 14     NFA_TO_CFA:     jsr     DO_COLON
  2331 00:115B: 8A 13                        dw      COUNT
  2332 00:115D: FA 08                        dw      PLUS
  2333 00:115F: AD 0E                        dw      EXIT
  2334                        
  2335                        ; NFA>LFA ( nfa -- lfa )
  2336                        
  2337                        ;               HEADER  7,"NFA>LFA",NORMAL
  2338 00:1161: 20 32 14     NFA_TO_LFA:     jsr     DO_COLON
  2339 00:1164: 08 16 03 00                  dw      DO_LITERAL,3
  2340 00:1168: 10 09                        dw      MINUS
  2341 00:116A: AD 0E                        dw      EXIT
  2342                        
  2343                        ; REFILL ( -- flag )
  2344                        ;
  2345                        ; Attempt to fill the input buffer from the input source, returning a true flag
  2346                        ; if successful.
  2347                        ;
  2348                        ; When the input source is the user input device, attempt to receive input into
  2349                        ; the terminal input buffer. If successful, make the result the input buffer,
  2350                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  2351                        ; is considered successful. If there is no input available from the current
  2352                        ; input source, return false.
  2353                        ;
  2354                        ; When the input source is a string from EVALUATE, return false and perform no
  2355                        ; other action.
  2356                        ;
  2357                        ; In this implementation it is defined as:
  2358                        ;
  2359                        ;   SOURCE-ID 0= IF
  2360                        ;     TIB DUP #TIB @ ACCEPT SPACE
  2361                        ;     LENGTH ! BUFFER !
  2362                        ;     0 >IN ! TRUE EXIT
  2363                        ;   THEN
  2364                        ;   FALSE
  2365                        
  2366 00:116C: 0B 11 00 06                  HEADER  6,"REFILL",NORMAL
       00:1170: 52 45 46 49 
       00:1174: 4C 4C 
  2367 00:1176: 20 32 14     REFILL:         jsr     DO_COLON
  2368 00:1179: 6A 12                        dw      SOURCE_ID
  2369 00:117B: CC 0C                        dw      ZERO_EQUAL
  2370 00:117D: C1 15 9F 11                  dw      QUERY_BRANCH,REFILL_1
  2371 00:1181: BF 04                        dw      TIB
  Mon Apr 18 2016 23:59                                                                                                    Page 48


  2372 00:1183: 80 07                        dw      DUP
  2373 00:1185: 49 04                        dw      HASH_TIB
  2374 00:1187: B4 05                        dw      FETCH
  2375 00:1189: C5 0F                        dw      ACCEPT
  2376 00:118B: 02 18                        dw      SPACE
  2377 00:118D: 94 04                        dw      LENGTH
  2378 00:118F: 46 05                        dw      STORE
  2379 00:1191: 75 04                        dw      BUFFER
  2380 00:1193: 46 05                        dw      STORE
  2381 00:1195: C9 04                        dw      ZERO
  2382 00:1197: 57 04                        dw      TO_IN
  2383 00:1199: 46 05                        dw      STORE
  2384 00:119B: 07 05                        dw      TRUE
  2385 00:119D: AD 0E                        dw      EXIT
  2386 00:119F: F3 04        REFILL_1:       dw      FALSE
  2387 00:11A1: AD 0E                        dw      EXIT
  2388                        
  2389                        ; RESTORE-INPUT ( xn ... x1 n -- flag )
  2390                        ;
  2391                        ; Attempt to restore the input source specification to the state described by
  2392                        ; x1 through xn. flag is true if the input source specification cannot be so
  2393                        ; restored.
  2394                        ;
  2395                        ; An ambiguous condition exists if the input source represented by the
  2396                        ; arguments is not the same as the current input source.
  2397                        ;
  2398                        ; In this implementation it is defined as:
  2399                        ;
  2400                        ;   >IN ! (LENGTH) ! BUFFER !
  2401                        ;   SOURCEID !
  2402                        ;   TRUE
  2403                        
  2404 00:11A3: 6F 11 00 0D                  HEADER  13,"RESTORE-INPUT",NORMAL
       00:11A7: 52 45 53 54 
       00:11AB: 4F 52 45 2D 
       00:11AF: 49 4E 50 55 
       00:11B3: 54 
  2405 00:11B4: 20 32 14     RESTORE_INPUT   jsr     DO_COLON
  2406 00:11B7: 57 04                        dw      TO_IN
  2407 00:11B9: 46 05                        dw      STORE
  2408 00:11BB: 94 04                        dw      LENGTH
  2409 00:11BD: 46 05                        dw      STORE
  2410 00:11BF: 75 04                        dw      BUFFER
  2411 00:11C1: 46 05                        dw      STORE
  2412 00:11C3: A5 04                        dw      SOURCEID
  2413 00:11C5: 46 05                        dw      STORE
  2414 00:11C7: 07 05                        dw      TRUE
  2415 00:11C9: AD 0E                        dw      EXIT
  2416                        
  2417                        ; S= ( c-addr1 caddr2 u -- n)
  2418                        ;
  2419                        ; Misnamed, more like C's strncmp. Note that counted length bytes are compared!
  2420                        
  2421                        S_EQUAL:
  2422 00:11CB: 5A                           phy
  2423 00:11CC: A6 01                        ldx     <1                      ; Fetch maximum length
  2424 00:11CE: F0 14                        beq     S_EQUAL_3
  2425 00:11D0: A0 00 00                     ldy     #0
  Mon Apr 18 2016 23:59                                                                                                    Page 49


  2426 00:11D3: E2 20                        short_a
  2427                        S_EQUAL_1:
  2428 00:11D5: B1 05                        lda     (5),y                   ; Compare bytes
  2429 00:11D7: D1 03                        cmp     (3),y
  2430 00:11D9: D0 06                        bne     S_EQUAL_2
  2431 00:11DB: C8                           iny
  2432 00:11DC: CA                           dex                             ; End of strings?
  2433 00:11DD: D0 F6                        bne     S_EQUAL_1               ; No
  2434 00:11DF: 80 03                        bra     S_EQUAL_3               ; Yes. must be the same
  2435                        S_EQUAL_2:
  2436 00:11E1: A2 FF FF                     ldx     #$ffff                  ; Difference found
  2437                        S_EQUAL_3:
  2438 00:11E4: C2 20                        long_a
  2439 00:11E6: 7B                           tdc                             ; Clean up the stack
  2440 00:11E7: 1A                           inc     a
  2441 00:11E8: 1A                           inc     a
  2442 00:11E9: 1A                           inc     a
  2443 00:11EA: 1A                           inc     a
  2444 00:11EB: 5B                           tcd
  2445 00:11EC: 86 01                        stx     <1                      ; Save the flag
  2446 00:11EE: 7A                           ply
  2447 00:11EF: BB C8 C8 7C                  CONTINUE
       00:11F3: 00 00 
  2448                        
  2449                        ; SAVE-INPUT ( -- xn ... x1 n )
  2450                        ;
  2451                        ; x1 through xn describe the current state of the input source specification
  2452                        ; for later use by RESTORE-INPUT.
  2453                        
  2454 00:11F5: A6 11 00 0A                  HEADER  10,"SAVE-INPUT",NORMAL
       00:11F9: 53 41 56 45 
       00:11FD: 2D 49 4E 50 
       00:1201: 55 54 
  2455 00:1203: 20 32 14     SAVE_INPUT:     jsr     DO_COLON
  2456 00:1206: A5 04                        dw      SOURCEID
  2457 00:1208: B4 05                        dw      FETCH
  2458 00:120A: 75 04                        dw      BUFFER
  2459 00:120C: B4 05                        dw      FETCH
  2460 00:120E: 94 04                        dw      LENGTH
  2461 00:1210: B4 05                        dw      FETCH
  2462 00:1212: 57 04                        dw      TO_IN
  2463 00:1214: B4 05                        dw      FETCH
  2464 00:1216: AD 0E                        dw      EXIT
  2465                        
  2466                        ; SCAN ( c-addr n c == c-addr' n' )
  2467                        
  2468                        SCAN:
  2469                        SCAN_1:
  2470 00:1218: A5 03                        lda     <3                      ; Any data left to scan?
  2471 00:121A: F0 10                        beq     SCAN_2                  ; No.
  2472 00:121C: A5 01                        lda     <1                      ; Fetch and compare with scan
  2473 00:121E: E2 20                        short_a
  2474 00:1220: D2 05                        cmp     (5)
  2475 00:1222: C2 20                        long_a
  2476 00:1224: F0 06                        beq     SCAN_2
  2477 00:1226: E6 05                        inc     <5
  2478 00:1228: C6 03                        dec     <3
  2479 00:122A: 80 EC                        bra     SCAN_1
  Mon Apr 18 2016 23:59                                                                                                    Page 50


  2480                        SCAN_2:
  2481 00:122C: 4C 6F 07                     jmp     DROP                    ; Drop the character
  2482                        
  2483                        ; SKIP ( c-addr n c == c-addr' n' )
  2484                        ;
  2485                        
  2486                        SKIP:
  2487 00:122F: A5 03        SKIP_1:         lda     <3                      ; Any data left to skip over?
  2488 00:1231: F0 10                        beq     SKIP_2                  ; No.
  2489 00:1233: A5 01                        lda     <1                      ; Fetch and compare with skip
  2490 00:1235: E2 20                        short_a
  2491 00:1237: D2 05                        cmp     (5)
  2492 00:1239: C2 20                        long_a
  2493 00:123B: D0 06                        bne     SKIP_2                  ; Cannot be skipped
  2494 00:123D: E6 05                        inc     <5                      ; Bump data address
  2495 00:123F: C6 03                        dec     <3                      ; and update length
  2496 00:1241: 80 EC                        bra     SKIP_1                  ; And repeat
  2497                        SKIP_2:
  2498 00:1243: 4C 6F 07                     jmp     DROP                    ; Drop the character
  2499                        
  2500                        ; SOURCE ( -- c-addr u )
  2501                        ;
  2502                        ; c-addr is the address of, and u is the number of characters in, the input
  2503                        ; buffer.
  2504                        ;
  2505                        ; In this implementation it is defined as
  2506                        ;
  2507                        ;   BUFFER @ LENGTH @
  2508                        
  2509 00:1246: F8 11 00 06                  HEADER  6,"SOURCE",NORMAL
       00:124A: 53 4F 55 52 
       00:124E: 43 45 
  2510 00:1250: 20 32 14     SOURCE:         jsr     DO_COLON
  2511 00:1253: 75 04                        dw      BUFFER
  2512 00:1255: B4 05                        dw      FETCH
  2513 00:1257: 94 04                        dw      LENGTH
  2514 00:1259: B4 05                        dw      FETCH
  2515 00:125B: AD 0E                        dw      EXIT
  2516                        
  2517                        ; SOURCE-ID ( -- 0 | -1 )
  2518                        ;
  2519                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  2520                        ; device.
  2521                        
  2522 00:125D: 49 12 00 09                  HEADER  9,"SOURCE-ID",NORMAL
       00:1261: 53 4F 55 52 
       00:1265: 43 45 2D 49 
       00:1269: 44 
  2523 00:126A: 20 32 14     SOURCE_ID:      jsr     DO_COLON
  2524 00:126D: A5 04                        dw      SOURCEID
  2525 00:126F: B4 05                        dw      FETCH
  2526 00:1271: AD 0E                        dw      EXIT
  2527                        
  2528                        ; WORD ( char <chars>ccc<char> -- c-addr )
  2529                        ;
  2530                        ; Skip leading delimiters. Parse characters ccc delimited by char. An
  2531                        ; ambiguous condition exists if the length of the parsed string is greater
  2532                        ; than the implementation-defined length of a counted string.
  Mon Apr 18 2016 23:59                                                                                                    Page 51


  2533                        ;
  2534                        ; c-addr is the address of a transient region containing the parsed word as
  2535                        ; a counted string. If the parse area was empty or contained no characters
  2536                        ; other than the delimiter, the resulting string has a zero length. A space,
  2537                        ; not included in the length, follows the string. A program may replace
  2538                        ; characters within the string.
  2539                        ;
  2540                        ; In this implementation it is defined as:
  2541                        ;
  2542                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  2543                        ;   DUP >R   ROT SKIP           -- c adr' n'
  2544                        ;   OVER >R  ROT SCAN           -- adr" n"
  2545                        ;   DUP IF CHAR- THEN        skip trailing delim.
  2546                        ;   R> R> ROT -   >IN +!        update >IN offset
  2547                        ;   TUCK -                      -- adr' N
  2548                        ;   HERE >counted               --
  2549                        ;   HERE                        -- a
  2550                        ;   BL OVER COUNT + C! ;    append trailing blank
  2551                        
  2552 00:1273: 60 12 00 04                  HEADER  4,"WORD",NORMAL
       00:1277: 57 4F 52 44 
  2553 00:127B: 20 32 14     WORD:           jsr     DO_COLON
  2554 00:127E: 80 07                        dw      DUP
  2555 00:1280: 50 12                        dw      SOURCE
  2556 00:1282: 57 04                        dw      TO_IN
  2557 00:1284: B4 05                        dw      FETCH
  2558 00:1286: DF 12                        dw      SLASH_STRING
  2559 00:1288: 80 07                        dw      DUP
  2560 00:128A: 68 08                        dw      TO_R
  2561 00:128C: DC 07                        dw      ROT
  2562 00:128E: 2F 12                        dw      SKIP
  2563 00:1290: A3 07                        dw      OVER
  2564 00:1292: 68 08                        dw      TO_R
  2565 00:1294: DC 07                        dw      ROT
  2566 00:1296: 18 12                        dw      SCAN
  2567 00:1298: 80 07                        dw      DUP
  2568 00:129A: C1 15 A0 12                  dw      QUERY_BRANCH,WORD_1
  2569 00:129E: 86 06                        dw      CHAR_MINUS
  2570 00:12A0: A1 08        WORD_1:         dw      R_FROM
  2571 00:12A2: A1 08                        dw      R_FROM
  2572 00:12A4: DC 07                        dw      ROT
  2573 00:12A6: 10 09                        dw      MINUS
  2574 00:12A8: 57 04                        dw      TO_IN
  2575 00:12AA: 5C 05                        dw      PLUS_STORE
  2576 00:12AC: 0C 08                        dw      TUCK
  2577 00:12AE: 10 09                        dw      MINUS
  2578 00:12B0: 1F 06                        dw      HERE
  2579 00:12B2: 6C 0F                        dw      TO_COUNTED
  2580 00:12B4: 1F 06                        dw      HERE
  2581 00:12B6: DB 04                        dw      BL
  2582 00:12B8: A3 07                        dw      OVER
  2583 00:12BA: 8A 13                        dw      COUNT
  2584 00:12BC: FA 08                        dw      PLUS
  2585 00:12BE: D6 05                        dw      C_STORE
  2586 00:12C0: AD 0E                        dw      EXIT
  2587                        
  2588                        ;===============================================================================
  2589                        ; String Words
  Mon Apr 18 2016 23:59                                                                                                    Page 52


  2590                        ;-------------------------------------------------------------------------------
  2591                        
  2592                        ; -TRAILING ( c-addr u1 -- c-addr u2 )
  2593                        ;
  2594                        ; If u1 is greater than zero, u2 is equal to u1 less the number of spaces at
  2595                        ; the end of the character string specified by c-addr u1. If u1 is zero or the
  2596                        ; entire string consists of spaces, u2 is zero.
  2597                        
  2598 00:12C2: 76 12 00 09                  HEADER  9,"-TRAILING",NORMAL
       00:12C6: 2D 54 52 41 
       00:12CA: 49 4C 49 4E 
       00:12CE: 47 
  2599 00:12CF: 20 32 14     DASH_TRAILING:  jsr     DO_COLON
  2600                        ; TODO
  2601 00:12D2: AD 0E                        dw      EXIT
  2602                        
  2603                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  2604                        ;
  2605                        ; Adjust the character string at c-addr1 by n characters. The resulting
  2606                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  2607                        ; characters and is u1 minus n characters long.
  2608                        ;
  2609                        ;   ROT OVER + ROT ROT -
  2610                        
  2611 00:12D4: C5 12 00 07                  HEADER  7,"/STRING",NORMAL
       00:12D8: 2F 53 54 52 
       00:12DC: 49 4E 47 
  2612 00:12DF: 20 32 14     SLASH_STRING:   jsr     DO_COLON
  2613 00:12E2: DC 07                        dw      ROT
  2614 00:12E4: A3 07                        dw      OVER
  2615 00:12E6: FA 08                        dw      PLUS
  2616 00:12E8: DC 07                        dw      ROT
  2617 00:12EA: DC 07                        dw      ROT
  2618 00:12EC: 10 09                        dw      MINUS
  2619 00:12EE: AD 0E                        dw      EXIT
  2620                        
  2621                        ; BLANK ( c-addr u -- )
  2622                        ;
  2623                        ; If u is greater than zero, store the character value for space in u
  2624                        ; consecutive character positions beginning at c-addr.
  2625                        ;
  2626                        ; In this implementation it is defined as
  2627                        ;
  2628                        ;   ?DUP IF OVER + SWAP DO BL I C! LOOP ELSE DROP THEN
  2629                        
  2630 00:12F0: D7 12 00 05                  HEADER  5,"BLANK",NORMAL
       00:12F4: 42 4C 41 4E 
       00:12F8: 4B 
  2631 00:12F9: 20 32 14     BLANK:          jsr     DO_COLON
  2632 00:12FC: 43 07                        dw      QUERY_DUP
  2633 00:12FE: C1 15 16 13                  dw      QUERY_BRANCH,BLANK_2
  2634 00:1302: A3 07                        dw      OVER
  2635 00:1304: FA 08                        dw      PLUS
  2636 00:1306: F6 07                        dw      SWAP
  2637 00:1308: 6F 15                        dw      DO_DO
  2638 00:130A: DB 04        BLANK_1:        dw      BL
  2639 00:130C: 7A 08                        dw      I
  2640 00:130E: D6 05                        dw      C_STORE
  Mon Apr 18 2016 23:59                                                                                                    Page 53


  2641 00:1310: 2E 16 0A 13                  dw      DO_LOOP,BLANK_1
  2642 00:1314: AD 0E                        dw      EXIT
  2643 00:1316: 6F 07        BLANK_2:        dw      DROP
  2644 00:1318: AD 0E                        dw      EXIT
  2645                        
  2646                        ; CMOVE ( c-addr1 c-addr2 u -- )
  2647                        ;
  2648                        ; If u is greater than zero, copy u consecutive characters from the data space
  2649                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2650                        ; character from lower addresses to higher addresses.
  2651                        
  2652 00:131A: F3 12 00 05                  HEADER  5,"CMOVE",NORMAL
       00:131E: 43 4D 4F 56 
       00:1322: 45 
  2653                        CMOVE:
  2654 00:1323: 5A                           phy
  2655 00:1324: A6 01                        ldx     <1                      ; Any characters to move?
  2656 00:1326: F0 0F                        beq     CMOVE_2                 ; No
  2657 00:1328: A0 00 00                     ldy     #0
  2658 00:132B: E2 20                        short_a
  2659                        CMOVE_1:                                        ; Transfer a byte
  2660 00:132D: B1 05                        lda     (5),y
  2661 00:132F: 91 03                        sta     (3),y
  2662 00:1331: C8                           iny
  2663 00:1332: CA                           dex                             ; Decrement count
  2664 00:1333: D0 F8                        bne     CMOVE_1                 ; .. and repeat until done
  2665 00:1335: C2 20                        long_a
  2666                        CMOVE_2:
  2667 00:1337: 7B                           tdc                             ; Clean up the stack
  2668 00:1338: 18                           clc
  2669 00:1339: 69 06 00                     adc     #6
  2670 00:133C: 5B                           tcd
  2671 00:133D: 7A                           ply
  2672 00:133E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1342: 00 00 
  2673                        
  2674                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  2675                        ;
  2676                        ; If u is greater than zero, copy u consecutive characters from the data space
  2677                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2678                        ; character from higher addresses to lower addresses.
  2679                        
  2680 00:1344: 1D 13 00 06                  HEADER  6,"CMOVE>",NORMAL
       00:1348: 43 4D 4F 56 
       00:134C: 45 3E 
  2681                        CMOVE_GREATER:
  2682 00:134E: 5A                           phy
  2683 00:134F: A6 01                        ldx     <1                      ; Any characters to move?
  2684 00:1351: F0 0E                        beq     CMOVE_GT_2              ; No.
  2685 00:1353: A4 01                        ldy     <1
  2686 00:1355: E2 20                        short_a
  2687                        CMOVE_GT_1:
  2688 00:1357: 88                           dey                             ; Transfer a byte
  2689 00:1358: B1 05                        lda     (5),y
  2690 00:135A: 91 03                        sta     (3),y
  2691 00:135C: CA                           dex                             ; Decrement length
  2692 00:135D: D0 F8                        bne     CMOVE_GT_1              ; .. and repeat until done
  2693 00:135F: C2 20                        long_a
  Mon Apr 18 2016 23:59                                                                                                    Page 54


  2694                        CMOVE_GT_2:
  2695 00:1361: 7B                           tdc                             ; Clean up the stack
  2696 00:1362: 18                           clc
  2697 00:1363: 69 06 00                     adc     #6
  2698 00:1366: 5B                           tcd
  2699 00:1367: BB C8 C8 7C                  CONTINUE                        ; Done
       00:136B: 00 00 
  2700                        
  2701                        ; COMPARE ( c-addr1 u1 c-addr2 u2 -- n )
  2702                        ;
  2703                        ; Compare the string specified by c-addr1 u1 to the string specified by c-addr2
  2704                        ; u2. The strings are compared, beginning at the given addresses, character by
  2705                        ; character, up to the length of the shorter string or until a difference is
  2706                        ; found. If the two strings are identical, n is zero. If the two strings are
  2707                        ; identical up to the length of the shorter string, n is minus-one (-1) if u1
  2708                        ; is less than u2 and one (1) otherwise. If the two strings are not identical
  2709                        ; up to the length of the shorter string, n is minus-one (-1) if the first
  2710                        ; non-matching character in the string specified by c-addr1 u1 has a lesser
  2711                        ; numeric value than the corresponding character in the string specified by
  2712                        ; c-addr2 u2 and one (1) otherwise.
  2713                        
  2714 00:136D: 47 13 00 07                  HEADER  7,"COMPARE",NORMAL
       00:1371: 43 4F 4D 50 
       00:1375: 41 52 45 
  2715 00:1378: 20 32 14     COMPARE:        jsr     DO_COLON
  2716                        ; TODO
  2717 00:137B: BB C8 C8 7C                  CONTINUE
       00:137F: 00 00 
  2718                        
  2719                        ; COUNT ( c-addr1 -- c-addr2 u )
  2720                        ;
  2721                        ; Return the character string specification for the counted string stored at
  2722                        ; c-addr1. c-addr2 is the address of the first character after c-addr1. u is
  2723                        ; the contents of the character at c-addr1, which is the length in characters
  2724                        ; of the string at c-addr2.
  2725                        ;
  2726                        ; In this implementation it is defined as
  2727                        ;
  2728                        ;   DUP CHAR+ SWAP C@
  2729                        
  2730 00:1381: 70 13 00 05                  HEADER  5,"COUNT",NORMAL
       00:1385: 43 4F 55 4E 
       00:1389: 54 
  2731 00:138A: 20 32 14     COUNT:          jsr     DO_COLON
  2732 00:138D: 80 07                        dw      DUP
  2733 00:138F: 75 06                        dw      CHAR_PLUS
  2734 00:1391: F6 07                        dw      SWAP
  2735 00:1393: 07 06                        dw      C_FETCH
  2736 00:1395: AD 0E                        dw      EXIT
  2737                        
  2738                        ; SEARCH ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
  2739                        ;
  2740                        ; Search the string specified by c-addr1 u1 for the string specified by c-addr2
  2741                        ; u2. If flag is true, a match was found at c-addr3 with u3 characters
  2742                        ; remaining. If flag is false there was no match and c-addr3 is c-addr1 and u3
  2743                        ; is u1.
  2744                        
  2745 00:1397: 84 13 00 06                  HEADER  6,"SEARCH",NORMAL
  Mon Apr 18 2016 23:59                                                                                                    Page 55


       00:139B: 53 45 41 52 
       00:139F: 43 48 
  2746 00:13A1: 20 32 14     SEARCH:         jsr     DO_COLON
  2747                        ; TODO
  2748 00:13A4: BB C8 C8 7C                  CONTINUE
       00:13A8: 00 00 
  2749                        
  2750                        ;===============================================================================
  2751                        ; Compiling Words
  2752                        ;-------------------------------------------------------------------------------
  2753                        
  2754                        ; ( ( -- )
  2755                        ;
  2756                        ; Parse ccc delimited by ) (right parenthesis). ( is an immediate word.
  2757                        ;
  2758                        ; The number of characters in ccc may be zero to the number of characters in the
  2759                        ; parse area.
  2760                        ;
  2761                        ; In this implementation it is defined as:
  2762                        ;
  2763                        ;  [ HEX ] 29 WORD DROP ; IMMEDIATE
  2764                        
  2765 00:13AA: 9A 13 80 01                  HEADER  1,"(",IMMEDIATE
       00:13AE: 28 
  2766 00:13AF: 20 32 14                     jsr     DO_COLON
  2767 00:13B2: 08 16 29 00                  dw      DO_LITERAL,')'
  2768 00:13B6: 7B 12                        dw      WORD
  2769 00:13B8: 6F 07                        dw      DROP
  2770 00:13BA: AD 0E                        dw      EXIT
  2771                        
  2772                        ; .(
  2773                        
  2774 00:13BC: AD 13 80 02                  HEADER  2,".(",IMMEDIATE
       00:13C0: 2E 28 
  2775 00:13C2: 20 32 14     DOT_PAREN:      jsr     DO_COLON
  2776 00:13C5: 08 16 29 00                  dw      DO_LITERAL,')'
  2777 00:13C9: 7B 12                        dw      WORD
  2778 00:13CB: 8A 13                        dw      COUNT
  2779 00:13CD: 34 18                        dw      TYPE
  2780 00:13CF: AD 0E                        dw      EXIT
  2781                        
  2782                        ; ." ( -- )
  2783                        
  2784 00:13D1: BF 13 80     		LINK 	IMMEDIATE
  2785 00:13D4: 02 2E 22     		db	2,".",'"'
  2786 00:13D7: 20 32 14     DOT_QUOTE:	jsr	DO_COLON
  2787 00:13DA: 9E 16        		dw	S_QUOTE
  2788 00:13DC: 08 16 34 18  		dw	DO_LITERAL,TYPE
  2789 00:13E0: 74 05        		dw	COMMA
  2790 00:13E2: AD 0E        		dw	EXIT
  2791                        		
  2792                        
  2793                        ; +LOOP ( -- )
  2794                        
  2795 00:13E4: D4 13 80 05                  HEADER  5,"+LOOP",IMMEDIATE
       00:13E8: 2B 4C 4F 4F 
       00:13EC: 50 
  2796 00:13ED: 20 32 14     PLUS_LOOP:      jsr     DO_COLON
  Mon Apr 18 2016 23:59                                                                                                    Page 56


  2797 00:13F0: 08 16 FA 13                  dw      DO_LITERAL,DO_PLUS_LOOP
  2798 00:13F4: 74 05                        dw      COMMA
  2799 00:13F6: 74 05                        dw      COMMA
  2800 00:13F8: AD 0E                        dw      EXIT
  2801                        
  2802                        DO_PLUS_LOOP:
  2803 00:13FA: A6 01                        ldx     <1                      ; Fetch increment
  2804 00:13FC: 7B                           tdc                             ; And drop
  2805 00:13FD: 1A                           inc     a
  2806 00:13FE: 1A                           inc     a
  2807 00:13FF: 5B                           tcd
  2808 00:1400: 18                           clc                             ; Add to loop counter
  2809 00:1401: 8A                           txa
  2810 00:1402: 63 01                        adc     1,s
  2811 00:1404: 83 01                        sta     1,s
  2812 00:1406: C3 03                        cmp     3,s                     ; Reached limit?
  2813 00:1408: B0 0A                        bcs     DO_PLOOP_END            ; Yes
  2814 00:140A: B9 00 00                     lda     !0,y                    ; No, branch back to start
  2815 00:140D: A8                           tay
  2816 00:140E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1412: 00 00 
  2817                        
  2818 00:1414: C8           DO_PLOOP_END:   iny                             ; Skip over address
  2819 00:1415: C8                           iny
  2820 00:1416: 68                           pla                             ; Drop loop variables
  2821 00:1417: 68                           pla
  2822 00:1418: BB C8 C8 7C                  CONTINUE                        ; Done
       00:141C: 00 00 
  2823                        
  2824                        ; : ( -- )
  2825                        
  2826 00:141E: E7 13 00 01                  HEADER  1,":",NORMAL
       00:1422: 3A 
  2827 00:1423: 20 32 14     COLON:          jsr     DO_COLON
  2828 00:1426: 72 0E                        dw      CREATE
  2829 00:1428: 08 16 32 14                  dw      DO_LITERAL,DO_COLON
  2830 00:142C: 5B 0E                        dw      BUILD
  2831 00:142E: A4 17                        dw      RIGHT_BRACKET
  2832 00:1430: AD 0E                        dw      EXIT
  2833                        
  2834                        DO_COLON:
  2835 00:1432: FA                           plx                             ; Pull new word IP-1
  2836 00:1433: 5A                           phy                             ; Save the old IP
  2837 00:1434: E8                           inx                             ; Work out new IP
  2838 00:1435: 9B                           txy
  2839 00:1436: BB C8 C8 7C                  CONTINUE                        ; Done
       00:143A: 00 00 
  2840                        
  2841                        ; :NONAME ( -- xt )
  2842                        
  2843 00:143C: 21 14 00 07                  HEADER  7,":NONAME",NORMAL
       00:1440: 3A 4E 4F 4E 
       00:1444: 41 4D 45 
  2844 00:1447: 20 32 14     NONAME:         jsr     DO_COLON
  2845 00:144A: 1F 06                        dw      HERE
  2846 00:144C: 08 16 32 14                  dw      DO_LITERAL,DO_COLON
  2847 00:1450: 5B 0E                        dw      BUILD
  2848 00:1452: A4 17                        dw      RIGHT_BRACKET
  Mon Apr 18 2016 23:59                                                                                                    Page 57


  2849 00:1454: AD 0E                        dw      EXIT
  2850                        
  2851                        ; ; ( -- )
  2852                        
  2853 00:1456: 3F 14 80                     LINK    IMMEDIATE
  2854 00:1459: 01 3B                        db      1,";"
  2855 00:145B: 20 32 14     SEMICOLON:      jsr     DO_COLON
  2856 00:145E: 08 16 AD 0E                  dw      DO_LITERAL,EXIT
  2857 00:1462: 74 05                        dw      COMMA
  2858 00:1464: 82 17                        dw      LEFT_BRACKET
  2859 00:1466: AD 0E                        dw      EXIT
  2860                        
  2861                        ; 2CONSTANT ( x <spaces>name -- )
  2862                        ;
  2863                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2864                        ; definition for name with the execution semantics defined below.
  2865                        
  2866 00:1468: 59 14 00 09                  HEADER  9,"2CONSTANT",NORMAL
       00:146C: 32 43 4F 4E 
       00:1470: 53 54 41 4E 
       00:1474: 54 
  2867 00:1475: 20 32 14     TWO_CONSTANT:   jsr     DO_COLON
  2868 00:1478: 72 0E                        dw      CREATE
  2869 00:147A: 08 16 86 14                  dw      DO_LITERAL,DO_TWO_CONSTANT
  2870 00:147E: 5B 0E                        dw      BUILD
  2871 00:1480: 74 05                        dw      COMMA
  2872 00:1482: 74 05        		dw	COMMA
  2873 00:1484: AD 0E                        dw      EXIT; AGAIN ( -- )
  2874                        
  2875                        DO_TWO_CONSTANT:
  2876 00:1486: FA                           plx				; Get return address
  2877 00:1487: 7B                           tdc				; Create space on stack
  2878 00:1488: 3A                           dec     a
  2879 00:1489: 3A                           dec     a
  2880 00:148A: 3A           		dec	a
  2881 00:148B: 3A           		dec	a
  2882 00:148C: 5B                           tcd
  2883 00:148D: BD 01 00                     lda     !1,x			; Transfer the value
  2884 00:1490: 85 01                        sta     <1
  2885 00:1492: BD 03 00     		lda	!3,x
  2886 00:1495: 85 03        		sta	<3
  2887 00:1497: BB C8 C8 7C                  CONTINUE                        ; Done		
       00:149B: 00 00 
  2888                        
  2889                        ; 2LITERAL
  2890                        
  2891 00:149D: 6B 14 80 08  		HEADER	8,"2LITERAL",IMMEDIATE
       00:14A1: 32 4C 49 54 
       00:14A5: 45 52 41 4C 
  2892 00:14A9: 20 32 14     TWO_LITERAL:	jsr	DO_COLON
  2893 00:14AC: 08 16 B8 14  		dw	DO_LITERAL,DO_TWO_LITERAL
  2894 00:14B0: 74 05        		dw	COMMA
  2895 00:14B2: 74 05        		dw	COMMA
  2896 00:14B4: 74 05        		dw	COMMA
  2897 00:14B6: AD 0E        		dw	EXIT
  2898                        		
  2899                        DO_TWO_LITERAL:
  2900 00:14B8: 7B                           tdc				; Make room on stack
  Mon Apr 18 2016 23:59                                                                                                    Page 58


  2901 00:14B9: 3A                           dec     a
  2902 00:14BA: 3A                           dec     a
  2903 00:14BB: 3A           		dec	a
  2904 00:14BC: 3A           		dec	a
  2905 00:14BD: 5B                           tcd
  2906 00:14BE: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  2907 00:14C1: 85 01                        sta     <1
  2908 00:14C3: B9 02 00     		lda	!2,y
  2909 00:14C6: 85 03        		sta	<3
  2910 00:14C8: C8                           iny				; Bump IP
  2911 00:14C9: C8                           iny
  2912 00:14CA: C8           		iny
  2913 00:14CB: C8           		iny
  2914 00:14CC: BB C8 C8 7C                  CONTINUE                        ; Done		
       00:14D0: 00 00 
  2915                        
  2916                        ; 2VARIABLE
  2917                        
  2918 00:14D2: A0 14 80 09  		HEADER	9,"2VARIABLE",IMMEDIATE
       00:14D6: 32 56 41 52 
       00:14DA: 49 41 42 4C 
       00:14DE: 45 
  2919 00:14DF: 20 32 14     TWO_VARIABLE:	jsr	DO_COLON
  2920 00:14E2: 72 0E                        dw      CREATE
  2921 00:14E4: 08 16 47 17                  dw      DO_LITERAL,DO_VARIABLE
  2922 00:14E8: 5B 0E                        dw      BUILD
  2923 00:14EA: 08 16 02 00                  dw      DO_LITERAL,2
  2924 00:14EE: 64 06                        dw      CELLS
  2925 00:14F0: C7 05                        dw      ALLOT
  2926 00:14F2: AD 0E                        dw      EXIT
  2927                        
  2928                        ; ABORT" ( -- )
  2929                        
  2930 00:14F4: D5 14 80     		LINK	IMMEDIATE
  2931 00:14F7: 06 41 42 4F  		db	6,"ABORT",'"'
       00:14FB: 52 54 22 
  2932 00:14FE: 20 32 14     ABORT_QUOTE:	jsr	DO_COLON
  2933 00:1501: 9E 16        		dw	S_QUOTE
  2934 00:1503: 08 16 30 0E  		dw	DO_LITERAL,QUERY_ABORT
  2935 00:1507: 74 05        		dw	COMMA
  2936 00:1509: AD 0E        		dw	EXIT
  2937                        		
  2938                        ; AGAIN ( -- )
  2939 00:150B: F7 14 80 05                  HEADER  5,"AGAIN",IMMEDIATE
       00:150F: 41 47 41 49 
       00:1513: 4E 
  2940 00:1514: 20 32 14     AGAIN:          jsr     DO_COLON
  2941 00:1517: 08 16 A0 15                  dw      DO_LITERAL,BRANCH
  2942 00:151B: 74 05                        dw      COMMA
  2943 00:151D: 74 05                        dw      COMMA
  2944 00:151F: AD 0E                        dw      EXIT
  2945                        
  2946                        ; BEGIN ( -- )
  2947                        
  2948 00:1521: 0E 15 80 05                  HEADER  5,"BEGIN",IMMEDIATE
       00:1525: 42 45 47 49 
       00:1529: 4E 
  2949 00:152A: 20 32 14     BEGIN:          jsr     DO_COLON
  Mon Apr 18 2016 23:59                                                                                                    Page 59


  2950 00:152D: 1F 06                        dw      HERE
  2951 00:152F: AD 0E                        dw      EXIT
  2952                        
  2953                        ; CONSTANT ( x <spaces>name -- )
  2954                        ;
  2955                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2956                        ; definition for name with the execution semantics defined below.
  2957                        
  2958 00:1531: 24 15 00 08                  HEADER  8,"CONSTANT",NORMAL
       00:1535: 43 4F 4E 53 
       00:1539: 54 41 4E 54 
  2959 00:153D: 20 32 14     CONSTANT:       jsr     DO_COLON
  2960 00:1540: 72 0E                        dw      CREATE
  2961 00:1542: 08 16 4C 15                  dw      DO_LITERAL,DO_CONSTANT
  2962 00:1546: 5B 0E                        dw      BUILD
  2963 00:1548: 74 05                        dw      COMMA
  2964 00:154A: AD 0E                        dw      EXIT
  2965                        
  2966                        DO_CONSTANT:
  2967 00:154C: FA                           plx				; Get return address
  2968 00:154D: 7B                           tdc				; Create space on stack
  2969 00:154E: 3A                           dec     a
  2970 00:154F: 3A                           dec     a
  2971 00:1550: 5B                           tcd
  2972 00:1551: BD 01 00                     lda     !1,x			; Transfer the value
  2973 00:1554: 85 01                        sta     <1
  2974 00:1556: BB C8 C8 7C                  CONTINUE                        ; Done
       00:155A: 00 00 
  2975                        
  2976                        ; DO ( -- )
  2977                        
  2978 00:155C: 34 15 80 02                  HEADER  2,"DO",IMMEDIATE
       00:1560: 44 4F 
  2979 00:1562: 20 32 14     DO:             jsr     DO_COLON
  2980 00:1565: 08 16 6F 15                  dw      DO_LITERAL,DO_DO
  2981 00:1569: 74 05                        dw      COMMA
  2982 00:156B: 1F 06                        dw      HERE
  2983 00:156D: AD 0E                        dw      EXIT
  2984                        
  2985                        DO_DO:
  2986 00:156F: A5 03                        lda     <3
  2987 00:1571: 48                           pha
  2988 00:1572: A5 01                        lda     <1
  2989 00:1574: 48                           pha
  2990 00:1575: 7B                           tdc
  2991 00:1576: 1A                           inc     a
  2992 00:1577: 1A                           inc     a
  2993 00:1578: 1A                           inc     a
  2994 00:1579: 1A                           inc     a
  2995 00:157A: 5B                           tcd
  2996 00:157B: BB C8 C8 7C                  CONTINUE
       00:157F: 00 00 
  2997                        
  2998                        ; ELSE ( -- )
  2999                        
  3000 00:1581: 5F 15 80 04                  HEADER  4,"ELSE",IMMEDIATE
       00:1585: 45 4C 53 45 
  3001 00:1589: 20 32 14     ELSE:           jsr     DO_COLON
  Mon Apr 18 2016 23:59                                                                                                    Page 60


  3002 00:158C: 08 16 A0 15                  dw      DO_LITERAL,BRANCH
  3003 00:1590: 74 05                        dw      COMMA
  3004 00:1592: 1F 06                        dw      HERE
  3005 00:1594: C9 04                        dw      ZERO
  3006 00:1596: 74 05                        dw      COMMA
  3007 00:1598: 1F 06                        dw      HERE
  3008 00:159A: F6 07                        dw      SWAP
  3009 00:159C: 46 05                        dw      STORE
  3010 00:159E: AD 0E                        dw      EXIT
  3011                        
  3012                        BRANCH:
  3013 00:15A0: B9 00 00                     lda     !0,y                    ; Load branch address into IP
  3014 00:15A3: A8                           tay
  3015 00:15A4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:15A8: 00 00 
  3016                        
  3017                        ; IF ( -- )
  3018                        
  3019 00:15AA: 84 15 80 02                  HEADER  2,"IF",IMMEDIATE
       00:15AE: 49 46 
  3020 00:15B0: 20 32 14     IF:             jsr     DO_COLON
  3021 00:15B3: 08 16 C1 15                  dw      DO_LITERAL,QUERY_BRANCH
  3022 00:15B7: 74 05                        dw      COMMA
  3023 00:15B9: 1F 06                        dw      HERE
  3024 00:15BB: C9 04                        dw      ZERO
  3025 00:15BD: 74 05                        dw      COMMA
  3026 00:15BF: AD 0E                        dw      EXIT
  3027                        		
  3028                        QUERY_BRANCH:
  3029 00:15C1: A6 01                        ldx     <1                      ; Pull the top of stack value
  3030 00:15C3: 7B                           tdc
  3031 00:15C4: 1A                           inc     a                       ; Drop top item
  3032 00:15C5: 1A                           inc     a
  3033 00:15C6: 5B                           tcd
  3034 00:15C7: 8A                           txa
  3035 00:15C8: F0 D6                        beq     BRANCH                  ; Branch if top was zero
  3036 00:15CA: C8                           iny                             ; Otherwise skip address
  3037 00:15CB: C8                           iny
  3038 00:15CC: BB C8 C8 7C                  CONTINUE                        ; Done
       00:15D0: 00 00 
  3039                        
  3040                        ; IMMEDIATE ( -- )
  3041                        
  3042 00:15D2: AD 15 80 09  		HEADER	9,"IMMEDIATE",IMMEDIATE
       00:15D6: 49 4D 4D 45 
       00:15DA: 44 49 41 54 
       00:15DE: 45 
  3043 00:15DF: 20 32 14     		jsr	DO_COLON
  3044 00:15E2: 08 16 80 00  		dw	DO_LITERAL,IMMEDIATE
  3045 00:15E6: 8F 04        		dw	LATEST
  3046 00:15E8: B4 05        		dw	FETCH
  3047 00:15EA: 58 09        		dw	ONE_MINUS
  3048 00:15EC: D6 05        		dw	C_STORE
  3049 00:15EE: AD 0E        		dw	EXIT
  3050                        		
  3051                        ; LITERAL ( x -- )
  3052                        ;
  3053                        ; Append the run-time semantics given below to the current definition.
  Mon Apr 18 2016 23:59                                                                                                    Page 61


  3054                        
  3055 00:15F0: D5 15 80 07                  HEADER  7,"LITERAL",IMMEDIATE
       00:15F4: 4C 49 54 45 
       00:15F8: 52 41 4C 
  3056 00:15FB: 20 32 14     LITERAL:        jsr     DO_COLON
  3057 00:15FE: 08 16 08 16                  dw      DO_LITERAL,DO_LITERAL
  3058 00:1602: 74 05                        dw      COMMA
  3059 00:1604: 74 05                        dw      COMMA
  3060 00:1606: AD 0E                        dw      EXIT
  3061                        
  3062                        DO_LITERAL:
  3063 00:1608: 7B                           tdc				; Make room on stack
  3064 00:1609: 3A                           dec     a
  3065 00:160A: 3A                           dec     a
  3066 00:160B: 5B                           tcd
  3067 00:160C: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  3068 00:160F: 85 01                        sta     <1
  3069 00:1611: C8                           iny
  3070 00:1612: C8                           iny
  3071 00:1613: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1617: 00 00 
  3072                        
  3073                        ; LOOP
  3074                        
  3075 00:1619: F3 15 80 04                  HEADER  4,"LOOP",IMMEDIATE
       00:161D: 4C 4F 4F 50 
  3076 00:1621: 20 32 14     LOOP:           jsr     DO_COLON
  3077 00:1624: 08 16 2E 16                  dw      DO_LITERAL,DO_LOOP
  3078 00:1628: 74 05                        dw      COMMA
  3079 00:162A: 74 05                        dw      COMMA
  3080 00:162C: AD 0E                        dw      EXIT
  3081                        
  3082                        ; (LOOP)
  3083                        
  3084                        ;               HEADER  6,"(LOOP)",NORMAL
  3085                        DO_LOOP
  3086 00:162E: A3 01                        lda     1,s                     ; Add one to loop counter
  3087 00:1630: 1A                           inc     a
  3088 00:1631: 83 01                        sta     1,s
  3089 00:1633: C3 03                        cmp     3,s                     ; Reached limit?
  3090 00:1635: B0 0A                        bcs     DO_LOOP_END             ; Yes
  3091 00:1637: B9 00 00                     lda     !0,y                    ; No, branch back to start
  3092 00:163A: A8                           tay
  3093 00:163B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:163F: 00 00 
  3094                        
  3095 00:1641: C8           DO_LOOP_END:    iny                             ; Skip over address
  3096 00:1642: C8                           iny
  3097 00:1643: 68                           pla                             ; Drop loop variables
  3098 00:1644: 68                           pla
  3099 00:1645: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1649: 00 00 
  3100                        
  3101                        ; POSTPONE
  3102                        
  3103                        ;   BL WORD FIND
  3104                        ;   DUP 0= ABORT" ?"
  3105                        ;   0< IF   -- xt	non immed: add code to current
  Mon Apr 18 2016 23:59                                                                                                    Page 62


  3106                        ;			def'n to compile xt later.
  3107                        ;       ['] LIT ,XT  ,	add "LIT,xt,COMMAXT"
  3108                        ;       ['] ,XT ,XT	to current definition
  3109                        ;   ELSE  ,XT      immed: compile into cur. def'n
  3110                        ;   THEN ; IMMEDIATE
  3111                        
  3112 00:164B: 1C 16 80 08  		HEADER	8,"POSTPONE",IMMEDIATE
       00:164F: 50 4F 53 54 
       00:1653: 50 4F 4E 45 
  3113 00:1657: 20 32 14     POSTPONE:	jsr	DO_COLON
  3114 00:165A: DB 04        		dw	BL
  3115 00:165C: 7B 12        		dw	WORD
  3116 00:165E: 10 11        		dw	FIND
  3117 00:1660: 80 07        		dw	DUP
  3118 00:1662: CC 0C        		dw	ZERO_EQUAL
  3119 00:1664: B7 16        		dw	DO_S_QUOTE
  3120 00:1666: 01 3F        		db	1,"?"
  3121 00:1668: 30 0E        		dw	QUERY_ABORT
  3122 00:166A: A3 0C        		dw	ZERO_LESS
  3123 00:166C: C1 15 7C 16  		dw	QUERY_BRANCH,POSTPONE_1
  3124 00:1670: 08 16 08 16  		dw	DO_LITERAL,DO_LITERAL
  3125 00:1674: 74 05        		dw	COMMA
  3126 00:1676: 74 05        		dw	COMMA
  3127 00:1678: A0 15 7E 16  		dw	BRANCH,POSTPONE_2
  3128 00:167C: 74 05        POSTPONE_1:	dw	COMMA
  3129 00:167E: AD 0E        POSTPONE_2:	dw	EXIT
  3130                        		
  3131                        ; RECURSE ( -- )
  3132                        
  3133 00:1680: 4E 16 80 07                  HEADER  7,"RECURSE",IMMEDIATE
       00:1684: 52 45 43 55 
       00:1688: 52 53 45 
  3134 00:168B: 20 32 14     RECURSE:        jsr     DO_COLON
  3135 00:168E: 8F 04                        dw      LATEST
  3136 00:1690: B4 05                        dw      FETCH
  3137 00:1692: 58 11                        dw      NFA_TO_CFA
  3138 00:1694: 74 05                        dw      COMMA
  3139 00:1696: AD 0E                        dw      EXIT
  3140                        
  3141                        ; S"
  3142                        
  3143 00:1698: 83 16 80                     LINK    IMMEDIATE
  3144 00:169B: 02 53 22                     db      2,"S",'"'
  3145 00:169E: 20 32 14     S_QUOTE:        jsr     DO_COLON
  3146 00:16A1: 08 16 B7 16  		dw	DO_LITERAL,DO_S_QUOTE
  3147 00:16A5: 74 05        		dw	COMMA
  3148 00:16A7: 08 16 22 00  		dw	DO_LITERAL,'"'
  3149 00:16AB: 7B 12        		dw	WORD
  3150 00:16AD: 07 06        		dw	C_FETCH
  3151 00:16AF: 4A 09        		dw	ONE_PLUS
  3152 00:16B1: 42 06        		dw	ALIGNED
  3153 00:16B3: C7 05        		dw	ALLOT
  3154 00:16B5: AD 0E                        dw      EXIT
  3155                        
  3156                        ; (S") ( -- c-addr u )
  3157                        
  3158                        DO_S_QUOTE:
  3159 00:16B7: 20 32 14     		jsr	DO_COLON
  Mon Apr 18 2016 23:59                                                                                                    Page 63


  3160 00:16BA: A1 08        		dw	R_FROM
  3161 00:16BC: 8A 13        		dw	COUNT
  3162 00:16BE: BA 06        		dw	TWO_DUP
  3163 00:16C0: FA 08        		dw	PLUS
  3164 00:16C2: 42 06        		dw	ALIGNED
  3165 00:16C4: 68 08        		dw	TO_R
  3166 00:16C6: AD 0E        		dw	EXIT
  3167                        
  3168                        ; THEN ( -- )
  3169                        
  3170 00:16C8: 9B 16 80 04                  HEADER  4,"THEN",IMMEDIATE
       00:16CC: 54 48 45 4E 
  3171 00:16D0: 20 32 14     THEN:           jsr     DO_COLON
  3172 00:16D3: 1F 06                        dw      HERE
  3173 00:16D5: F6 07                        dw      SWAP
  3174 00:16D7: 46 05                        dw      STORE
  3175 00:16D9: AD 0E                        dw      EXIT
  3176                        
  3177                        ; UNTIL ( -- )
  3178                        
  3179 00:16DB: CB 16 80 05                  HEADER  5,"UNTIL",IMMEDIATE
       00:16DF: 55 4E 54 49 
       00:16E3: 4C 
  3180 00:16E4: 20 32 14     UNTIL:          jsr     DO_COLON
  3181 00:16E7: 08 16 C1 15                  dw      DO_LITERAL,QUERY_BRANCH
  3182 00:16EB: 74 05                        dw      COMMA
  3183 00:16ED: 74 05                        dw      COMMA
  3184 00:16EF: AD 0E                        dw      EXIT
  3185                        
  3186                        ; USER
  3187                        
  3188 00:16F1: DE 16 00 04                  HEADER  4,"USER",NORMAL
       00:16F5: 55 53 45 52 
  3189 00:16F9: 20 32 14     USER:           jsr     DO_COLON
  3190 00:16FC: 72 0E                        dw      CREATE
  3191 00:16FE: 08 16 12 17                  dw      DO_LITERAL,DO_USER
  3192 00:1702: 5B 0E                        dw      BUILD
  3193 00:1704: 74 05                        dw      COMMA
  3194 00:1706: AD 0E                        dw      EXIT
  3195                        
  3196 00:1708: F4 16 00 06                  HEADER  6,"(USER)",NORMAL
       00:170C: 28 55 53 45 
       00:1710: 52 29 
  3197                        DO_USER:
  3198 00:1712: 7B                           tdc
  3199 00:1713: 3A                           dec     a                       ; Push on data stack
  3200 00:1714: 3A                           dec     a
  3201 00:1715: 5B                           tcd
  3202 00:1716: FA                           plx
  3203 00:1717: 18                           clc
  3204 00:1718: BD 01 00                     lda     !1,x
  3205 00:171B: 69 00 00                     adc     #USER_AREA
  3206 00:171E: 85 01                        sta     <1
  3207 00:1720: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1724: 00 00 
  3208                        
  3209                        ; VARIABLE ( <spaces>name -- )
  3210                        ;
  Mon Apr 18 2016 23:59                                                                                                    Page 64


  3211                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  3212                        ; definition for name with the execution semantics defined below. Reserve one
  3213                        ; cell of data space at an aligned address.
  3214                        
  3215 00:1726: 0B 17 00                     LINK    NORMAL
  3216 00:1729: 08 56 41 52                  db      8,"VARIABLE"
       00:172D: 49 41 42 4C 
       00:1731: 45 
  3217 00:1732: 20 32 14     VARIABLE:       jsr     DO_COLON
  3218 00:1735: 72 0E                        dw      CREATE
  3219 00:1737: 08 16 47 17                  dw      DO_LITERAL,DO_VARIABLE
  3220 00:173B: 5B 0E                        dw      BUILD
  3221 00:173D: 08 16 01 00                  dw      DO_LITERAL,1
  3222 00:1741: 64 06                        dw      CELLS
  3223 00:1743: C7 05                        dw      ALLOT
  3224 00:1745: AD 0E                        dw      EXIT
  3225                        
  3226                        DO_VARIABLE:
  3227 00:1747: 7B                           tdc
  3228 00:1748: 3A                           dec     a
  3229 00:1749: 3A                           dec     a
  3230 00:174A: 5B                           tcd
  3231 00:174B: 68                           pla
  3232 00:174C: 1A                           inc     a
  3233 00:174D: 85 01                        sta     <1
  3234 00:174F: BB C8 C8 7C                  CONTINUE
       00:1753: 00 00 
  3235                        
  3236                        ; WORDS ( -- )
  3237                        ;
  3238                        ;   LATEST @ BEGIN
  3239                        ;       DUP COUNT TYPE SPACE
  3240                        ;       NFA>LFA @
  3241                        ;   DUP 0= UNTIL
  3242                        ;   DROP ;
  3243                        
  3244 00:1755: 29 17 00 05                  HEADER  5,"WORDS",NORMAL
       00:1759: 57 4F 52 44 
       00:175D: 53 
  3245 00:175E: 20 32 14                     jsr     DO_COLON
  3246 00:1761: 8F 04                        dw      LATEST
  3247 00:1763: B4 05                        dw      FETCH
  3248 00:1765: 80 07        WORDS_1:        dw      DUP
  3249 00:1767: 8A 13                        dw      COUNT
  3250 00:1769: 34 18                        dw      TYPE
  3251 00:176B: 02 18                        dw      SPACE
  3252 00:176D: 61 11                        dw      NFA_TO_LFA
  3253 00:176F: B4 05                        dw      FETCH
  3254 00:1771: 80 07                        dw      DUP
  3255 00:1773: CC 0C                        dw      ZERO_EQUAL
  3256 00:1775: C1 15 65 17                  dw      QUERY_BRANCH,WORDS_1
  3257 00:1779: 6F 07                        dw      DROP
  3258 00:177B: AD 0E                        dw      EXIT
  3259                        
  3260                        ; [
  3261                        ;
  3262                        ; In this implementation it is defined as
  3263                        ;
  Mon Apr 18 2016 23:59                                                                                                    Page 65


  3264                        ;   0 STATE !
  3265                        
  3266 00:177D: 58 17 80 01                  HEADER  1,"[",IMMEDIATE
       00:1781: 5B 
  3267 00:1782: 20 32 14     LEFT_BRACKET:   jsr     DO_COLON
  3268 00:1785: C9 04                        dw      ZERO
  3269 00:1787: B3 04                        dw      STATE
  3270 00:1789: 46 05                        dw      STORE
  3271 00:178B: AD 0E                        dw      EXIT
  3272                        
  3273                        ; \ ( -- )
  3274                        ;
  3275                        ; Parse and discard the remainder of the parse area. \ is an immediate word.
  3276                        ;
  3277                        ; In this implementation it is defined as
  3278                        ;
  3279                        ;   1 WORD DROP
  3280                        
  3281 00:178D: 80 17 80 01                  HEADER  1,"\",IMMEDIATE
       00:1791: 5C 
  3282 00:1792: 20 32 14     BACKSLASH:      jsr     DO_COLON
  3283 00:1795: 08 16 01 00                  dw      DO_LITERAL,1
  3284 00:1799: 7B 12                        dw      WORD
  3285 00:179B: 6F 07                        dw      DROP
  3286 00:179D: AD 0E                        dw      EXIT
  3287                        
  3288                        ; ]
  3289                        ;
  3290                        ; In this implementation it is defined as
  3291                        ;
  3292                        ;   -1 STATE !
  3293                        
  3294 00:179F: 90 17 00 01                  HEADER  1,"]",NORMAL
       00:17A3: 5D 
  3295 00:17A4: 20 32 14     RIGHT_BRACKET:  jsr     DO_COLON
  3296 00:17A7: 08 16 FF FF                  dw      DO_LITERAL,-1
  3297 00:17AB: B3 04                        dw      STATE
  3298 00:17AD: 46 05                        dw      STORE
  3299 00:17AF: AD 0E                        dw      EXIT
  3300                        
  3301                        ;===============================================================================
  3302                        ; I/O Operations
  3303                        ;-------------------------------------------------------------------------------
  3304                        
  3305                        ; CR ( -- )
  3306                        ;
  3307                        ; Cause subsequent output to appear at the beginning of the next line.
  3308                        ;
  3309                        ; In this implementation it is defined as
  3310                        ;
  3311                        ;   13 EMIT 10 EMIT
  3312                        
  3313 00:17B1: A2 17 00 02                  HEADER  2,"CR",NORMAL
       00:17B5: 43 52 
  3314 00:17B7: 20 32 14     CR:             jsr     DO_COLON
  3315 00:17BA: 08 16 0D 00                  dw      DO_LITERAL,13
  3316 00:17BE: D0 17                        dw      EMIT
  3317 00:17C0: 08 16 0A 00                  dw      DO_LITERAL,10
  Mon Apr 18 2016 23:59                                                                                                    Page 66


  3318 00:17C4: D0 17                        dw      EMIT
  3319 00:17C6: AD 0E                        dw      EXIT
  3320                        
  3321                        ; EMIT ( x -- )
  3322                        ;
  3323                        ; If x is a graphic character in the implementation-defined character set,
  3324                        ; display x. The effect of EMIT for all other values of x is implementation
  3325                        ; -defined.
  3326                        
  3327 00:17C8: B4 17 00 04                  HEADER  4,"EMIT",NORMAL
       00:17CC: 45 4D 49 54 
  3328                                        extern  UartTx
  3329                        EMIT:
  3330 00:17D0: A5 01                        lda     <1                      ; Fetch character from stack
  3331 00:17D2: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  3332 00:17D5: 7B                           tdc
  3333 00:17D6: 1A                           inc     a                       ; Drop the character
  3334 00:17D7: 1A                           inc     a
  3335 00:17D8: 5B                           tcd
  3336 00:17D9: BB C8 C8 7C                  CONTINUE                        ; Done
       00:17DD: 00 00 
  3337                        
  3338                        ; KEY ( -- char )
  3339                        ;
  3340                        ; Receive one character char, a member of the implementation-defined character
  3341                        ; set. Keyboard events that do not correspond to such characters are discarded
  3342                        ; until a valid character is received, and those events are subsequently
  3343                        ; unavailable.
  3344                        ;
  3345                        ; All standard characters can be received. Characters received by KEY are not
  3346                        ; displayed.
  3347                        
  3348 00:17DF: CB 17 00 03                  HEADER  3,"KEY",NORMAL
       00:17E3: 4B 45 59 
  3349                                        extern  UartRx
  3350                        KEY:
  3351 00:17E6: 20 xx xx                     jsr     UartRx                  ; Receive a character
  3352 00:17E9: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  3353 00:17EC: AA                           tax
  3354 00:17ED: 7B                           tdc
  3355 00:17EE: 3A                           dec     a                       ; And push to stack
  3356 00:17EF: 3A                           dec     a
  3357 00:17F0: 5B                           tcd
  3358 00:17F1: 86 01                        stx     <1
  3359 00:17F3: BB C8 C8 7C                  CONTINUE                        ; Done
       00:17F7: 00 00 
  3360                        
  3361                        ; SPACE ( -- )
  3362                        ;
  3363                        ; Display one space.
  3364                        ;
  3365                        ; In this implementation it is defined as
  3366                        ;
  3367                        ;   BL EMIT
  3368                        
  3369 00:17F9: E2 17 00 05                  HEADER  5,"SPACE",NORMAL
       00:17FD: 53 50 41 43 
       00:1801: 45 
  Mon Apr 18 2016 23:59                                                                                                    Page 67


  3370 00:1802: 20 32 14     SPACE:          jsr     DO_COLON
  3371 00:1805: DB 04                        dw      BL
  3372 00:1807: D0 17                        dw      EMIT
  3373 00:1809: AD 0E                        dw      EXIT
  3374                        
  3375                        ; SPACES ( n -- )
  3376                        ;
  3377                        ; If n is greater than zero, display n spaces.
  3378                        ;
  3379                        ; In this implementation it is defined as
  3380                        ;
  3381                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  3382                        
  3383 00:180B: FC 17 00 06                  HEADER  6,"SPACES",NORMAL
       00:180F: 53 50 41 43 
       00:1813: 45 53 
  3384 00:1815: 20 32 14     SPACES:         jsr     DO_COLON
  3385 00:1818: 80 07        SPACES_1:       dw      DUP
  3386 00:181A: E0 0C                        dw      ZERO_GREATER
  3387 00:181C: C1 15 28 18                  dw      QUERY_BRANCH,SPACES_2
  3388 00:1820: 02 18                        dw      SPACE
  3389 00:1822: 58 09                        dw      ONE_MINUS
  3390 00:1824: A0 15 18 18                  dw      BRANCH,SPACES_1
  3391 00:1828: 6F 07        SPACES_2:       dw      DROP
  3392 00:182A: AD 0E                        dw      EXIT
  3393                        
  3394                        ; TYPE ( c-addr u -- )
  3395                        ;
  3396                        ; If u is greater than zero, display the character string specified by c-addr
  3397                        ; and u.
  3398                        ;
  3399                        ; In this implementation it is defined as
  3400                        ;
  3401                        ;   ?DUP IF
  3402                        ;     OVER + SWAP DO I C@ EMIT LOOP
  3403                        ;   ELSE DROP THEN
  3404                        
  3405 00:182C: 0E 18 00 04                  HEADER  4,"TYPE",NORMAL
       00:1830: 54 59 50 45 
  3406 00:1834: 20 32 14     TYPE:           jsr     DO_COLON
  3407 00:1837: 43 07                        dw      QUERY_DUP
  3408 00:1839: C1 15 53 18                  dw      QUERY_BRANCH,TYPE_2
  3409 00:183D: A3 07                        dw      OVER
  3410 00:183F: FA 08                        dw      PLUS
  3411 00:1841: F6 07                        dw      SWAP
  3412 00:1843: 6F 15                        dw      DO_DO
  3413 00:1845: 7A 08        TYPE_1:         dw      I
  3414 00:1847: 07 06                        dw      C_FETCH
  3415 00:1849: D0 17                        dw      EMIT
  3416 00:184B: 2E 16 45 18                  dw      DO_LOOP,TYPE_1
  3417 00:184F: A0 15 55 18                  dw      BRANCH,TYPE_3
  3418 00:1853: 6F 07        TYPE_2          dw      DROP
  3419 00:1855: AD 0E        TYPE_3          dw      EXIT
  3420                        
  3421                        ;===============================================================================
  3422                        ;-------------------------------------------------------------------------------
  3423                        
  3424                        ; #
  Mon Apr 18 2016 23:59                                                                                                    Page 68


  3425                        ; #>
  3426                        ; #S
  3427                        ; SIGN
  3428                        
  3429                        ;===============================================================================
  3430                        ; Programming Tools
  3431                        ;-------------------------------------------------------------------------------
  3432                        
  3433                        ; .NYBBLE
  3434                        
  3435                        ;               HEADER  7,".NYBBLE",NORMAL
  3436                        DOT_NYBBLE:
  3437 00:1857: A5 01                        lda     <1
  3438 00:1859: 29 0F 00                     and     #$000f
  3439 00:185C: 09 30 00                     ora     #$0030
  3440 00:185F: C9 3A 00                     cmp     #$003a
  3441 00:1862: 90 03                        bcc     $+5
  3442 00:1864: 69 06 00                     adc     #$0006
  3443 00:1867: 20 xx xx                     jsr     UartTx
  3444 00:186A: 4C 6F 07                     jmp     DROP
  3445                        
  3446                        ; .BYTE
  3447                        
  3448 00:186D: 2F 18 00 05                  HEADER  5,".BYTE",NORMAL
       00:1871: 2E 42 59 54 
       00:1875: 45 
  3449 00:1876: 20 32 14     DOT_BYTE:       jsr     DO_COLON
  3450 00:1879: 80 07                        dw      DUP
  3451 00:187B: 08 16 04 00                  dw      DO_LITERAL,4
  3452 00:187F: F7 0D                        dw      RSHIFT
  3453 00:1881: 57 18                        dw      DOT_NYBBLE
  3454 00:1883: 57 18                        dw      DOT_NYBBLE
  3455 00:1885: 02 18                        dw      SPACE
  3456 00:1887: AD 0E                        dw      EXIT
  3457                        
  3458                        ; .WORD
  3459                        
  3460 00:1889: 70 18 00 05                  HEADER  5,".WORD",NORMAL
       00:188D: 2E 57 4F 52 
       00:1891: 44 
  3461 00:1892: 20 32 14     DOT_WORD:       jsr     DO_COLON
  3462 00:1895: 80 07                        dw      DUP
  3463 00:1897: 08 16 0C 00                  dw      DO_LITERAL,12
  3464 00:189B: F7 0D                        dw      RSHIFT
  3465 00:189D: 57 18                        dw      DOT_NYBBLE
  3466 00:189F: 80 07                        dw      DUP
  3467 00:18A1: 08 16 08 00                  dw      DO_LITERAL,8
  3468 00:18A5: F7 0D                        dw      RSHIFT
  3469 00:18A7: 57 18                        dw      DOT_NYBBLE
  3470 00:18A9: 80 07                        dw      DUP
  3471 00:18AB: 08 16 04 00                  dw      DO_LITERAL,4
  3472 00:18AF: F7 0D                        dw      RSHIFT
  3473 00:18B1: 57 18                        dw      DOT_NYBBLE
  3474 00:18B3: 57 18                        dw      DOT_NYBBLE
  3475 00:18B5: 02 18                        dw      SPACE
  3476 00:18B7: AD 0E                        dw      EXIT
  3477                        
  3478                        ; .DP
  Mon Apr 18 2016 23:59                                                                                                    Page 69


  3479                        
  3480 00:18B9: 8C 18 00 03                  HEADER  3,".DP",NORMAL
       00:18BD: 2E 44 50 
  3481 00:18C0: 20 32 14                     jsr     DO_COLON
  3482 00:18C3: 13 19                        dw      AT_DP
  3483 00:18C5: 92 18                        dw      DOT_WORD
  3484 00:18C7: AD 0E                        dw      EXIT
  3485                        
  3486 00:18C9: BC 18 00 03                  HEADER  3,".RP",NORMAL
       00:18CD: 2E 52 50 
  3487 00:18D0: 20 32 14                     jsr     DO_COLON
  3488 00:18D3: 28 19                        dw      AT_RP
  3489 00:18D5: 92 18                        dw      DOT_WORD
  3490 00:18D7: AD 0E                        dw      EXIT
  3491                        
  3492                        ; .S ( -- )
  3493                        
  3494 00:18D9: CC 18 00 02                  HEADER  2,".S",NORMAL
       00:18DD: 2E 53 
  3495 00:18DF: 20 32 14                     jsr     DO_COLON
  3496 00:18E2: 13 19                        dw      AT_DP
  3497 00:18E4: 4A 09                        dw      ONE_PLUS
  3498 00:18E6: 08 16 80 01                  dw      DO_LITERAL,DSTACK_END
  3499 00:18EA: F6 07                        dw      SWAP
  3500 00:18EC: 6F 15                        dw      DO_DO
  3501 00:18EE: 7A 08        DOT_S_1:        dw      I
  3502 00:18F0: B4 05                        dw      FETCH
  3503 00:18F2: 92 18                        dw      DOT_WORD
  3504 00:18F4: 08 16 02 00                  dw      DO_LITERAL,2
  3505 00:18F8: FA 13                        dw      DO_PLUS_LOOP
  3506 00:18FA: EE 18                        dw      DOT_S_1
  3507 00:18FC: AD 0E                        dw      EXIT
  3508                        
  3509                        ; ? ( a-addr -- )
  3510                        
  3511 00:18FE: DC 18 00 01                  HEADER  1,"?",NORMAL
       00:1902: 3F 
  3512 00:1903: 20 32 14                     jsr     DO_COLON
  3513 00:1906: B4 05                        dw      FETCH
  3514 00:1908: 92 18                        dw      DOT_WORD
  3515 00:190A: AD 0E                        dw      EXIT
  3516                        
  3517 00:190C: 01 19 00 03                  HEADER  3,"@DP",NORMAL
       00:1910: 40 44 50 
  3518                        AT_DP:
  3519 00:1913: 0B                           phd
  3520 00:1914: 7B                           tdc
  3521 00:1915: 3A                           dec     a
  3522 00:1916: 3A                           dec     a
  3523 00:1917: 5B                           tcd
  3524 00:1918: 68                           pla
  3525 00:1919: 85 01                        sta     <1
  3526 00:191B: BB C8 C8 7C                  CONTINUE
       00:191F: 00 00 
  3527                        
  3528 00:1921: 0F 19 00 03                  HEADER  3,"@RP",NORMAL
       00:1925: 40 52 50 
  3529                        AT_RP:
  Mon Apr 18 2016 23:59                                                                                                    Page 70


  3530 00:1928: 7B                           tdc
  3531 00:1929: 3A                           dec     a
  3532 00:192A: 3A                           dec     a
  3533 00:192B: 5B                           tcd
  3534 00:192C: BA                           tsx
  3535 00:192D: 86 01                        stx     <1
  3536 00:192F: BB C8 C8 7C                  CONTINUE
       00:1933: 00 00 
  3537                        
  3538                        
  3539                        ;-------------------------------------------------------------------------------
  3540                        
  3541                                        include "device.asm"
     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; Device Specific Words for the W65C816SXB
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ;------------------------------------------------------------------------------
    23                        
    24                        ; (TITLE) - ( -- )
    25                        ;
    26                        
    27                        ;               HEADER  7,"(TITLE)",NORMAL
    28 00:1935: 20 32 14     DO_TITLE:       jsr     DO_COLON
    29 00:1938: B7 16                        dw      DO_S_QUOTE
    30 00:193A: 1C 57 36 35                  db      28,"W65C816SXB ANS-Forth [16.04]"
       00:193E: 43 38 31 36 
       00:1942: 53 58 42 20 
       00:1946: 41 4E 53 2D 
       00:194A: 46 6F 72 74 
       00:194E: 68 20 5B 31 
       00:1952: 36 2E 30 34 
       00:1956: 5D 
    31 00:1957: AD 0E                        dw      EXIT
    32                        
    33                        ; BYE ( -- )
    34                        ;
    35                        ; Return control to the host operating system, if any.
    36                        
    37 00:1959: 24 19 00 03                  HEADER  3,"BYE",NORMAL
       00:195D: 42 59 45 
  Mon Apr 18 2016 23:59                                                                                                    Page 71


    38                        BYE:
    39 00:1960: 78                           sei
    40 00:1961: D8                           cld
    41 00:1962: 38 FB                        emulate
    42 00:1964: 6C FC FF                     jmp     ($fffc)         ; Reset the processor
    43                        
    44                        ; UNUSED ( -- u )
    45                        ;
    46                        ; u is the amount of space remaining in the region addressed by HERE , in
    47                        ; address units.
    48                        
    49 00:1967: 5C 19 00 06                  HEADER  6,"UNUSED",NORMAL
       00:196B: 55 4E 55 53 
       00:196F: 45 44 
    50 00:1971: 20 32 14     UNUSED:         jsr     DO_COLON
    51 00:1974: 08 16 00 7E                  dw      DO_LITERAL,$7e00
    52 00:1978: 1F 06                        dw      HERE
    53 00:197A: 10 09                        dw      MINUS
    54 00:197C: AD 0E                        dw      EXIT
    55                        
    56                        ;-------------------------------------------------------------------------------
    57                        
    58 00:197E: 6A 19 00 08                  HEADER  8,"ACIA$RXD",NORMAL
       00:1982: 41 43 49 41 
       00:1986: 24 52 58 44 
    59 00:198A: 20 4C 15                     jsr     DO_CONSTANT
    60 00:198D: 80 7F                        dw      $7f80
    61                        
    62 00:198F: 81 19 00 08                  HEADER  8,"ACIA$TXD",NORMAL
       00:1993: 41 43 49 41 
       00:1997: 24 54 58 44 
    63 00:199B: 20 4C 15                     jsr     DO_CONSTANT
    64 00:199E: 80 7F                        dw      $7f80
    65                        
    66 00:19A0: 92 19 00 07                  HEADER  7,"ACIA$SR",NORMAL
       00:19A4: 41 43 49 41 
       00:19A8: 24 53 52 
    67 00:19AB: 20 4C 15                     jsr     DO_CONSTANT
    68 00:19AE: 81 7F                        dw      $7f81
    69                        
    70 00:19B0: A3 19 00 08                  HEADER  8,"ACIA$CMD",NORMAL
       00:19B4: 41 43 49 41 
       00:19B8: 24 43 4D 44 
    71 00:19BC: 20 4C 15                     jsr     DO_CONSTANT
    72 00:19BF: 82 7F                        dw      $7f82
    73                        
    74 00:19C1: B3 19 00 08                  HEADER  8,"ACIA$CTL",NORMAL
       00:19C5: 41 43 49 41 
       00:19C9: 24 43 54 4C 
    75 00:19CD: 20 4C 15                     jsr     DO_CONSTANT
    76 00:19D0: 83 7F                        dw      $7f83
    77                        
    78                        ;-------------------------------------------------------------------------------
    79                        
    80 00:19D2: C4 19 00 07                  HEADER  7,"PIA$PIA",NORMAL
       00:19D6: 50 49 41 24 
       00:19DA: 50 49 41 
    81 00:19DD: 20 4C 15                     jsr     DO_CONSTANT
  Mon Apr 18 2016 23:59                                                                                                    Page 72


    82 00:19E0: A0 7F                        dw      $7fa0
    83                        
    84 00:19E2: D5 19 00 08                  HEADER  8,"PIA$DDRA",NORMAL
       00:19E6: 50 49 41 24 
       00:19EA: 44 44 52 41 
    85 00:19EE: 20 4C 15                     jsr     DO_CONSTANT
    86 00:19F1: A0 7F                        dw      $7fa0
    87                        
    88 00:19F3: E5 19 00 07                  HEADER  7,"PIA$CRA",NORMAL
       00:19F7: 50 49 41 24 
       00:19FB: 43 52 41 
    89 00:19FE: 20 4C 15                     jsr     DO_CONSTANT
    90 00:1A01: A1 7F                        dw      $7fa1
    91                        
    92 00:1A03: F6 19 00 07                  HEADER  7,"PIA$PIB",NORMAL
       00:1A07: 50 49 41 24 
       00:1A0B: 50 49 42 
    93 00:1A0E: 20 4C 15                     jsr     DO_CONSTANT
    94 00:1A11: A2 7F                        dw      $7fa2
    95                        
    96 00:1A13: 06 1A 00 08                  HEADER  8,"PIA$DDRB",NORMAL
       00:1A17: 50 49 41 24 
       00:1A1B: 44 44 52 42 
    97 00:1A1F: 20 4C 15                     jsr     DO_CONSTANT
    98 00:1A22: A2 7F                        dw      $7fa2
    99                        
   100 00:1A24: 16 1A 00 07                  HEADER  7,"PIA$CRB",NORMAL
       00:1A28: 50 49 41 24 
       00:1A2C: 43 52 42 
   101 00:1A2F: 20 4C 15                     jsr     DO_CONSTANT
   102 00:1A32: A3 7F                        dw      $7fa3
   103                        
   104                        ;-------------------------------------------------------------------------------
   105                        
   106 00:1A34: 27 1A 00 08                  HEADER  8,"VIA1$ORB",NORMAL
       00:1A38: 56 49 41 31 
       00:1A3C: 24 4F 52 42 
   107 00:1A40: 20 4C 15                     jsr     DO_CONSTANT
   108 00:1A43: C0 7F                        dw      $7fc0
   109                        
   110 00:1A45: 37 1A 00 08                  HEADER  8,"VIA1$IRB",NORMAL
       00:1A49: 56 49 41 31 
       00:1A4D: 24 49 52 42 
   111 00:1A51: 20 4C 15                     jsr     DO_CONSTANT
   112 00:1A54: C0 7F                        dw      $7fc0
   113                        
   114 00:1A56: 48 1A 00 08                  HEADER  8,"VIA1$ORA",NORMAL
       00:1A5A: 56 49 41 31 
       00:1A5E: 24 4F 52 41 
   115 00:1A62: 20 4C 15                     jsr     DO_CONSTANT
   116 00:1A65: C1 7F                        dw      $7fc1
   117                        
   118 00:1A67: 59 1A 00 08                  HEADER  8,"VIA1$IRA",NORMAL
       00:1A6B: 56 49 41 31 
       00:1A6F: 24 49 52 41 
   119 00:1A73: 20 4C 15                     jsr     DO_CONSTANT
   120 00:1A76: C1 7F                        dw      $7fc1
   121                        
  Mon Apr 18 2016 23:59                                                                                                    Page 73


   122 00:1A78: 6A 1A 00 09                  HEADER  9,"VIA1$DDRB",NORMAL
       00:1A7C: 56 49 41 31 
       00:1A80: 24 44 44 52 
       00:1A84: 42 
   123 00:1A85: 20 4C 15                     jsr     DO_CONSTANT
   124 00:1A88: C2 7F                        dw      $7fc2
   125                        
   126 00:1A8A: 7B 1A 00 09                  HEADER  9,"VIA1$DDRA",NORMAL
       00:1A8E: 56 49 41 31 
       00:1A92: 24 44 44 52 
       00:1A96: 41 
   127 00:1A97: 20 4C 15                     jsr     DO_CONSTANT
   128 00:1A9A: C3 7F                        dw      $7fc3
   129                        
   130 00:1A9C: 8D 1A 00 09                  HEADER  9,"VIA1$T1CL",NORMAL
       00:1AA0: 56 49 41 31 
       00:1AA4: 24 54 31 43 
       00:1AA8: 4C 
   131 00:1AA9: 20 4C 15                     jsr     DO_CONSTANT
   132 00:1AAC: C4 7F                        dw      $7fc4
   133                        
   134 00:1AAE: 9F 1A 00 09                  HEADER  9,"VIA1$T1CH",NORMAL
       00:1AB2: 56 49 41 31 
       00:1AB6: 24 54 31 43 
       00:1ABA: 48 
   135 00:1ABB: 20 4C 15                     jsr     DO_CONSTANT
   136 00:1ABE: C5 7F                        dw      $7fc5
   137                        
   138 00:1AC0: B1 1A 00 09                  HEADER  9,"VIA1$T1LL",NORMAL
       00:1AC4: 56 49 41 31 
       00:1AC8: 24 54 31 4C 
       00:1ACC: 4C 
   139 00:1ACD: 20 4C 15                     jsr     DO_CONSTANT
   140 00:1AD0: C6 7F                        dw      $7fc6
   141                        
   142 00:1AD2: C3 1A 00 09                  HEADER  9,"VIA1$T1LH",NORMAL
       00:1AD6: 56 49 41 31 
       00:1ADA: 24 54 31 4C 
       00:1ADE: 48 
   143 00:1ADF: 20 4C 15                     jsr     DO_CONSTANT
   144 00:1AE2: C7 7F                        dw      $7fc7
   145                        
   146 00:1AE4: D5 1A 00 09                  HEADER  9,"VIA1$T2CL",NORMAL
       00:1AE8: 56 49 41 31 
       00:1AEC: 24 54 32 43 
       00:1AF0: 4C 
   147 00:1AF1: 20 4C 15                     jsr     DO_CONSTANT
   148 00:1AF4: C8 7F                        dw      $7fc8
   149                        
   150 00:1AF6: E7 1A 00 09                  HEADER  9,"VIA1$T2CH",NORMAL
       00:1AFA: 56 49 41 31 
       00:1AFE: 24 54 32 43 
       00:1B02: 48 
   151 00:1B03: 20 4C 15                     jsr     DO_CONSTANT
   152 00:1B06: C9 7F                        dw      $7fc9
   153                        
   154 00:1B08: F9 1A 00 07                  HEADER  7,"VIA1$SR",NORMAL
       00:1B0C: 56 49 41 31 
  Mon Apr 18 2016 23:59                                                                                                    Page 74


       00:1B10: 24 53 52 
   155 00:1B13: 20 4C 15                     jsr     DO_CONSTANT
   156 00:1B16: CA 7F                        dw      $7fca
   157                        
   158 00:1B18: 0B 1B 00 08                  HEADER  8,"VIA1$ACR",NORMAL
       00:1B1C: 56 49 41 31 
       00:1B20: 24 41 43 52 
   159 00:1B24: 20 4C 15                     jsr     DO_CONSTANT
   160 00:1B27: CB 7F                        dw      $7fcb
   161                        
   162 00:1B29: 1B 1B 00 08                  HEADER  8,"VIA1$PCR",NORMAL
       00:1B2D: 56 49 41 31 
       00:1B31: 24 50 43 52 
   163 00:1B35: 20 4C 15                     jsr     DO_CONSTANT
   164 00:1B38: CC 7F                        dw      $7fcc
   165                        
   166 00:1B3A: 2C 1B 00 08                  HEADER  8,"VIA1$IFR",NORMAL
       00:1B3E: 56 49 41 31 
       00:1B42: 24 49 46 52 
   167 00:1B46: 20 4C 15                     jsr     DO_CONSTANT
   168 00:1B49: CD 7F                        dw      $7fcd
   169                        
   170 00:1B4B: 3D 1B 00 08                  HEADER  8,"VIA1$IER",NORMAL
       00:1B4F: 56 49 41 31 
       00:1B53: 24 49 45 52 
   171 00:1B57: 20 4C 15                     jsr     DO_CONSTANT
   172 00:1B5A: CE 7F                        dw      $7fce
   173                        
   174 00:1B5C: 4E 1B 00 09                  HEADER  9,"VIA1$ORAN",NORMAL
       00:1B60: 56 49 41 31 
       00:1B64: 24 4F 52 41 
       00:1B68: 4E 
   175 00:1B69: 20 4C 15                     jsr     DO_CONSTANT
   176 00:1B6C: CF 7F                        dw      $7fcf
   177                        
   178 00:1B6E: 5F 1B 00 09                  HEADER  9,"VIA1$IRAN",NORMAL
       00:1B72: 56 49 41 31 
       00:1B76: 24 49 52 41 
       00:1B7A: 4E 
   179 00:1B7B: 20 4C 15                     jsr     DO_CONSTANT
   180 00:1B7E: CF 7F                        dw      $7fcf
   181                        
   182                        ;-------------------------------------------------------------------------------
   183                        
   184                        
   185 00:1B80: 71 1B 00 08                  HEADER  8,"VIA2$ORB",NORMAL
       00:1B84: 56 49 41 32 
       00:1B88: 24 4F 52 42 
   186 00:1B8C: 20 4C 15                     jsr     DO_CONSTANT
   187 00:1B8F: E0 7F                        dw      $7fe0
   188                        
   189 00:1B91: 83 1B 00 08                  HEADER  8,"VIA2$IRB",NORMAL
       00:1B95: 56 49 41 32 
       00:1B99: 24 49 52 42 
   190 00:1B9D: 20 4C 15                     jsr     DO_CONSTANT
   191 00:1BA0: E0 7F                        dw      $7fe0
   192                        
   193 00:1BA2: 94 1B 00 08                  HEADER  8,"VIA2$ORA",NORMAL
  Mon Apr 18 2016 23:59                                                                                                    Page 75


       00:1BA6: 56 49 41 32 
       00:1BAA: 24 4F 52 41 
   194 00:1BAE: 20 4C 15                     jsr     DO_CONSTANT
   195 00:1BB1: E1 7F                        dw      $7fe1
   196                        
   197 00:1BB3: A5 1B 00 08                  HEADER  8,"VIA2$IRA",NORMAL
       00:1BB7: 56 49 41 32 
       00:1BBB: 24 49 52 41 
   198 00:1BBF: 20 4C 15                     jsr     DO_CONSTANT
   199 00:1BC2: E1 7F                        dw      $7fe1
   200                        
   201 00:1BC4: B6 1B 00 09                  HEADER  9,"VIA2$DDRB",NORMAL
       00:1BC8: 56 49 41 32 
       00:1BCC: 24 44 44 52 
       00:1BD0: 42 
   202 00:1BD1: 20 4C 15                     jsr     DO_CONSTANT
   203 00:1BD4: E2 7F                        dw      $7fe2
   204                        
   205 00:1BD6: C7 1B 00 09                  HEADER  9,"VIA2$DDRA",NORMAL
       00:1BDA: 56 49 41 32 
       00:1BDE: 24 44 44 52 
       00:1BE2: 41 
   206 00:1BE3: 20 4C 15                     jsr     DO_CONSTANT
   207 00:1BE6: E3 7F                        dw      $7fe3
   208                        
   209 00:1BE8: D9 1B 00 09                  HEADER  9,"VIA2$T1CL",NORMAL
       00:1BEC: 56 49 41 32 
       00:1BF0: 24 54 31 43 
       00:1BF4: 4C 
   210 00:1BF5: 20 4C 15                     jsr     DO_CONSTANT
   211 00:1BF8: E4 7F                        dw      $7fe4
   212                        
   213 00:1BFA: EB 1B 00 09                  HEADER  9,"VIA2$T1CH",NORMAL
       00:1BFE: 56 49 41 32 
       00:1C02: 24 54 31 43 
       00:1C06: 48 
   214 00:1C07: 20 4C 15                     jsr     DO_CONSTANT
   215 00:1C0A: E5 7F                        dw      $7fe5
   216                        
   217 00:1C0C: FD 1B 00 09                  HEADER  9,"VIA2$T1LL",NORMAL
       00:1C10: 56 49 41 32 
       00:1C14: 24 54 31 4C 
       00:1C18: 4C 
   218 00:1C19: 20 4C 15                     jsr     DO_CONSTANT
   219 00:1C1C: E6 7F                        dw      $7fe6
   220                        
   221 00:1C1E: 0F 1C 00 09                  HEADER  9,"VIA2$T1LH",NORMAL
       00:1C22: 56 49 41 32 
       00:1C26: 24 54 31 4C 
       00:1C2A: 48 
   222 00:1C2B: 20 4C 15                     jsr     DO_CONSTANT
   223 00:1C2E: E7 7F                        dw      $7fe7
   224                        
   225 00:1C30: 21 1C 00 09                  HEADER  9,"VIA2$T2CL",NORMAL
       00:1C34: 56 49 41 32 
       00:1C38: 24 54 32 43 
       00:1C3C: 4C 
   226 00:1C3D: 20 4C 15                     jsr     DO_CONSTANT
  Mon Apr 18 2016 23:59                                                                                                    Page 76


   227 00:1C40: E8 7F                        dw      $7fe8
   228                        
   229 00:1C42: 33 1C 00 09                  HEADER  9,"VIA2$T2CH",NORMAL
       00:1C46: 56 49 41 32 
       00:1C4A: 24 54 32 43 
       00:1C4E: 48 
   230 00:1C4F: 20 4C 15                     jsr     DO_CONSTANT
   231 00:1C52: E9 7F                        dw      $7fe9
   232                        
   233 00:1C54: 45 1C 00 07                  HEADER  7,"VIA2$SR",NORMAL
       00:1C58: 56 49 41 32 
       00:1C5C: 24 53 52 
   234 00:1C5F: 20 4C 15                     jsr     DO_CONSTANT
   235 00:1C62: EA 7F                        dw      $7fea
   236                        
   237 00:1C64: 57 1C 00 08                  HEADER  8,"VIA2$ACR",NORMAL
       00:1C68: 56 49 41 32 
       00:1C6C: 24 41 43 52 
   238 00:1C70: 20 4C 15                     jsr     DO_CONSTANT
   239 00:1C73: EB 7F                        dw      $7feb
   240                        
   241 00:1C75: 67 1C 00 08                  HEADER  8,"VIA2$PCR",NORMAL
       00:1C79: 56 49 41 32 
       00:1C7D: 24 50 43 52 
   242 00:1C81: 20 4C 15                     jsr     DO_CONSTANT
   243 00:1C84: EC 7F                        dw      $7fec
   244                        
   245 00:1C86: 78 1C 00 08                  HEADER  8,"VIA2$IFR",NORMAL
       00:1C8A: 56 49 41 32 
       00:1C8E: 24 49 46 52 
   246 00:1C92: 20 4C 15                     jsr     DO_CONSTANT
   247 00:1C95: ED 7F                        dw      $7fed
   248                        
   249 00:1C97: 89 1C 00 08                  HEADER  8,"VIA2$IER",NORMAL
       00:1C9B: 56 49 41 32 
       00:1C9F: 24 49 45 52 
   250 00:1CA3: 20 4C 15                     jsr     DO_CONSTANT
   251 00:1CA6: EE 7F                        dw      $7fee
   252                        
   253 00:1CA8: 9A 1C 00 09                  HEADER  9,"VIA2$ORAN",NORMAL
       00:1CAC: 56 49 41 32 
       00:1CB0: 24 4F 52 41 
       00:1CB4: 4E 
   254 00:1CB5: 20 4C 15                     jsr     DO_CONSTANT
   255 00:1CB8: EF 7F                        dw      $7fef
   256                        
   257 00:1CBA: AB 1C 00 09                  HEADER  9,"VIA2$IRAN",NORMAL
       00:1CBE: 56 49 41 32 
       00:1CC2: 24 49 52 41 
       00:1CC6: 4E 
   258 00:1CC7: 20 4C 15                     jsr     DO_CONSTANT
   259 00:1CCA: EF 7F                        dw      $7fef
  3542                        
  3543                                        TRAILER
  3544                        NEXT_WORD:
  3545                        
  3546                                        end

  Mon Apr 18 2016 23:59                                                                                                    Page 77



      Lines assembled: 5757
      Errors: 0
